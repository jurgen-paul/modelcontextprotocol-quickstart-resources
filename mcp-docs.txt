TITLE: Initialize and Interact with Asynchronous MCP Client (Java)
DESCRIPTION: This Java code illustrates the configuration and usage of an asynchronous Model Context Protocol (MCP) client, utilizing reactive programming patterns. It shows how to initialize the client, configure capabilities, chain operations like listing tools, calling tools, and managing resources and prompts, and set up consumers for real-time change notifications.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-client

LANGUAGE: Java
CODE:
```
// Create an async client with custom configuration
McpAsyncClient client = McpClient.async(transport)
    .requestTimeout(Duration.ofSeconds(10))
    .capabilities(ClientCapabilities.builder()
        .roots(true)      // Enable roots capability
        .sampling()       // Enable sampling capability
        .build())
    .sampling(request -> Mono.just(new CreateMessageResult(response)))
    .toolsChangeConsumer(tools -> Mono.fromRunnable(() -> {
        logger.info("Tools updated: {}", tools);
    }))
    .resourcesChangeConsumer(resources -> Mono.fromRunnable(() -> {
        logger.info("Resources updated: {}", resources);
    }))
    .promptsChangeConsumer(prompts -> Mono.fromRunnable(() -> {
        logger.info("Prompts updated: {}", prompts);
    }))
    .build();

// Initialize connection and use features
client.initialize()
    .flatMap(initResult -> client.listTools())
    .flatMap(tools -> {
        return client.callTool(new CallToolRequest(
            "calculator",
            Map.of("operation", "add", "a", 2, "b", 3)
        ));
    })
    .flatMap(result -> {
        return client.listResources()
            .flatMap(resources ->
                client.readResource(new ReadResourceRequest("resource://uri"))
            );
    })
    .flatMap(resource -> {
```

----------------------------------------

TITLE: Client `initialize` Request for MCP
DESCRIPTION: The client initiates the Model Context Protocol (MCP) connection by sending an `initialize` request. This request specifies the supported protocol version, client capabilities, and client implementation details to the server.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/basic/lifecycle

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "initialize",
  "params": {
    "protocolVersion": "2024-11-05",
    "capabilities": {
      "roots": {
        "listChanged": true
      },
      "sampling": {}
    },
    "clientInfo": {
      "name": "ExampleClient",
      "version": "1.0.0"
    }
  }
}
```

----------------------------------------

TITLE: Configure and Manage Asynchronous MCP Server in Java
DESCRIPTION: This Java code illustrates the setup and management of an `McpAsyncServer`, highlighting its asynchronous API. It shows how to configure server capabilities, register tools, resources, and prompts using reactive operations (`doOnSuccess`, `subscribe`), and gracefully close the server within the Model Context Protocol.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-server

LANGUAGE: Java
CODE:
```
// Create an async server with custom configuration
McpAsyncServer asyncServer = McpServer.async(transportProvider)
    .serverInfo("my-server", "1.0.0")
    .capabilities(ServerCapabilities.builder()
        .resources(false, true)     // Enable resource support
        .tools(true)                // Enable tool support
        .prompts(true)              // Enable prompt support
        .logging()                  // Enable logging support
        .completions()              // Enable completions support
        .build())
    .build();

// Register tools, resources, and prompts
asyncServer.addTool(asyncToolSpecification)
    .doOnSuccess(v -> logger.info("Tool registered"))
    .subscribe();

asyncServer.addResource(asyncResourceSpecification)
    .doOnSuccess(v -> logger.info("Resource registered"))
    .subscribe();

asyncServer.addPrompt(asyncPromptSpecification)
    .doOnSuccess(v -> logger.info("Prompt registered"))
    .subscribe();

// Close the server when done
asyncServer.close()
    .doOnSuccess(v -> logger.info("Server closed"))
    .subscribe();
```

----------------------------------------

TITLE: Request LLM Generation: sampling/createMessage
DESCRIPTION: Servers send a 'sampling/createMessage' request to initiate a language model generation. This request includes an array of messages (e.g., user prompts), optional model preferences (hints, intelligence/speed priority), a system prompt, and a maximum token limit for the response.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client/sampling

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "sampling/createMessage",
  "params": {
    "messages": [
      {
        "role": "user",
        "content": {
          "type": "text",
          "text": "What is the capital of France?"
        }
      }
    ],
    "modelPreferences": {
      "hints": [
        {
          "name": "claude-3-sonnet"
        }
      ],
      "intelligencePriority": 0.8,
      "speedPriority": 0.5
    },
    "systemPrompt": "You are a helpful assistant.",
    "maxTokens": 100
  }
}
```

----------------------------------------

TITLE: Initialize and Interact with Synchronous MCP Client (Java)
DESCRIPTION: This Java code demonstrates the setup and usage of a synchronous Model Context Protocol (MCP) client. It covers configuring client capabilities like roots and sampling, initializing the connection, performing operations such as listing and calling tools, managing resources, interacting with prompts, and adding/removing roots, concluding with a graceful shutdown.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-client

LANGUAGE: Java
CODE:
```
// Create a sync client with custom configuration
McpSyncClient client = McpClient.sync(transport)
    .requestTimeout(Duration.ofSeconds(10))
    .capabilities(ClientCapabilities.builder()
        .roots(true)      // Enable roots capability
        .sampling()       // Enable sampling capability
        .build())
    .sampling(request -> new CreateMessageResult(response))
    .build();

// Initialize connection
client.initialize();

// List available tools
ListToolsResult tools = client.listTools();

// Call a tool
CallToolResult result = client.callTool(
    new CallToolRequest("calculator",
        Map.of("operation", "add", "a", 2, "b", 3))
);

// List and read resources
ListResourcesResult resources = client.listResources();
ReadResourceResult resource = client.readResource(
    new ReadResourceRequest("resource://uri")
);

// List and use prompts
ListPromptsResult prompts = client.listPrompts();
GetPromptResult prompt = client.getPrompt(
    new GetPromptRequest("greeting", Map.of("name", "Spring"))
);

// Add/remove roots
client.addRoot(new Root("file:///path", "description"));
client.removeRoot("file:///path");

// Close client
client.closeGracefully();
```

----------------------------------------

TITLE: Process User Queries with Anthropic and Tool Calls (Kotlin)
DESCRIPTION: Implements the core logic for processing user queries using the Anthropic API. It sends user messages, handles AI responses, and manages tool calls. If the AI suggests a tool, it executes the tool via MCP, incorporates the result, and continues the conversation. Uses `MessageCreateParams` and `MessageParam` for API interaction.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: Kotlin
CODE:
```
private val messageParamsBuilder: MessageCreateParams.Builder = MessageCreateParams.builder()
    .model(Model.CLAUDE_3_5_SONNET_20241022)
    .maxTokens(1024)

suspend fun processQuery(query: String): String {
    val messages = mutableListOf(
        MessageParam.builder()
            .role(MessageParam.Role.USER)
            .content(query)
            .build()
    )

    val response = anthropic.messages().create(
        messageParamsBuilder
            .messages(messages)
            .tools(tools)
            .build()
    )

    val finalText = mutableListOf<String>()
    response.content().forEach { content ->
        when {
            content.isText() -> finalText.add(content.text().getOrNull()?.text() ?: "")

            content.isToolUse() -> {
                val toolName = content.toolUse().get().name()
                val toolArgs =
                    content.toolUse().get()._input().convert(object : TypeReference<Map<String, JsonValue>>() {})

                val result = mcp.callTool(
                    name = toolName,
                    arguments = toolArgs ?: emptyMap()
                )
                finalText.add("[Calling tool $toolName with args $toolArgs]")

                messages.add(
                    MessageParam.builder()
                        .role(MessageParam.Role.USER)
                        .content(
                            "\"type\": \"tool_result\",\n\"tool_name\": $toolName,\n\"result\": ${result?.content?.joinToString("\\n") { (it as TextContent).text ?: "" }}"
                        )
                        .build()
                )

                val aiResponse = anthropic.messages().create(
                    messageParamsBuilder
                        .messages(messages)
                        .build()
                )

                finalText.add(aiResponse.content().first().text().getOrNull()?.text() ?: "")
            }
        }
    }

    return finalText.joinToString("\n", prefix = "", postfix = "")
}
```

----------------------------------------

TITLE: Setting up the MCP Server Instance
DESCRIPTION: This Kotlin code initializes an MCP (Model Context Protocol) server with a 'weather' tool implementation and sets up communication using standard I/O. It demonstrates how to create a server instance, define its capabilities, and connect it to a transport layer, ensuring the server runs until explicitly closed.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: Kotlin
CODE:
```
fun `run mcp server`() {
    val server = Server(
        Implementation(
            name = "weather",
            version = "1.0.0"
        ),
        ServerOptions(
            capabilities = ServerCapabilities(tools = ServerCapabilities.Tools(listChanged = true))
        )
    )

    val transport = StdioServerTransport(
        System.`in`.asInput(),
        System.out.asSink().buffered()
    )

    runBlocking {
        server.connect(transport)
        val done = Job()
        server.onClose {
            done.complete()
        }
        done.join()
    }
}
```

----------------------------------------

TITLE: Detecting MCP Transport Type for Backwards Compatibility
DESCRIPTION: This TypeScript function attempts to detect the appropriate Model Context Protocol (MCP) transport type for a given server URL. It first tries to use Streamable HTTP by sending a POST request with specific headers. If that fails, it falls back to the legacy Server-Sent Events (SSE) transport by issuing a GET request. This ensures compatibility with both modern and older MCP server implementations.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/transports

LANGUAGE: TypeScript
CODE:
```
async function detectTransport(serverUrl: string): Promise<TransportType> {
  try {
    // Try Streamable HTTP first
    const response = await fetch(serverUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json, text/event-stream"
      },
      body: JSON.stringify({
        jsonrpc: "2.0",
        method: "initialize",
        params: {
          /* ... */
        }
      })
    });

    if (response.ok) {
      return "streamable-http";
    }
  } catch (error) {
    // Fall back to legacy SSE
    const sseResponse = await fetch(serverUrl, {
      method: "GET",
      headers: { Accept: "text/event-stream" }
    });

    if (sseResponse.ok) {
      return "legacy-sse";
    n}
  }

  throw new Error("Unsupported transport");
}
```

----------------------------------------

TITLE: Kotlin: Implement Tool Execution for Weather API
DESCRIPTION: This Kotlin code demonstrates setting up an HTTP client for `weather.gov` and registering two tools with an MCP server. The `get_alerts` tool fetches weather alerts by US state, and the `get_forecast` tool retrieves weather forecasts by latitude and longitude. Both tools include input schema definitions and handle argument parsing and validation.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: kotlin
CODE:
```
// Create an HTTP client with a default request configuration and JSON content negotiation
val httpClient = HttpClient {
    defaultRequest {
        url("https://api.weather.gov")
        headers {
            append("Accept", "application/geo+json")
            append("User-Agent", "WeatherApiClient/1.0")
        }
        contentType(ContentType.Application.Json)
    }
    // Install content negotiation plugin for JSON serialization/deserialization
    install(ContentNegotiation) { json(Json { ignoreUnknownKeys = true }) }
}

// Register a tool to fetch weather alerts by state
server.addTool(
    name = "get_alerts",
    description = """
        Get weather alerts for a US state. Input is Two-letter US state code (e.g. CA, NY)
    """.trimIndent(),
    inputSchema = Tool.Input(
        properties = buildJsonObject {
            putJsonObject("state") {
                put("type", "string")
                put("description", "Two-letter US state code (e.g. CA, NY)")
            }
        },
        required = listOf("state")
    )
) { request ->
    val state = request.arguments["state"]?.jsonPrimitive?.content
    if (state == null) {
        return@addTool CallToolResult(
            content = listOf(TextContent("The 'state' parameter is required."))
        )
    }

    val alerts = httpClient.getAlerts(state)

    CallToolResult(content = alerts.map { TextContent(it) })
}

// Register a tool to fetch weather forecast by latitude and longitude
server.addTool(
    name = "get_forecast",
    description = """
        Get weather forecast for a specific latitude/longitude
    """.trimIndent(),
    inputSchema = Tool.Input(
        properties = buildJsonObject {
            putJsonObject("latitude") { put("type", "number") }
            putJsonObject("longitude") { put("type", "number") }
        },
        required = listOf("latitude", "longitude")
    )
) { request ->
    val latitude = request.arguments["latitude"]?.jsonPrimitive?.doubleOrNull
    val longitude = request.arguments["longitude"]?.jsonPrimitive?.doubleOrNull
    if (latitude == null || longitude == null) {
        return@addTool CallToolResult(
            content = listOf(TextContent("The 'latitude' and 'longitude' parameters are required."))
        )
    }

    val forecast = httpClient.getForecast(latitude, longitude)

    CallToolResult(content = forecast.map { TextContent(it) })
```

----------------------------------------

TITLE: Example MCP Client GET Request with Access Token
DESCRIPTION: This example demonstrates an MCP client making a GET request to the /v1/contexts endpoint. The request includes the Host header and the Authorization header with a Bearer token, as required for all authenticated resource requests.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/basic/authorization

LANGUAGE: HTTP
CODE:
```
GET /v1/contexts HTTP/1.1
Host: mcp.example.com
Authorization: Bearer eyJhbGciOiJIUzI1NiIs...
```

----------------------------------------

TITLE: Implement Python Custom Transport with AnyIO Context Manager
DESCRIPTION: This Python snippet demonstrates a custom transport implementation using `anyio` as an asynchronous context manager. It sets up streams for reading and writing JSON-RPC messages, manages a task group for message processing, and ensures proper resource cleanup upon exit or error.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/transports

LANGUAGE: Python
CODE:
```
@contextmanager
async def create_transport(
    read_stream: MemoryObjectReceiveStream[JSONRPCMessage | Exception],
    write_stream: MemoryObjectSendStream[JSONRPCMessage]
):
    """
    Transport interface for MCP.

    Args:
        read_stream: Stream to read incoming messages from
        write_stream: Stream to write outgoing messages to
    """
    async with anyio.create_task_group() as tg:
        try:
            # Start processing messages
            tg.start_soon(lambda: process_messages(read_stream))

            # Send messages
            async with write_stream:
                yield write_stream

        except Exception as exc:
            # Handle errors
            raise exc
        finally:
            # Clean up
            tg.cancel_scope.cancel()
            await write_stream.aclose()
            await read_stream.aclose()
```

----------------------------------------

TITLE: Implement Interactive Chat Loop and Cleanup in Python
DESCRIPTION: This Python snippet defines `chat_loop` for an interactive command-line interface, allowing users to input queries and receive responses, and `cleanup` for proper resource management using `AsyncExitStack`.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: Python
CODE:
```
async def chat_loop(self):
    """Run an interactive chat loop"""
    print("\nMCP Client Started!")
    print("Type your queries or 'quit' to exit.")

    while True:
        try:
            query = input("\nQuery: ").strip()

            if query.lower() == 'quit':
                break

            response = await self.process_query(query)
            print("\n" + response)

        except Exception as e:
            print(f"\nError: {str(e)}")

async def cleanup(self):
    """Clean up resources"""
    await self.exit_stack.aclose()
```

----------------------------------------

TITLE: Execute Tools Asynchronously with MCP Client (Java)
DESCRIPTION: Illustrates how to list available server-side tools and execute a specific tool with parameters using the asynchronous API of the Model Context Protocol (MCP) client. This approach uses reactive streams (e.g., Project Reactor) for non-blocking operations.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-client

LANGUAGE: Java
CODE:
```
// List available tools asynchronously
client.listTools()
    .doOnNext(tools -> tools.forEach(tool ->
        System.out.println(tool.getName())))
    .subscribe();

// Execute a tool asynchronously
client.callTool("calculator", Map.of(
        "operation", "add",
        "a", 1,
        "b", 2
    ))
    .subscribe();
```

----------------------------------------

TITLE: Process Queries with Claude and Tools in Python
DESCRIPTION: This asynchronous method handles user queries by interacting with the Claude API and available tools. It prepares messages for Claude, retrieves available tools from the MCP server, and then makes an initial call to Claude. The method processes Claude's response, executing tool calls when 'tool_use' content is present, and continues the conversation with Claude based on tool results.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: python
CODE:
```
async def process_query(self, query: str) -> str:
    """Process a query using Claude and available tools"""
    messages = [
        {
            "role": "user",
            "content": query
        }
    ]

    response = await self.session.list_tools()
    available_tools = [{
        "name": tool.name,
        "description": tool.description,
        "input_schema": tool.inputSchema
    } for tool in response.tools]

    # Initial Claude API call
    response = self.anthropic.messages.create(
        model="claude-3-5-sonnet-20241022",
        max_tokens=1000,
        messages=messages,
        tools=available_tools
    )

    # Process response and handle tool calls
    final_text = []

    assistant_message_content = []
    for content in response.content:
        if content.type == 'text':
            final_text.append(content.text)
            assistant_message_content.append(content)
        elif content.type == 'tool_use':
            tool_name = content.name
            tool_args = content.input

            # Execute tool call
            result = await self.session.call_tool(tool_name, tool_args)
            final_text.append(f"[Calling tool {tool_name} with args {tool_args}]")

            assistant_message_content.append(content)
            messages.append({
                "role": "assistant",
                "content": assistant_message_content
            })
            messages.append({
                "role": "user",
                "content": [
                    {
                        "type": "tool_result",
                        "tool_use_id": content.id,
                        "content": result.content
                    }
                ]
            })

            # Get next response from Claude
            response = self.anthropic.messages.create(
                model="claude-3-5-sonnet-20241022",
                max_tokens=1000,
                messages=messages,
                tools=available_tools
            )

            final_text.append(response.content[0].text)

    return "\n".join(final_text)
```

----------------------------------------

TITLE: Defining a Server-Side Calculator Tool with Model Preferences
DESCRIPTION: This Java snippet demonstrates how to define an asynchronous server-side tool that acts as a calculator. It configures model preferences such as intelligence and speed priority, sets a system prompt for the model's behavior, and limits the maximum tokens in the response. The tool processes the model's output to return a numerical answer.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-server

LANGUAGE: Java
CODE:
```
                .intelligencePriority(0.8)  // Prioritize intelligence
                .speedPriority(0.5)         // Moderate speed importance
                .build())
            .systemPrompt("You are a helpful calculator assistant. Provide only the numerical answer.")
            .maxTokens(100)
            .build();

        // Request sampling from the client
        return exchange.createMessage(request)
            .map(result -> {
                // Process the result
                String answer = result.content().text();
                return new CallToolResult(answer, false);
            });
    }
);

// Add the tool to the server
server.addTool(calculatorTool)
    .subscribe();
```

----------------------------------------

TITLE: Model Context Protocol Message Type Interfaces
DESCRIPTION: Defines the core message structures used in the Model Context Protocol (MCP) for requests, successful results, errors, and one-way notifications, all based on JSON-RPC 2.0.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/architecture

LANGUAGE: TypeScript
CODE:
```
interface Request {
  method: string;
  params?: { ... };
}

interface Result {
  [key: string]: unknown;
}

interface Error {
  code: number;
  message: string;
  data?: unknown;
}

interface Notification {
  method: string;
  params?: { ... };
}
```

----------------------------------------

TITLE: Define NWS API Helper Functions in Python
DESCRIPTION: This section provides two asynchronous helper functions crucial for interacting with the National Weather Service (NWS) API. `make_nws_request` handles HTTP GET requests to the NWS API, including proper headers, error handling, and JSON parsing. `format_alert` takes a raw alert feature dictionary and formats it into a human-readable string, extracting key details like event, area, severity, description, and instructions.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: python
CODE:
```
async def make_nws_request(url: str) -> dict[str, Any] | None:
    """Make a request to the NWS API with proper error handling."""
    headers = {
        "User-Agent": USER_AGENT,
        "Accept": "application/geo+json"
    }
    async with httpx.AsyncClient() as client:
        try:
            response = await client.get(url, headers=headers, timeout=30.0)
            response.raise_for_status()
            return response.json()
        except Exception:
            return None

def format_alert(feature: dict) -> str:
    """Format an alert feature into a readable string."""
    props = feature["properties"]
    return f"""
Event: {props.get('event', 'Unknown')}
Area: {props.get('areaDesc', 'Unknown')}
Severity: {props.get('severity', 'Unknown')}
Description: {props.get('description', 'No description available')}
Instructions: {props.get('instruction', 'No specific instructions provided')}
"""
```

----------------------------------------

TITLE: MCP Pagination Response Format
DESCRIPTION: This JSON snippet illustrates the server's response format when paginating results in the Model Context Protocol. It includes the current page of results and an optional "nextCursor" field, which indicates if more results are available and provides the token for the next page.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/utilities/pagination

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": "123",
  "result": {
    "resources": [...],
    "nextCursor": "eyJwYWdlIjogM30="
  }
}
```

----------------------------------------

TITLE: Define API Integration Tool Schema (GitHub Issue)
DESCRIPTION: This JSON schema defines a 'github_create_issue' tool for integrating with the GitHub API, specifying 'title', 'body', and 'labels' as input properties.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/tools

LANGUAGE: JSON
CODE:
```
{
  "name": "github_create_issue",
  "description": "Create a GitHub issue",
  "inputSchema": {
    "type": "object",
    "properties": {
      "title": { "type": "string" },
      "body": { "type": "string" },
      "labels": { "type": "array", "items": { "type": "string" } }
    }
  }
}
```

----------------------------------------

TITLE: Call Tool Response (JSON-RPC)
DESCRIPTION: Illustrates the JSON-RPC response format for a successful tool invocation, including the tool's content result and error status.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/tools

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "Current weather in New York:\nTemperature: 72°F\nConditions: Partly cloudy"
      }
    ],
    "isError": false
  }
}
```

----------------------------------------

TITLE: Setting up Anthropic API Key in .env
DESCRIPTION: This section details the steps to securely configure your Anthropic API key. It involves creating a `.env` file, adding your API key to it, and ensuring the `.env` file is ignored by Git to prevent accidental exposure.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: Shell
CODE:
```
# Create .env file
touch .env
```

LANGUAGE: Text
CODE:
```
ANTHROPIC_API_KEY=<your key here>
```

LANGUAGE: Shell
CODE:
```
echo ".env" >> .gitignore
```

----------------------------------------

TITLE: Security Considerations for Tools
DESCRIPTION: Outlines critical security measures for both servers and clients when interacting with tools, covering validation, access controls, rate limiting, sanitization, user confirmation, timeouts, and logging.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/tools

LANGUAGE: APIDOC
CODE:
```
Security Considerations:
  Servers MUST:
    - Validate all tool inputs.
    - Implement proper access controls.
    - Rate limit tool invocations.
    - Sanitize tool outputs.
  Clients SHOULD:
    - Prompt for user confirmation on sensitive operations.
    - Show tool inputs to the user before calling the server, to avoid malicious or accidental data exfiltration.
    - Validate tool results before passing to LLM.
    - Implement timeouts for tool calls.
    - Log tool usage for audit purposes.
```

----------------------------------------

TITLE: Connect to MCP Server and Initialize Tools (Kotlin)
DESCRIPTION: Implements a suspend function to connect to an MCP server by launching a server script (JS, Python, or JAR) as a process. It establishes a client transport, connects to the MCP, lists available tools, and initializes them for use. Handles process creation, input/output streaming, and error handling.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: Kotlin
CODE:
```
suspend fun connectToServer(serverScriptPath: String) {
    try {
        val command = buildList {
            when (serverScriptPath.substringAfterLast(".")) {
                "js" -> add("node")
                "py" -> add(if (System.getProperty("os.name").lowercase().contains("win")) "python" else "python3")
                "jar" -> addAll(listOf("java", "-jar"))
                else -> throw IllegalArgumentException("Server script must be a .js, .py or .jar file")
            }
            add(serverScriptPath)
        }

        val process = ProcessBuilder(command).start()
        val transport = StdioClientTransport(
            input = process.inputStream.asSource().buffered(),
            output = process.outputStream.asSink().buffered()
        )

        mcp.connect(transport)

        val toolsResult = mcp.listTools()
        tools = toolsResult?.tools?.map { tool ->
            ToolUnion.ofTool(
                Tool.builder()
                    .name(tool.name)
                    .description(tool.description ?: "")
                    .inputSchema(
                        Tool.InputSchema.builder()
                            .type(JsonValue.from(tool.inputSchema.type))
                            .properties(tool.inputSchema.properties.toJsonValue())
                            .putAdditionalProperty("required", JsonValue.from(tool.inputSchema.required))
                            .build()
                    )
                    .build()
            )
        } ?: emptyList()
        println("Connected to server with tools: ${tools.joinToString(", ") { it.tool().get().name() }}")
    } catch (e: Exception) {
        println("Failed to connect to MCP server: $e")
        throw e
    }
}
```

----------------------------------------

TITLE: Implement MCP Server Connection Method
DESCRIPTION: Provides the TypeScript implementation for the `connectToServer` method within the `MCPClient` class. This method handles establishing a connection to an MCP server, determining the correct command based on the server script type (.js or .py), and listing available tools from the connected server.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: typescript
CODE:
```
async connectToServer(serverScriptPath: string) {
  try {
    const isJs = serverScriptPath.endsWith(".js");
    const isPy = serverScriptPath.endsWith(".py");
    if (!isJs && !isPy) {
      throw new Error("Server script must be a .js or .py file");
    }
    const command = isPy
      ? process.platform === "win32"
        ? "python"
        : "python3"
      : process.execPath;

    this.transport = new StdioClientTransport({
      command,
      args: [serverScriptPath],
    });
    await this.mcp.connect(this.transport);

    const toolsResult = await this.mcp.listTools();
    this.tools = toolsResult.tools.map((tool) => {
      return {
        name: tool.name,
        description: tool.description,
        input_schema: tool.inputSchema,
      };
    });
    console.log(
      "Connected to server with tools:",
      this.tools.map(({ name }) => name)
    );
  } catch (e) {
    console.log("Failed to connect to MCP server: ", e);
    throw e;
  }
}
```

----------------------------------------

TITLE: Connect to MCP Server in Python
DESCRIPTION: This asynchronous method establishes a connection to an MCP server. It validates the server script path to ensure it's either a Python (.py) or JavaScript (.js) file, then uses StdioServerParameters to set up a standard I/O transport. After initializing a client session, it lists available tools from the connected server.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: python
CODE:
```
async def connect_to_server(self, server_script_path: str):
    """Connect to an MCP server

    Args:
        server_script_path: Path to the server script (.py or .js)
    """
    is_python = server_script_path.endswith('.py')
    is_js = server_script_path.endswith('.js')
    if not (is_python or is_js):
        raise ValueError("Server script must be a .py or .js file")

    command = "python" if is_python else "node"
    server_params = StdioServerParameters(
        command=command,
        args=[server_script_path],
        env=None
    )

    stdio_transport = await self.exit_stack.enter_async_context(stdio_client(server_params))
    self.stdio, self.write = stdio_transport
    self.session = await self.exit_stack.enter_async_context(ClientSession(self.stdio, self.write))

    await self.session.initialize()

    # List available tools
    response = await self.session.list_tools()
    tools = response.tools
    print("\nConnected to server with tools:", [tool.name for tool in tools])
```

----------------------------------------

TITLE: Define a multi-step debug workflow in JavaScript
DESCRIPTION: This JavaScript snippet defines a 'debug-error' workflow object with an asynchronous 'getMessages' method. It demonstrates how to construct a sequence of user and assistant messages for a multi-step debugging conversation, dynamically incorporating an error message into the initial prompt.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/prompts

LANGUAGE: JavaScript
CODE:
```
const debugWorkflow = {
  name: "debug-error",
  async getMessages(error: string) {
    return [
      {
        role: "user",
        content: {
          type: "text",
          text: `Here's an error I'm seeing: ${error}`,
        },
      },
      {
        role: "assistant",
        content: {
          type: "text",
          text: "I'll help analyze this error. What have you tried so far?",
        },
      },
      {
        role: "user",
        content: {
          type: "text",
          text: "I've tried restarting the service, but the error persists.",
        },
      },
    ];
  },
};
```

----------------------------------------

TITLE: Define Tool Annotations for Different Scenarios
DESCRIPTION: This snippet demonstrates how to define various tools using JSON objects, incorporating `inputSchema` and `annotations` to describe their purpose, required inputs, and behavioral hints such as `readOnlyHint`, `destructiveHint`, `idempotentHint`, and `openWorldHint` for different use cases like web search, file deletion, and record creation.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/tools

LANGUAGE: JSON
CODE:
```
// A read-only search tool
{
  name: "web_search",
  description: "Search the web for information",
  inputSchema: {
    type: "object",
    properties: {
      query: { type: "string" }
    },
    required: ["query"]
  },
  annotations: {
    title: "Web Search",
    readOnlyHint: true,
    openWorldHint: true
  }
}

// A destructive file deletion tool
{
  name: "delete_file",
  description: "Delete a file from the filesystem",
  inputSchema: {
    type: "object",
    properties: {
      path: { type: "string" }
    },
    required: ["path"]
  },
  annotations: {
    title: "Delete File",
    readOnlyHint: false,
    destructiveHint: true,
    idempotentHint: true,
    openWorldHint: false
  }
}

// A non-destructive database record creation tool
{
  name: "create_record",
  description: "Create a new record in the database",
  inputSchema: {
    type: "object",
    properties: {
      table: { type: "string" },
      data: { type: "object" }
    },
    required: ["table", "data"]
  },
  annotations: {
    title: "Create Database Record",
    readOnlyHint: false,
    destructiveHint: false,
    idempotentHint: false,
    openWorldHint: false
  }
}
```

----------------------------------------

TITLE: Set up Python Project and Virtual Environment on MacOS/Linux
DESCRIPTION: These commands create a new project directory, initialize a virtual environment using `uv`, activate it, install necessary dependencies (`mcp[cli]` and `httpx`), and create the main server file `weather.py` for your MCP server.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: Shell
CODE:
```
# Create a new directory for our project
uv init weather
cd weather

# Create virtual environment and activate it
uv venv
source .venv/bin/activate

# Install dependencies
uv add "mcp[cli]" httpx

# Create our server file
touch weather.py
```

----------------------------------------

TITLE: Response for Listing Available Tools in MCP
DESCRIPTION: The server's response to a 'tools/list' request provides a list of available tools. Each tool includes its 'name', 'description', and an 'inputSchema' defining its expected parameters. The response also contains a 'nextCursor' for retrieving subsequent pages of tools.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/tools

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "tools": [
      {
        "name": "get_weather",
        "description": "Get current weather information for a location",
        "inputSchema": {
          "type": "object",
          "properties": {
            "location": {
              "type": "string",
              "description": "City name or zip code"
            }
          },
          "required": ["location"]
        }
      }
    ],
    "nextCursor": "next-page-cursor"
  }
}
```

----------------------------------------

TITLE: APIDOC: tools/list Request Method
DESCRIPTION: Describes the 'tools/list' JSON-RPC request used by clients to discover available tools, supporting pagination via an optional cursor.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/tools

LANGUAGE: APIDOC
CODE:
```
Method: tools/list
Purpose: To discover available tools. Supports pagination.

Parameters:
  cursor: string (optional)
    Description: An optional cursor value for retrieving subsequent pages of results.
```

----------------------------------------

TITLE: APIDOC: tools/list Response Structure
DESCRIPTION: Describes the 'tools/list' JSON-RPC response, which returns a list of tools and a cursor for pagination.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/tools

LANGUAGE: APIDOC
CODE:
```
Response Object:
  result: object
    tools: array of objects
      Description: A list of available tools.
      Tool Object Properties:
        name: string
          Description: Unique identifier for the tool.
        title: string
          Description: Human-readable title for the tool.
        description: string
          Description: Brief explanation of the tool's purpose.
        inputSchema: object
          Description: JSON Schema defining the expected input parameters for the tool.
          InputSchema Properties:
            type: string
              Description: The type of the schema (e.g., "object").
            properties: object
              Description: Defines the input fields as key-value pairs.
            required: array of strings
              Description: List of required input field names.
    nextCursor: string (optional)
      Description: A cursor for retrieving the next page of results, if available.
```

----------------------------------------

TITLE: API Request: List Available Prompts
DESCRIPTION: Clients send a 'prompts/list' request to retrieve available prompt templates from the server. This operation supports pagination, allowing clients to specify an optional cursor for subsequent pages.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/prompts

LANGUAGE: APIDOC
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "prompts/list",
  "params": {
    "cursor": "optional-cursor-value"
  }
}
```

----------------------------------------

TITLE: Implement Spring AI Weather Service with Tool Annotations
DESCRIPTION: Demonstrates how to create a `WeatherService` in Spring AI using `RestClient` to interact with the National Weather Service API. It defines `@Tool` annotated methods (`getWeatherForecastByLocation`, `getAlerts`) to expose specific functionalities for AI models, including parameter descriptions and return value hints.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: Java
CODE:
```
@Service
public class WeatherService {

	private final RestClient restClient;

	public WeatherService() {
		this.restClient = RestClient.builder()
			.baseUrl("https://api.weather.gov")
			.defaultHeader("Accept", "application/geo+json")
			.defaultHeader("User-Agent", "WeatherApiClient/1.0 ([email protected])")
			.build();
	}

  @Tool(description = "Get weather forecast for a specific latitude/longitude")
  public String getWeatherForecastByLocation(
      double latitude,   // Latitude coordinate
      double longitude   // Longitude coordinate
  ) {
      // Returns detailed forecast including:
      // - Temperature and unit
      // - Wind speed and direction
      // - Detailed forecast description
  }

  @Tool(description = "Get weather alerts for a US state")
  public String getAlerts(
      @ToolParam(description = "Two-letter US state code (e.g. CA, NY)" String state
  ) {
      // Returns active alerts including:
      // - Event type
      // - Affected area
      // - Severity
      // - Description
      // - Safety instructions
  }

  // ......
}
```

----------------------------------------

TITLE: Requesting Autocompletion with MCP Client (Synchronous Java)
DESCRIPTION: Demonstrates how to make a synchronous autocompletion request using the Model Context Protocol (MCP) client in Java. It creates a CompleteRequest for a 'code_review' prompt, specifying 'language' as 'py', and then calls completeCompletion on a synchronous client instance.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-client

LANGUAGE: java
CODE:
```
CompleteRequest request = new CompleteRequest(
        new PromptReference("code_review"),
        new CompleteRequest.CompleteArgument("language", "py"));

CompleteResult result = syncMcpClient.completeCompletion(request);
```

----------------------------------------

TITLE: Streamable HTTP Client Connection (Python)
DESCRIPTION: Demonstrates how a Python client establishes a session with an MCP endpoint over HTTP. It uses `http_client` and `ClientSession` to connect and initialize the session.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/transports

LANGUAGE: Python
CODE:
```
async with http_client("http://localhost:8000/mcp") as transport:
    async with ClientSession(transport[0], transport[1]) as session:
        await session.initialize()
```

----------------------------------------

TITLE: Initialize MCP Client Class
DESCRIPTION: Sets up the basic structure for the 'MCPClient' class in Python, including necessary imports, loading environment variables, and initializing 'ClientSession', 'AsyncExitStack', and 'Anthropic' client objects.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: python
CODE:
```
import asyncio
from typing import Optional
from contextlib import AsyncExitStack

from mcp import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client

from anthropic import Anthropic
from dotenv import load_dotenv

load_dotenv()  # load environment variables from .env

class MCPClient:
    def __init__(self):
        # Initialize session and client objects
        self.session: Optional[ClientSession] = None
        self.exit_stack = AsyncExitStack()
        self.anthropic = Anthropic()
    # methods will go here
```

----------------------------------------

TITLE: Client `initialize` Request
DESCRIPTION: The client initiates the initialization phase by sending an `initialize` request to the server. This request includes the supported protocol version, client capabilities, and client implementation information. It must not be part of a JSON-RPC batch.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/basic/lifecycle

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "initialize",
  "params": {
    "protocolVersion": "2025-03-26",
    "capabilities": {
      "roots": {
        "listChanged": true
      },
      "sampling": {}
    },
    "clientInfo": {
      "name": "ExampleClient",
      "version": "1.0.0"
    }
  }
}
```

----------------------------------------

TITLE: Configure Server Capabilities (Java)
DESCRIPTION: This code demonstrates how to configure `ServerCapabilities` using a builder pattern. It allows enabling or disabling support for features like resources, tools, prompts, and logging, with options to include list change notifications for specific capabilities.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-server

LANGUAGE: Java
CODE:
```
var capabilities = ServerCapabilities.builder()
    .resources(false, true)  // Resource support with list changes notifications
    .tools(true)            // Tool support with list changes notifications
    .prompts(true)          // Prompt support with list changes notifications
    .logging()              // Enable logging support (enabled by default with logging level INFO)
    .build();
```

----------------------------------------

TITLE: Define Main Entry Point for Kotlin MCP Client
DESCRIPTION: This Kotlin `main` function serves as the entry point for the Model Context Protocol (MCP) client. It parses the server path from command-line arguments, initializes an `MCPClient`, connects to the specified server, and then starts an interactive chat loop. It throws an `IllegalArgumentException` if no server path is provided.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: kotlin
CODE:
```
fun main(args: Array<String>) = runBlocking {
    if (args.isEmpty()) throw IllegalArgumentException("Usage: java -jar <your_path>/build/libs/kotlin-mcp-client-0.1.0-all.jar <path_to_server_script>")
    val serverPath = args.first()
    val client = MCPClient()
    client.use {
        client.connectToServer(serverPath)
        client.chatLoop()
    }
}
```

----------------------------------------

TITLE: Protocol Shutdown Procedures
DESCRIPTION: Explains how to cleanly terminate the protocol connection for different transport mechanisms, including stdio and HTTP, detailing steps for client-initiated shutdown.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/basic/lifecycle

LANGUAGE: APIDOC
CODE:
```
Shutdown Procedures:
  stdio Transport:
    Client-initiated shutdown:
      1. Close input stream to child process (server).
      2. Wait for server to exit, or send SIGTERM if server does not exit within reasonable time.
      3. Send SIGKILL if server does not exit within reasonable time after SIGTERM.
    Server-initiated shutdown:
      MAY initiate shutdown by closing its output stream to the client and exiting.
  HTTP Transport:
    Shutdown is indicated by closing the associated HTTP connection(s).
```

----------------------------------------

TITLE: Register Weather Tools for Model Context Protocol Server
DESCRIPTION: This code snippet demonstrates how to register two weather-related tools, 'get-alerts' and 'get-forecast', with an MCP server. The 'get-alerts' tool fetches weather alerts for a given state, validating the state code. The 'get-forecast' tool retrieves a weather forecast for specified latitude and longitude, handling API calls to the NWS and formatting the output. Both tools include input validation using 'z' (likely Zod) and robust error handling for API failures.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: TypeScript
CODE:
```
// Register weather tools
server.tool(
  "get-alerts",
  "Get weather alerts for a state",
  {
    state: z.string().length(2).describe("Two-letter state code (e.g. CA, NY)"),
  },
  async ({ state }) => {
    const stateCode = state.toUpperCase();
    const alertsUrl = `${NWS_API_BASE}/alerts?area=${stateCode}`;
    const alertsData = await makeNWSRequest<AlertsResponse>(alertsUrl);

    if (!alertsData) {
      return {
        content: [
          {
            type: "text",
            text: "Failed to retrieve alerts data",
          },
        ],
      };
    }

    const features = alertsData.features || [];
    if (features.length === 0) {
      return {
        content: [
          {
            type: "text",
            text: `No active alerts for ${stateCode}`,
          },
        ],
      };
    }

    const formattedAlerts = features.map(formatAlert);
    const alertsText = `Active alerts for ${stateCode}:\n\n${formattedAlerts.join("\n")}`;

    return {
      content: [
        {
          type: "text",
          text: alertsText,
        },
      ],
    };
  },
);

server.tool(
  "get-forecast",
  "Get weather forecast for a location",
  {
    latitude: z.number().min(-90).max(90).describe("Latitude of the location"),
    longitude: z
      .number()
      .min(-180)
      .max(180)
      .describe("Longitude of the location"),
  },
  async ({ latitude, longitude }) => {
    // Get grid point data
    const pointsUrl = `${NWS_API_BASE}/points/${latitude.toFixed(4)},${longitude.toFixed(4)}`;
    const pointsData = await makeNWSRequest<PointsResponse>(pointsUrl);

    if (!pointsData) {
      return {
        content: [
          {
            type: "text",
            text: `Failed to retrieve grid point data for coordinates: ${latitude}, ${longitude}. This location may not be supported by the NWS API (only US locations are supported).`,
          },
        ],
      };
    }

    const forecastUrl = pointsData.properties?.forecast;
    if (!forecastUrl) {
      return {
        content: [
          {
            type: "text",
            text: "Failed to get forecast URL from grid point data",
          },
        ],
      };
    }

    // Get forecast data
    const forecastData = await makeNWSRequest<ForecastResponse>(forecastUrl);
    if (!forecastData) {
      return {
        content: [
          {
            type: "text",
            text: "Failed to retrieve forecast data",
          },
        ],
      };
    }

    const periods = forecastData.properties?.periods || [];
    if (periods.length === 0) {
      return {
        content: [
          {
            type: "text",
            text: "No forecast periods available",
          },
        ],
      };
    }

    // Format forecast periods
    const formattedForecast = periods.map((period: ForecastPeriod) =>
      [
        `${period.name || "Unknown"}:`,
        `Temperature: ${period.temperature || "Unknown"}°${period.temperatureUnit || "F"}`,
        `Wind: ${period.windSpeed || "Unknown"} ${period.windDirection || ""}`,
        `${period.shortForecast || "No forecast available"}`,
        "---",
      ].join("\n"),
    );

    const forecastText = `Forecast for ${latitude}, ${longitude}:\n\n${formattedForecast.join("\n")}`;

    return {
      content: [
        {
          type: "text",
          text: forecastText,
        },
      ],
    };
  },
);
```

----------------------------------------

TITLE: Python MCP Tool Execution for Weather Data
DESCRIPTION: Implements two `mcp.tool` decorated asynchronous functions: `get_alerts` retrieves active weather alerts for a specified US state, and `get_forecast` fetches detailed weather forecasts for a given latitude and longitude. Both tools leverage the NWS API and format the results for user consumption.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: Python
CODE:
```
@mcp.tool()
async def get_alerts(state: str) -> str:
    """Get weather alerts for a US state.

    Args:
        state: Two-letter US state code (e.g. CA, NY)
    """
    url = f"{NWS_API_BASE}/alerts/active/area/{state}"
    data = await make_nws_request(url)

    if not data or "features" not in data:
        return "Unable to fetch alerts or no alerts found."

    if not data["features"]:
        return "No active alerts for this state."

    alerts = [format_alert(feature) for feature in data["features"]]
    return "\n---\n".join(alerts)

@mcp.tool()
async def get_forecast(latitude: float, longitude: float) -> str:
    """Get weather forecast for a location.

    Args:
        latitude: Latitude of the location
        longitude: Longitude of the location
    """
    # First get the forecast grid endpoint
    points_url = f"{NWS_API_BASE}/points/{latitude},{longitude}"
    points_data = await make_nws_request(points_url)

    if not points_data:
        return "Unable to fetch forecast data for this location."

    # Get the forecast URL from the points response
    forecast_url = points_data["properties"]["forecast"]
    forecast_data = await make_nws_request(forecast_url)

    if not forecast_data:
        return "Unable to fetch detailed forecast."

    # Format the periods into a readable forecast
    periods = forecast_data["properties"]["periods"]
    forecasts = []
    for period in periods[:5]:  # Only show next 5 periods
        forecast = f"""
{period['name']}:
Temperature: {period['temperature']}°{period['temperatureUnit']}
Wind: {period['windSpeed']} {period['windDirection']}
Forecast: {period['detailedForecast']}
"""
        forecasts.append(forecast)

    return "\n---\n".join(forecasts)
```

----------------------------------------

TITLE: Model Context Protocol Primitives Overview
DESCRIPTION: This table outlines the core primitives used in the Model Context Protocol (MCP) for enhancing language model interactions. It details each primitive's control mechanism, a brief description of its function, and a practical example of its application.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server

LANGUAGE: APIDOC
CODE:
```
Primitive: Prompts
  Control: User-controlled
  Description: Interactive templates invoked by user choice
  Example: Slash commands, menu options

Primitive: Resources
  Control: Application-controlled
  Description: Contextual data attached and managed by the client
  Example: File contents, git history

Primitive: Tools
  Control: Model-controlled
  Description: Functions exposed to the LLM to take actions
  Example: API POST requests, file writing
```

----------------------------------------

TITLE: Request Timeout and Cancellation Handling
DESCRIPTION: Provides guidelines for establishing and managing timeouts for requests, including cancellation notifications and considerations for progress notifications.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/basic/lifecycle

LANGUAGE: APIDOC
CODE:
```
Timeout Management:
  Implementations SHOULD:
    - Establish timeouts for all sent requests to prevent hung connections and resource exhaustion.
    - Issue a cancellation notification for a request and stop waiting for a response if timeout occurs.
  SDKs and other middleware SHOULD:
    - Allow timeouts to be configured on a per-request basis.
  Implementations MAY:
    - Reset the timeout clock when receiving a progress notification.
  Implementations SHOULD always:
    - Enforce a maximum timeout, regardless of progress notifications.
```

----------------------------------------

TITLE: Add .env to .gitignore
DESCRIPTION: Command to add the '.env' file to your '.gitignore' to prevent it from being committed to version control, ensuring API key security.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: bash
CODE:
```
echo ".env" >> .gitignore
```

----------------------------------------

TITLE: Read Resource Contents API Request and Response
DESCRIPTION: To retrieve the actual contents of a resource, clients send a `resources/read` request, specifying the resource's URI. The response contains the resource's metadata and its content, which can be text or binary.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/resources

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "resources/read",
  "params": {
    "uri": "file:///project/src/main.rs"
  }
}
```

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "contents": [
      {
        "uri": "file:///project/src/main.rs",
        "name": "main.rs",
        "title": "Rust Software Application Main File",
        "mimeType": "text/x-rust",
        "text": "fn main() {\n    println!(\"Hello world!\");\n}"
      }
    ]
  }
}
```

----------------------------------------

TITLE: JSON-RPC Request: Get a Prompt
DESCRIPTION: Clients send a `prompts/get` request to retrieve a specific prompt by its unique name. This request can include arguments for prompt customization, which may be auto-completed via the completion API.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/prompts

LANGUAGE: APIDOC
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "prompts/get",
  "params": {
    "name": "code_review",
    "arguments": {
      "code": "def hello():\n    print('world')"
    }
  }
}
```

----------------------------------------

TITLE: Access Resources Synchronously with MCP Client (Java)
DESCRIPTION: Shows how to list available server-side resources and retrieve their content using a URI template via the synchronous API of the Model Context Protocol (MCP) client. Resources represent server-side data sources that clients can access.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-client

LANGUAGE: Java
CODE:
```
// List available resources and their names
var resources = client.listResources();
resources.forEach(resource -> System.out.println(resource.getName()));

// Retrieve resource content using a URI template
var content = client.getResource("file", Map.of(
    "path", "/path/to/file.txt"
));
```

----------------------------------------

TITLE: JSON RPC Error Response for Unsupported Protocol Version
DESCRIPTION: This JSON RPC error response illustrates a protocol version mismatch during initialization. It specifies the error code, a descriptive message, and data indicating the requested unsupported version and the list of supported protocol versions.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/basic/lifecycle

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -32602,
    "message": "Unsupported protocol version",
    "data": {
      "supported": ["2024-11-05"],
      "requested": "1.0.0"
    }
  }
}
```

----------------------------------------

TITLE: Read Resources Response Structure (APIDOC)
DESCRIPTION: Defines the structure of the server's response to a "resources/read" request. It contains a list of resource contents, where each entry specifies the URI, an optional MIME type, and either text or base64-encoded binary content.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/resources

LANGUAGE: APIDOC
CODE:
```
{
  contents: [
    {
      uri: string;        // The URI of the resource
      mimeType?: string;  // Optional MIME type

      // One of:
      text?: string;      // For text resources
      blob?: string;      // For binary resources (base64 encoded)
    }
  ]
}
```

----------------------------------------

TITLE: Define Kotlin Project Dependencies (Gradle)
DESCRIPTION: This snippet provides the necessary dependencies for a Kotlin project using Gradle, shown in both Kotlin DSL and Groovy DSL formats. It includes the Model Context Protocol (MCP) Kotlin SDK, SLF4J for logging, and the Anthropic Java client.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: Kotlin
CODE:
```
val mcpVersion = "0.4.0"
val slf4jVersion = "2.0.9"
val anthropicVersion = "0.8.0"

dependencies {
    implementation("io.modelcontextprotocol:kotlin-sdk:$mcpVersion")
    implementation("org.slf4j:slf4j-nop:$slf44jVersion")
    implementation("com.anthropic:anthropic-java:$anthropicVersion")
}
```

LANGUAGE: Groovy
CODE:
```
val mcpVersion = "0.4.0"
val slf4jVersion = "2.0.9"
val anthropicVersion = "0.8.0"

dependencies {
    implementation("io.modelcontextprotocol:kotlin-sdk:$mcpVersion")
    implementation("org.slf4j:slf4j-nop:$slf4jVersion")
    implementation("com.anthropic:anthropic-java:$anthropicVersion")
}
```

----------------------------------------

TITLE: Integrate Tool Annotations in TypeScript Server
DESCRIPTION: This example shows how to register a tool definition, including its `inputSchema` and `annotations`, within a TypeScript server implementation. It uses `server.setRequestHandler` to define a `calculate_sum` tool that adds two numbers, marking it as read-only and operating in a closed world.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/tools

LANGUAGE: TypeScript
CODE:
```
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [{
      name: "calculate_sum",
      description: "Add two numbers together",
      inputSchema: {
        type: "object",
        properties: {
          a: { type: "number" },
          b: { type: "number" }
        },
        required: ["a", "b"]
      },
      annotations: {
        title: "Calculate Sum",
        readOnlyHint: true,
        openWorldHint: false
      }
    }]
  };
});
```

----------------------------------------

TITLE: Set Up TypeScript Project Environment (MacOS/Linux)
DESCRIPTION: This snippet provides a sequence of bash commands for MacOS/Linux to set up a new TypeScript project. It includes creating a project directory, initializing an npm project, installing core and development dependencies for the Model Context Protocol SDK, and creating the initial source file structure.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: bash
CODE:
```
# Create a new directory for our project
mkdir weather
cd weather

# Initialize a new npm project
npm init -y

# Install dependencies
npm install @modelcontextprotocol/sdk zod
npm install -D @types/node typescript

# Create our files
mkdir src
touch src/index.ts
```

----------------------------------------

TITLE: Client Initialize Request (JSON-RPC)
DESCRIPTION: The client initiates the connection by sending an 'initialize' request to the server. This request includes the supported protocol version, client capabilities, and client implementation details, essential for capability negotiation and version agreement.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/basic/lifecycle

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "initialize",
  "params": {
    "protocolVersion": "2024-11-05",
    "capabilities": {
      "roots": {
        "listChanged": true
      },
      "sampling": {},
      "elicitation": {}
    },
    "clientInfo": {
      "name": "ExampleClient",
      "title": "Example Client Display Name",
      "version": "1.0.0"
    }
  }
}
```

----------------------------------------

TITLE: Implement Query Processing and Tool Call Handling
DESCRIPTION: Sets up an Anthropic chat client integrated with Microsoft.Extensions.AI for automatic tool invocation. It establishes an interactive console loop where user queries are sent to the server, and streaming responses are displayed, including a helper function for prompting input.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: C#
CODE:
```
using var anthropicClient = new AnthropicClient(new APIAuthentication(builder.Configuration["ANTHROPIC_API_KEY"])) 
    .Messages
    .AsBuilder()
    .UseFunctionInvocation()
    .Build();

var options = new ChatOptions
{
    MaxOutputTokens = 1000,
    ModelId = "claude-3-5-sonnet-20241022",
    Tools = [.. tools]
};

Console.ForegroundColor = ConsoleColor.Green;
Console.WriteLine("MCP Client Started!");
Console.ResetColor();

PromptForInput();
while(Console.ReadLine() is string query && !"exit".Equals(query, StringComparison.OrdinalIgnoreCase))
{
    if (string.IsNullOrWhiteSpace(query))
    {
        PromptForInput();
        continue;
    }

    await foreach (var message in anthropicClient.GetStreamingResponseAsync(query, options))
    {
        Console.Write(message);
    }
    Console.WriteLine();

    PromptForInput();
}

static void PromptForInput()
{
    Console.WriteLine("Enter a command (or 'exit' to quit):");
    Console.ForegroundColor = ConsoleColor.Cyan;
    Console.Write("> ");
    Console.ResetColor();
}
```

----------------------------------------

TITLE: MCP Server Resource Implementation Example
DESCRIPTION: Demonstrates a simple MCP server implementation for managing resources. It shows how to initialize a server with resource capabilities and set up request handlers for listing available resources and reading their contents, exemplified with an application log file.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/resources

LANGUAGE: TypeScript
CODE:
```
const server = new Server({
  name: "example-server",
  version: "1.0.0"
}, {
  capabilities: {
    resources: {}
  }
});

// List available resources
server.setRequestHandler(ListResourcesRequestSchema, async () => {
  return {
    resources: [
      {
        uri: "file:///logs/app.log",
        name: "Application Logs",
        mimeType: "text/plain"
      }
    ]
  };
});

// Read resource contents
server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
  const uri = request.params.uri;

  if (uri === "file:///logs/app.log") {
    const logContents = await readLogFile();
    return {
      contents: [
        {
          uri,
          mimeType: "text/plain",
          text: logContents
        }
      ]
    };
  }

  throw new Error("Resource not found");
});
```

LANGUAGE: Python
CODE:
```
app = Server("example-server")

@app.list_resources()
async def list_resources() -> list[types.Resource]:
    return [
        types.Resource(
            uri="file:///logs/app.log",
            name="Application Logs",
            mimeType="text/plain"
        )
    ]

@app.read_resource()
async def read_resource(uri: AnyUrl) -> str:
    if str(uri) == "file:///logs/app.log":
        log_contents = await read_log_file()
        return log_contents

    raise ValueError("Resource not found")

# Start server
async with stdio_server() as streams:
    await app.run(
        streams[0],
        streams[1],
        app.create_initialization_options()
    )
```

----------------------------------------

TITLE: Process Query with Claude and MCP Tools
DESCRIPTION: Adds the 'process_query' method to 'MCPClient', which uses Anthropic's Claude model to process user queries. It integrates with MCP tools, handling tool calls and incorporating tool results back into the conversation flow with Claude.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: python
CODE:
```
async def process_query(self, query: str) -> str:
    """Process a query using Claude and available tools"""
    messages = [
        {
            "role": "user",
            "content": query
        }
    ]

    response = await self.session.list_tools()
    available_tools = [{
        "name": tool.name,
        "description": tool.description,
        "input_schema": tool.inputSchema
    } for tool in response.tools]

    # Initial Claude API call
    response = self.anthropic.messages.create(
        model="claude-3-5-sonnet-20241022",
        max_tokens=1000,
        messages=messages,
        tools=available_tools
    )

    # Process response and handle tool calls
    final_text = []

    assistant_message_content = []
    for content in response.content:
        if content.type == 'text':
            final_text.append(content.text)
            assistant_message_content.append(content)
        elif content.type == 'tool_use':
            tool_name = content.name
            tool_args = content.input

            # Execute tool call
            result = await self.session.call_tool(tool_name, tool_args)
            final_text.append(f"[Calling tool {tool_name} with args {tool_args}]")

            assistant_message_content.append(content)
            messages.append({
                "role": "assistant",
                "content": assistant_message_content
            })
            messages.append({
                "role": "user",
                "content": [
                    {
                        "type": "tool_result",
                        "tool_use_id": content.id,
                        "content": result.content
                    }
                ]
            })

            # Get next response from Claude
            response = self.anthropic.messages.create(
                model="claude-3-5-sonnet-20241022",
                max_tokens=1000,
                messages=messages,
                tools=available_tools
            )

            final_text.append(response.content[0].text)

    return "\n".join(final_text)
```

----------------------------------------

TITLE: C# Weather API Tool Execution Handlers
DESCRIPTION: This C# class defines tool execution handlers for the National Weather Service API. It provides methods to retrieve active weather alerts for a US state and to get a detailed forecast for a specific geographic location (latitude/longitude).
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: C#
CODE:
```
using ModelContextProtocol.Server;
using System.ComponentModel;
using System.Globalization;
using System.Text.Json;

namespace QuickstartWeatherServer.Tools;

[McpServerToolType]
public static class WeatherTools
{
    [McpServerTool, Description("Get weather alerts for a US state.")]
    public static async Task<string> GetAlerts(
        HttpClient client,
        [Description("The US state to get alerts for.")] string state)
    {
        using var jsonDocument = await client.ReadJsonDocumentAsync($"/alerts/active/area/{state}");
        var jsonElement = jsonDocument.RootElement;
        var alerts = jsonElement.GetProperty("features").EnumerateArray();

        if (!alerts.Any())
        {
            return "No active alerts for this state.";
        }

        return string.Join("\n--\n", alerts.Select(alert =>
        {
            JsonElement properties = alert.GetProperty("properties");
            return $"""
                    Event: {properties.GetProperty("event").GetString()}
                    Area: {properties.GetProperty("areaDesc").GetString()}
                    Severity: {properties.GetProperty("severity").GetString()}
                    Description: {properties.GetProperty("description").GetString()}
                    Instruction: {properties.GetProperty("instruction").GetString()}
                    """;
        }));
    }

    [McpServerTool, Description("Get weather forecast for a location.")]
    public static async Task<string> GetForecast(
        HttpClient client,
        [Description("Latitude of the location.")] double latitude,
        [Description("Longitude of the location.")] double longitude)
    {
        var pointUrl = string.Create(CultureInfo.InvariantCulture, $"/points/{latitude},{longitude}");
        using var jsonDocument = await client.ReadJsonDocumentAsync(pointUrl);
        var forecastUrl = jsonDocument.RootElement.GetProperty("properties").GetProperty("forecast").GetString()
            ?? throw new Exception($"No forecast URL provided by {client.BaseAddress}points/{latitude},{longitude}");

        using var forecastDocument = await client.ReadJsonDocumentAsync(forecastUrl);
        var periods = forecastDocument.RootElement.GetProperty("properties").GetProperty("periods").EnumerateArray();

        return string.Join("\n---\n", periods.Select(period => $"""
                {period.GetProperty("name").GetString()}
                Temperature: {period.GetProperty("temperature").GetInt32()}°F
                Wind: {period.GetProperty("windSpeed").GetString()} {period.GetProperty("windDirection").GetString()}
                Forecast: {period.GetProperty("detailedForecast").GetString()}
                """));
    }
}
```

----------------------------------------

TITLE: Define Synchronous Tool Specification (Java)
DESCRIPTION: Illustrates how to define a synchronous tool specification using `McpServerFeatures.SyncToolSpecification`. This involves providing a `Tool` definition with a name, description, and a JSON schema for its parameters, followed by a synchronous call handler lambda function that implements the tool's logic. Tools enable AI models to perform calculations, access external APIs, and query databases.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-server

LANGUAGE: Java
CODE:
```
// Sync tool specification
var schema = """
            {
              "type" : "object",
              "id" : "urn:jsonschema:Operation",
              "properties" : {
                "operation" : {
                  "type" : "string"
                },
                "a" : {
                  "type" : "number"
                },
                "b" : {
                  "type" : "number"
                }
              }
            }
            """;
var syncToolSpecification = new McpServerFeatures.SyncToolSpecification(
    new Tool("calculator", "Basic calculator", schema),
    (exchange, arguments) -> {
        // Tool implementation
        return new CallToolResult(result, false);
    }
);
```

----------------------------------------

TITLE: Describe MCP Server Requirements to LLM
DESCRIPTION: This example demonstrates how to articulate the desired features and functionalities of an MCP server to an LLM. It outlines the server's interaction with a PostgreSQL database, resource exposure (table schemas), provision of SQL query tools, and inclusion of data analysis prompts.
SOURCE: https://modelcontextprotocol.io/introduction/tutorials/building-mcp-with-llms

LANGUAGE: Natural Language
CODE:
```
Build an MCP server that:
- Connects to my company's PostgreSQL database
- Exposes table schemas as resources
- Provides tools for running read-only SQL queries
- Includes prompts for common data analysis tasks
```

----------------------------------------

TITLE: Define Basic Kotlin MCP Client Structure
DESCRIPTION: This Kotlin code defines the basic structure of an `MCPClient` class, implementing `AutoCloseable`. It initializes `AnthropicOkHttpClient` and `Client` instances, and includes a `close()` method for proper resource management using `runBlocking`.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: Kotlin
CODE:
```
class MCPClient : AutoCloseable {
    private val anthropic = AnthropicOkHttpClient.fromEnv()
    private val mcp: Client = Client(clientInfo = Implementation(name = "mcp-client-cli", version = "1.0.0"))
    private lateinit var tools: List<ToolUnion>

    // methods will go here

    override fun close() {
        runBlocking {
            mcp.close()
            anthropic.close()
        }
    }

```

----------------------------------------

TITLE: Initialize .NET Host Builder and Configuration
DESCRIPTION: Sets up the foundational host builder for a .NET console application. It configures the application to load settings from environment variables and user secrets, which is crucial for securely managing API keys and other sensitive configurations.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: C#
CODE:
```
using Anthropic.SDK;
using Microsoft.Extensions.AI;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Hosting;
using ModelContextProtocol.Client;
using ModelContextProtocol.Protocol.Transport;

var builder = Host.CreateApplicationBuilder(args);

builder.Configuration
    .AddEnvironmentVariables()
    .AddUserSecrets<Program>();
```

----------------------------------------

TITLE: JSON Structure for Error Responses in MCP
DESCRIPTION: Example of a standard JSON-RPC error response structure used in Model Context Protocol for common failure cases, including an error code and a descriptive message.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client/sampling

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -1,
    "message": "User rejected sampling request"
  }
}
```

----------------------------------------

TITLE: Basic MCP Client Structure in Python
DESCRIPTION: This Python snippet establishes the foundational `MCPClient` class. It includes essential imports for asynchronous operations, type hinting, context management, MCP client components, Anthropic API interaction, and environment variable loading. The class initializes an Anthropic client and prepares for managing the client session lifecycle.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: Python
CODE:
```
import asyncio
from typing import Optional
from contextlib import AsyncExitStack

from mcp import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client

from anthropic import Anthropic
from dotenv import load_dotenv

load_dotenv()  # load environment variables from .env

class MCPClient:
    def __init__(self):
        # Initialize session and client objects
        self.session: Optional[ClientSession] = None
        self.exit_stack = AsyncExitStack()
        self.anthropic = Anthropic()
    # methods will go here
```

----------------------------------------

TITLE: Implement Custom Prompts in MCP Server (TypeScript)
DESCRIPTION: This TypeScript example demonstrates setting up an MCP server to handle custom prompts. It defines 'git-commit' and 'explain-code' prompts, implementing request handlers for listing available prompts and generating responses based on user arguments.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/prompts

LANGUAGE: TypeScript
CODE:
```
import { Server } from "@modelcontextprotocol/sdk/server";
import {
  ListPromptsRequestSchema,
  GetPromptRequestSchema
} from "@modelcontextprotocol/sdk/types";

const PROMPTS = {
  "git-commit": {
    name: "git-commit",
    description: "Generate a Git commit message",
    arguments: [
      {
        name: "changes",
        description: "Git diff or description of changes",
        required: true
      }
    ]
  },
  "explain-code": {
    name: "explain-code",
    description: "Explain how code works",
    arguments: [
      {
        name: "code",
        description: "Code to explain",
        required: true
      },
      {
        name: "language",
        description: "Programming language",
        required: false
      }
    ]
  }
};

const server = new Server({
  name: "example-prompts-server",
  version: "1.0.0"
}, {
  capabilities: {
    prompts: {}
  }
});

// List available prompts
server.setRequestHandler(ListPromptsRequestSchema, async () => {
  return {
    prompts: Object.values(PROMPTS)
  };
});

// Get specific prompt
server.setRequestHandler(GetPromptRequestSchema, async (request) => {
  const prompt = PROMPTS[request.params.name];
  if (!prompt) {
    throw new Error(`Prompt not found: ${request.params.name}`);
  }

  if (request.params.name === "git-commit") {
    return {
      messages: [
        {
          role: "user",
          content: {
            type: "text",
            text: `Generate a concise but descriptive commit message for these changes:\n\n${request.params.arguments?.changes}`
          }
        }
      ]
    };
  }

  if (request.params.name === "explain-code") {
    const language = request.params.arguments?.language || "Unknown";
    return {
      messages: [
        {
          role: "user",
          content: {
            type: "text",
            text: `Explain how this ${language} code works:\n\n${request.params.arguments?.code}`
          }
        }
      ]
    };
  }

  throw new Error("Prompt implementation not found");
});
```

----------------------------------------

TITLE: Process Queries and Handle Tool Calls
DESCRIPTION: This asynchronous function processes user queries, interacts with the Anthropic API to generate responses, and handles tool calls by executing them via the MCP client. It manages message history and integrates tool results into the conversation flow.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: TypeScript
CODE:
```
async processQuery(query: string) {
  const messages: MessageParam[] = [
    {
      role: "user",
      content: query,
    },
  ];

  const response = await this.anthropic.messages.create({
    model: "claude-3-5-sonnet-20241022",
    max_tokens: 1000,
    messages,
    tools: this.tools,
  });

  const finalText = [];

  for (const content of response.content) {
    if (content.type === "text") {
      finalText.push(content.text);
    } else if (content.type === "tool_use") {
      const toolName = content.name;
      const toolArgs = content.input as { [x: string]: unknown } | undefined;

      const result = await this.mcp.callTool({
        name: toolName,
        arguments: toolArgs,
      });
      finalText.push(
        `[Calling tool ${toolName} with args ${JSON.stringify(toolArgs)}]`
      );

      messages.push({
        role: "user",
        content: result.content as string,
      });

      const response = await this.anthropic.messages.create({
        model: "claude-3-5-sonnet-20241022",
        max_tokens: 1000,
        messages,
      });

      finalText.push(
        response.content[0].type === "text" ? response.content[0].text : ""
      );
    }
  }

  return finalText.join("\n");
}
```

----------------------------------------

TITLE: Configure MCP Client with LLM Sampling Support
DESCRIPTION: Demonstrates how to integrate LLM sampling into an MCP client by providing a samplingHandler function that interfaces with an LLM, enabling servers to request completions through the client.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-client

LANGUAGE: Java
CODE:
```
// Configure sampling handler
Function<CreateMessageRequest, CreateMessageResult> samplingHandler = request -> {
    // Sampling implementation that interfaces with LLM
    return new CreateMessageResult(response);
};

// Create client with sampling support
var client = McpClient.sync(transport)
    .capabilities(ClientCapabilities.builder()
        .sampling()
        .build())
    .sampling(samplingHandler)
    .build();
```

----------------------------------------

TITLE: APIDOC: Server and Client Implementation Guidelines
DESCRIPTION: Provides guidelines for both server and client implementations regarding suggestion sorting, fuzzy matching, rate limiting, input validation, debouncing, caching, and graceful handling of results.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/utilities/completion

LANGUAGE: APIDOC
CODE:
```
Implementation Considerations:
  Servers SHOULD:
    - Return suggestions sorted by relevance
    - Implement fuzzy matching where appropriate
    - Rate limit completion requests
    - Validate all inputs
  Clients SHOULD:
    - Debounce rapid completion requests
    - Cache completion results where appropriate
    - Handle missing or partial results gracefully
```

----------------------------------------

TITLE: Add Spring AI MCP WebFlux Starter Dependency
DESCRIPTION: This XML snippet shows the Maven dependency required to integrate the Spring AI MCP client with WebFlux-based applications. This starter provides a Server-Sent Events (SSE) transport implementation, recommended for production deployments.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: XML
CODE:
```
<dependency>
    <groupId>org.springframework.ai</groupId>
    <artifactId>spring-ai-mcp-client-webflux-spring-boot-starter</artifactId>
</dependency>
```

----------------------------------------

TITLE: Build and Run MCP Client
DESCRIPTION: Instructions for building the TypeScript project and running the compiled JavaScript client. It provides examples for connecting to both Python and Node.js MCP servers.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: Shell
CODE:
```
# Build TypeScript
npm run build

# Run the client
node build/index.js path/to/server.py # python server
node build/index.js path/to/build/index.js # node server
```

----------------------------------------

TITLE: Define a tool for project analysis
DESCRIPTION: This JSON schema defines a tool named 'analyze-project' with required arguments for 'timeframe' and 'fileUri'. This tool is intended for analyzing project logs and code by specifying the time period for logs and the URI of the code file to review.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/prompts

LANGUAGE: JSON
CODE:
```
{
  "name": "analyze-project",
  "description": "Analyze project logs and code",
  "arguments": [
    {
      "name": "timeframe",
      "description": "Time period to analyze logs",
      "required": true
    },
    {
      "name": "fileUri",
      "description": "URI of code file to review",
      "required": true
    }
  ]
}
```

----------------------------------------

TITLE: Output Schema Specification
DESCRIPTION: Details the requirements and benefits of providing an output schema for tools. Servers must conform to it, clients should validate against it. It enhances validation, type information, parsing guidance, and developer experience.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/tools

LANGUAGE: APIDOC
CODE:
```
Output Schema:
  Purpose: Defines the expected structure for structured tool results.
  Requirements:
    - Servers MUST provide structured results conforming to this schema.
    - Clients SHOULD validate structured results against this schema.
  Benefits:
    - Enables strict schema validation of responses.
    - Provides type information for better integration with programming languages.
    - Guides clients and LLMs to properly parse and utilize returned data.
    - Supports better documentation and developer experience.
```

----------------------------------------

TITLE: Model Context Protocol Resources API Specification
DESCRIPTION: Formal specification of the Model Context Protocol's API for managing resources, including server capabilities and messages for listing resources.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/resources

LANGUAGE: APIDOC
CODE:
```
Model Context Protocol Resources API:

Capabilities:
  resources: object
    description: Declares server support for resource management.
    properties:
      subscribe: boolean (optional)
        description: Whether the client can subscribe to be notified of changes to individual resources.
      listChanged: boolean (optional)
        description: Whether the server will emit notifications when the list of available resources changes.

Methods:
  resources/list:
    description: Request to discover available resources. Supports pagination.
    Request:
      jsonrpc: "2.0"
      id: number
      method: "resources/list"
      params: object
        properties:
          cursor: string (optional)
            description: An opaque value for pagination, indicating the starting point for the next page of results.
    Response:
      jsonrpc: "2.0"
      id: number
      result: object
        properties:
          resources: array of ResourceObject
            description: A list of available resources.
          nextCursor: string (optional)
            description: An opaque value for pagination, indicating the cursor for the next page of results.

ResourceObject:
  type: object
  properties:
    uri: string
      description: Unique identifier for the resource, typically a URI (RFC 3986).
    name: string
      description: A human-readable name for the resource.
    description: string (optional)
      description: A brief description of the resource's purpose or content.
    mimeType: string (optional)
      description: The MIME type of the resource's content.
```

----------------------------------------

TITLE: Model Context Protocol Request Message Structure
DESCRIPTION: Defines the structure for client-to-server or server-to-client requests within the Model Context Protocol, adhering to JSON-RPC 2.0. Requests must include a unique string or integer ID and a method name, with optional parameters. The ID must not be null and must not have been previously used in the session.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/basic/messages

LANGUAGE: APIDOC
CODE:
```
{
  jsonrpc: "2.0";
  id: string | number;
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

----------------------------------------

TITLE: MCP tools/list Response Protocol and Example
DESCRIPTION: Defines the structure for the 'tools/list' JSON-RPC response. It returns a list of tools, each with a name, description, and input schema, along with a 'nextCursor' for pagination. Includes a JSON example.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/tools

LANGUAGE: APIDOC
CODE:
```
Method: tools/list
Response Properties:
  tools: array of objects
    name: string - Unique identifier for the tool.
    description: string - A brief explanation of the tool's purpose.
    inputSchema: object - JSON Schema defining the tool's input parameters.
      type: string ("object")
      properties: object - Defines the tool's input fields.
        location: object
          type: string
          description: string ("City name or zip code")
      required: array of strings (e.g., ["location"])
  nextCursor: string (optional) - Cursor for the next page of results.
```

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "tools": [
      {
        "name": "get_weather",
        "description": "Get current weather information for a location",
        "inputSchema": {
          "type": "object",
          "properties": {
            "location": {
              "type": "string",
              "description": "City name or zip code"
            }
          },
          "required": ["location"]
        }
      }
    ],
    "nextCursor": "next-page-cursor"
  }
}
```

----------------------------------------

TITLE: Define Model Context Protocol Tool Structure
DESCRIPTION: This JSON schema defines the structure for a tool within the Model Context Protocol (MCP). It specifies required fields like 'name' and 'inputSchema', and optional annotations for behavior hints such as 'readOnlyHint' or 'destructiveHint'. This structure enables clients to discover and invoke server-exposed functionalities for LLMs.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/tools

LANGUAGE: JSON
CODE:
```
{
  name: string;          // Unique identifier for the tool
  description?: string;  // Human-readable description
  inputSchema: {         // JSON Schema for the tool's parameters
    type: "object",
    properties: { ... }  // Tool-specific parameters
  },
  annotations?: {        // Optional hints about tool behavior
    title?: string;      // Human-readable title for the tool
    readOnlyHint?: boolean;    // If true, the tool does not modify its environment
    destructiveHint?: boolean; // If true, the tool may perform destructive updates
    idempotentHint?: boolean;  // If true, repeated calls with same args have no additional effect
    openWorldHint?: boolean;   // If true, tool interacts with external entities
  }
}
```

----------------------------------------

TITLE: Model Context Protocol Response Message Structure
DESCRIPTION: Defines the structure for responses to requests within the Model Context Protocol. Responses must include the same ID as the corresponding request and must contain either a 'result' or an 'error' field, but not both. Error codes must be integers.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/basic/messages

LANGUAGE: APIDOC
CODE:
```
{
  jsonrpc: "2.0";
  id: string | number;
  result?: {
    [key: string]: unknown;
  }
  error?: {
    code: number;
    message: string;
    data?: unknown;
  }
}
```

----------------------------------------

TITLE: APIDOC: Tool Definition Structure
DESCRIPTION: Defines the structure of a tool, including its unique identifier, a human-readable description of its functionality, a JSON Schema for its expected input parameters, and optional annotations describing its behavior. Clients must treat annotations from untrusted servers as untrusted.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/tools

LANGUAGE: APIDOC
CODE:
```
Tool:
  name: string (Unique identifier for the tool)
  description: string (Human-readable description of functionality)
  inputSchema: JSON Schema (Defining expected parameters)
  annotations: object (Optional properties describing tool behavior)
```

----------------------------------------

TITLE: API: LLM Sampling Parameters
DESCRIPTION: Details the parameters available for fine-tuning LLM sampling behavior, including randomness (temperature), maximum tokens to generate, sequences that stop generation, and additional provider-specific metadata.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/sampling

LANGUAGE: APIDOC
CODE:
```
temperature: number (0.0 to 1.0)
  Controls randomness of LLM output.
maxTokens: number
  Maximum number of tokens to generate.
stopSequences: string[]
  Array of sequences that stop generation.
metadata: object
  Additional provider-specific parameters.
```

----------------------------------------

TITLE: Python Initialize and Run MCP Server
DESCRIPTION: This snippet demonstrates how to initialize and run the Model Context Protocol (MCP) server. When the script is executed as the main program, `mcp.run(transport='stdio')` starts the server, making the defined tools available for interaction.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: Python
CODE:
```
if __name__ == "__main__":
    # Initialize and run the server
    mcp.run(transport='stdio')
```

----------------------------------------

TITLE: Tool Execution Error Example
DESCRIPTION: Illustrates a tool execution error reported within the tool result, indicating issues like API failures or business logic errors.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/tools

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 4,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "Failed to fetch weather data: API rate limit exceeded"
      }
    ],
    "isError": true
  }
}
```

----------------------------------------

TITLE: Run MCP Client with Server Script Path
DESCRIPTION: Demonstrates how to execute the MCP client from the command line, specifying the path to the server script. Examples include both absolute Unix-like paths and Windows-style paths (forward and back slashes).
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: bash
CODE:
```
uv run client.py /Users/username/projects/mcp-server/weather.py
uv run client.py C:/projects/mcp-server/weather.py
uv run client.py C:\projects\mcp-server\weather.py
```

----------------------------------------

TITLE: Initialize FastMCP Server and Constants
DESCRIPTION: This Python code snippet imports necessary packages (`typing`, `httpx`, `FastMCP`), initializes a `FastMCP` server instance named 'weather', and defines constants for the NWS API base URL and a user agent. This forms the foundational setup for the MCP weather server.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: Python
CODE:
```
from typing import Any
import httpx
from mcp.server.fastmcp import FastMCP

# Initialize FastMCP server
mcp = FastMCP("weather")

# Constants
NWS_API_BASE = "https://api.weather.gov"
USER_AGENT = "weather-app/1.0"
```

----------------------------------------

TITLE: Configure MCP Servers for Claude
DESCRIPTION: Illustrates how to configure various Model Context Protocol (MCP) servers within a Claude application's `mcpServers` configuration block, specifying commands, arguments, and environment variables for each server.
SOURCE: https://modelcontextprotocol.io/introduction/examples

LANGUAGE: json
CODE:
```
{
  "mcpServers": {
    "memory": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-memory"]
    },
    "filesystem": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-filesystem",
        "/path/to/allowed/files"
      ]
    },
    "github": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-github"],
      "env": {
        "GITHUB_PERSONAL_ACCESS_TOKEN": "<YOUR_TOKEN>"
      }
    }
  }
}
```

----------------------------------------

TITLE: JSON-RPC 2.0 Response Message Format
DESCRIPTION: Defines the structure for a JSON-RPC 2.0 response message, including the protocol version, the request identifier, and either a result object on success or an error object on failure.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/transports

LANGUAGE: APIDOC
CODE:
```
{
  jsonrpc: "2.0",
  id: number | string,
  result?: object,
  error?: {
    code: number,
    message: string,
    data?: unknown
  }
}

```

----------------------------------------

TITLE: Follow MCP logs in real-time
DESCRIPTION: This command uses `tail` to display the last 20 lines of MCP logs from Claude Desktop in real-time, useful for monitoring server connection events, configuration issues, runtime errors, and message exchanges.
SOURCE: https://modelcontextprotocol.io/introduction/docs/tools/debugging

LANGUAGE: Shell
CODE:
```
tail -n 20 -F ~/Library/Logs/Claude/mcp*.log
```

----------------------------------------

TITLE: Implement Basic Tool in MCP Server
DESCRIPTION: This snippet demonstrates how to set up an MCP server, define a 'calculate_sum' tool with its input schema, and handle its execution for both listing and calling the tool. It provides examples in TypeScript and Python.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/tools

LANGUAGE: TypeScript
CODE:
```
const server = new Server({
  name: "example-server",
  version: "1.0.0"
}, {
  capabilities: {
    tools: {}
  }
});

// Define available tools
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [{
      name: "calculate_sum",
      description: "Add two numbers together",
      inputSchema: {
        type: "object",
        properties: {
          a: { type: "number" },
          b: { type: "number" }
        },
        required: ["a", "b"]
      }
    }]
  };
});

// Handle tool execution
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  if (request.params.name === "calculate_sum") {
    const { a, b } = request.params.arguments;
    return {
      content: [
        {
          type: "text",
          text: String(a + b)
        }
      ]
    };
  }
  throw new Error("Tool not found");
});
```

LANGUAGE: Python
CODE:
```
app = Server("example-server")

@app.list_tools()
async def list_tools() -> list[types.Tool]:
    return [
        types.Tool(
            name="calculate_sum",
            description="Add two numbers together",
            inputSchema={
                "type": "object",
                "properties": {
                    "a": {"type": "number"},
                    "b": {"type": "number"}
                },
                "required": ["a", "b"]
            }
        )
    ]

@app.call_tool()
async def call_tool(
    name: str,
    arguments: dict
) -> list[types.TextContent | types.ImageContent | types.EmbeddedResource]:
    if name == "calculate_sum":
        a = arguments["a"]
        b = arguments["b"]
        result = a + b
        return [types.TextContent(type="text", text=str(result))]
    raise ValueError(f"Tool not found: {name}")
```

----------------------------------------

TITLE: Configure and Manage Synchronous MCP Server in Java
DESCRIPTION: This Java code demonstrates how to initialize an `McpSyncServer` with custom capabilities, register various components like tools, resources, and prompts, and properly close the server. It showcases the synchronous API for server management within the Model Context Protocol.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-server

LANGUAGE: Java
CODE:
```
// Create a server with custom configuration
McpSyncServer syncServer = McpServer.sync(transportProvider)
    .serverInfo("my-server", "1.0.0")
    .capabilities(ServerCapabilities.builder()
        .resources(false, true)  // Enable resource support
        .tools(true)             // Enable tool support
        .prompts(true)           // Enable prompt support
        .logging()               // Enable logging support
        .completions()           // Enable completions support
        .build())
    .build();

// Register tools, resources, and prompts
syncServer.addTool(syncToolSpecification);
syncServer.addResource(syncResourceSpecification);
syncServer.addPrompt(syncPromptSpecification);

// Close the server when done
syncServer.close();
```

----------------------------------------

TITLE: Configure Filesystem MCP Server for Claude Desktop
DESCRIPTION: This JSON configuration tells Claude for Desktop which MCP servers to start up. It defines the 'filesystem' server, specifying the 'npx' command and arguments to run the '@modelcontextprotocol/server-filesystem'. Replace 'username' with your actual computer's username and ensure paths point to valid directories you want Claude to access.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/user

LANGUAGE: macOS/Linux
CODE:
```
{
  "mcpServers": {
    "filesystem": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-filesystem",
        "/Users/username/Desktop",
        "/Users/username/Downloads"
      ]
    }
  }
}
```

LANGUAGE: Windows
CODE:
```
{
  "mcpServers": {
    "filesystem": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-filesystem",
        "C:\\Users\\username\\Desktop",
        "C:\\Users\\username\\Downloads"
      ]
    }
  }
}
```

----------------------------------------

TITLE: Configure MCP Weather Server in Claude for Desktop
DESCRIPTION: This JSON configuration snippet is added to the `mcpServers` key in `claude_desktop_config.json` to register a 'weather' MCP server. It defines the command to launch the server using `uv`, specifying the directory and the main Python file. Paths are adjusted for different operating systems.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: JSON
CODE:
```
{
  "mcpServers": {
    "weather": {
      "command": "uv",
      "args": [
        "--directory",
        "/ABSOLUTE/PATH/TO/PARENT/FOLDER/weather",
        "run",
        "weather.py"
      ]
    }
  }
}
```

LANGUAGE: JSON
CODE:
```
{
  "mcpServers": {
    "weather": {
      "command": "uv",
      "args": [
        "--directory",
        "C:\\ABSOLUTE\\PATH\\TO\\PARENT\\FOLDER\\weather",
        "run",
        "weather.py"
      ]
    }
  }
}
```

----------------------------------------

TITLE: Model Context Protocol: Text Content Type Schema
DESCRIPTION: Defines the schema for text-based content within Model Context Protocol messages, specifying the content 'type' as 'text' and the actual 'text' string.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/client/sampling

LANGUAGE: APIDOC
CODE:
```
{
  "type": "text",
  "text": "The message content"
}
```

----------------------------------------

TITLE: Model Context Protocol JSON-RPC Request Message
DESCRIPTION: Defines the structure for request messages sent between Model Context Protocol clients and servers. Requests must include a non-null string or integer ID that has not been previously used within the same session. The `method` specifies the operation, and `params` is an optional object containing parameters.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/basic

LANGUAGE: APIDOC
CODE:
```
{
  jsonrpc: "2.0";
  id: string | number;
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

----------------------------------------

TITLE: APIDOC: Prompt Data Type Definition
DESCRIPTION: Defines the structure of a prompt, including its unique identifier, an optional human-readable description, and an optional list of arguments for customization.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/prompts

LANGUAGE: APIDOC
CODE:
```
Prompt:
  name: string - Unique identifier for the prompt
  description: string (optional) - Human-readable description
  arguments: array (optional) - List of arguments for customization
```

----------------------------------------

TITLE: MCP Prompt Structure Definition
DESCRIPTION: Defines the structure of a Model Context Protocol (MCP) prompt, including its unique identifier, optional human-readable description, and an optional list of arguments. Each argument specifies its name, an optional description, and whether it is required.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/prompts

LANGUAGE: APIDOC
CODE:
```
{
  name: string;              // Unique identifier for the prompt
  description?: string;      // Human-readable description
  arguments?: [              // Optional list of arguments
    {
      name: string;          // Argument identifier
      description?: string;  // Argument description
      required?: boolean;    // Whether argument is required
    }
  ]
}
```

----------------------------------------

TITLE: Requesting Completions: `completion/complete` JSON-RPC Request
DESCRIPTION: Clients send a `completion/complete` request to get autocompletion suggestions. The request specifies the reference type (e.g., `ref/prompt`) and the argument being completed, including its name and current value.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/utilities/completion

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "completion/complete",
  "params": {
    "ref": {
      "type": "ref/prompt",
      "name": "code_review"
    },
    "argument": {
      "name": "language",
      "value": "py"
    }
  }
}
```

----------------------------------------

TITLE: Define Model Context Protocol Prompts in Python
DESCRIPTION: This Python code defines two prompt types, 'git-commit' and 'explain-code', using the `types.Prompt` and `types.PromptArgument` classes. Each prompt specifies its name, description, and required/optional arguments, which are then stored in a `PROMPTS` dictionary for server use.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/prompts

LANGUAGE: Python
CODE:
```
PROMPTS = {
    "git-commit": types.Prompt(
        name="git-commit",
        description="Generate a Git commit message",
        arguments=[
            types.PromptArgument(
                name="changes",
                description="Git diff or description of changes",
                required=True
            )
        ],
    ),
    "explain-code": types.Prompt(
        name="explain-code",
        description="Explain how code works",
        arguments=[
            types.PromptArgument(
                name="code",
                description="Code to explain",
                required=True
            ),
            types.PromptArgument(
                name="language",
                description="Programming language",
                required=False
            )
        ],
    )
}
```

----------------------------------------

TITLE: APIDOC: Model Context Protocol Request Timeouts
DESCRIPTION: Outlines guidelines for implementing timeouts on all sent requests to prevent hung connections and resource exhaustion. Discusses cancellation notifications, configurable timeouts, and resetting the timeout clock on progress notifications while enforcing a maximum timeout.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/basic/lifecycle

LANGUAGE: APIDOC
CODE:
```
Timeouts:
  Implementations SHOULD establish timeouts for all sent requests.
  Sender SHOULD issue cancellation notification and stop waiting if no response within timeout.
  SDKs/middleware SHOULD allow per-request timeout configuration.
  Implementations MAY reset timeout clock on progress notification, but SHOULD always enforce a maximum timeout.
```

----------------------------------------

TITLE: MCP Pagination Request Format
DESCRIPTION: This JSON snippet demonstrates how a client continues pagination by including the `cursor` received from a previous response in its subsequent request. The `cursor` acts as an opaque token to specify the desired position in the result set for the next page.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/utilities/pagination

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "method": "resources/list",
  "params": {
    "cursor": "eyJwYWdlIjogMn0="
  }
}
```

----------------------------------------

TITLE: Define JSON-RPC 2.0 Response Structure for MCP
DESCRIPTION: Outlines the JSON-RPC 2.0 response format for the Model Context Protocol, sent in reply to requests. Responses must carry the original request's ID and contain either a 'result' for success or an 'error' object, but never both. Error objects require a numeric code and a message.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/basic

LANGUAGE: APIDOC
CODE:
```
{
  jsonrpc: "2.0";
  id: string | number;
  result?: {
    [key: string]: unknown;
  }
  error?: {
    code: number;
    message: string;
    data?: unknown;
  }
}
```

----------------------------------------

TITLE: Configure Weather MCP Server in Claude Desktop
DESCRIPTION: This JSON snippet demonstrates how to add a 'weather' MCP server configuration to the `mcpServers` key in `claude_desktop_config.json`. It specifies the command to run the server (`uv`) and its arguments, including the absolute path to the server directory. This configuration enables Claude for Desktop to recognize and launch the server.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: json
CODE:
```
{
  "mcpServers": {
    "weather": {
      "command": "uv",
      "args": [
        "--directory",
        "/ABSOLUTE/PATH/TO/PARENT/FOLDER/weather",
        "run",
        "weather.py"
      ]
    }
  }
}
```

LANGUAGE: json
CODE:
```
{
  "mcpServers": {
    "weather": {
      "command": "uv",
      "args": [
        "--directory",
        "C:\\ABSOLUTE\\PATH\\TO\\PARENT\\FOLDER\\weather",
        "run",
        "weather.py"
      ]
    }
  }
}
```

----------------------------------------

TITLE: MCP Model Preference Configuration Example
DESCRIPTION: This JSON snippet illustrates how a server can define its model preferences within the Model Context Protocol. It combines specific model hints, such as preferring 'claude-3-sonnet', with numerical priorities for cost, speed, and intelligence, guiding the client's model selection process.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/client/sampling

LANGUAGE: JSON
CODE:
```
{
  "hints": [
    { "name": "claude-3-sonnet" },
    { "name": "claude" }
  ],
  "costPriority": 0.3,
  "speedPriority": 0.8,
  "intelligencePriority": 0.5
}
```

----------------------------------------

TITLE: Define Main Execution Logic for MCP Client
DESCRIPTION: This section provides the main asynchronous function to initialize and run the MCP client. It handles command-line arguments for server connection, establishes a connection, starts the chat loop, and ensures proper cleanup upon exit.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: TypeScript
CODE:
```
async function main() {
  if (process.argv.length < 3) {
    console.log("Usage: node index.ts <path_to_server_script>");
    return;
  }
  const mcpClient = new MCPClient();
  try {
    await mcpClient.connectToServer(process.argv[2]);
    await mcpClient.chatLoop();
  } finally {
    await mcpClient.cleanup();
    process.exit(0);
  }
}

main();
```

----------------------------------------

TITLE: Send sampling/createMessage Request for LLM Generation
DESCRIPTION: Servers initiate a language model generation by sending a `sampling/createMessage` JSON-RPC request. This example demonstrates a request with a user message, model preferences (hints, intelligence and speed priority), a system prompt, and a maximum token limit.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/client/sampling

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "sampling/createMessage",
  "params": {
    "messages": [
      {
        "role": "user",
        "content": {
          "type": "text",
          "text": "What is the capital of France?"
        }
      }
    ],
    "modelPreferences": {
      "hints": [
        {
          "name": "claude-3-sonnet"
        }
      ],
      "intelligencePriority": 0.8,
      "speedPriority": 0.5
    },
    "systemPrompt": "You are a helpful assistant.",
    "maxTokens": 100
  }
}
```

----------------------------------------

TITLE: MCP Client Reactive Operations Chain
DESCRIPTION: Demonstrates a sequence of reactive operations using an MCP client, including listing prompts, getting a specific prompt, adding and removing a root, and gracefully closing the client upon completion or error.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-client

LANGUAGE: Java
CODE:
```
        return client.listPrompts()
            .flatMap(prompts ->
                client.getPrompt(new GetPromptRequest(
                    "greeting",
                    Map.of("name", "Spring")
                ))
            );
    })
    .flatMap(prompt -> {
        return client.addRoot(new Root("file:///path", "description"))
            .then(client.removeRoot("file:///path"));
    })
    .doFinally(signalType -> {
        client.closeGracefully().subscribe();
    })
    .subscribe();
```

----------------------------------------

TITLE: Add Model Context Protocol and Hosting NuGet Packages
DESCRIPTION: These commands add the necessary NuGet packages to the C# project: the Model Context Protocol SDK for server functionality and Microsoft.Extensions.Hosting for application hosting and dependency injection, enabling the server to run.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: Shell
CODE:
```
# Add the Model Context Protocol SDK NuGet package
dotnet add package ModelContextProtocol --prerelease
# Add the .NET Hosting NuGet package
dotnet add package Microsoft.Extensions.Hosting
```

----------------------------------------

TITLE: MCP tools/list Request Protocol and Example
DESCRIPTION: Defines the structure for the 'tools/list' JSON-RPC request. Clients use this to discover available tools, optionally providing a cursor for pagination. Includes a JSON example.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/tools

LANGUAGE: APIDOC
CODE:
```
Method: tools/list
Description: To discover available tools. Supports pagination.
Request Parameters:
  cursor: string (optional) - An optional cursor value for pagination.
```

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/list",
  "params": {
    "cursor": "optional-cursor-value"
  }
}
```

----------------------------------------

TITLE: APIDOC: Standard JSON-RPC Error Codes
DESCRIPTION: Servers should return standard JSON-RPC errors for common failure cases, providing specific error codes for invalid parameters or internal issues.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/prompts

LANGUAGE: APIDOC
CODE:
```
Error Codes:
  -32602 (Invalid params): Invalid prompt name, Missing required arguments
  -32603 (Internal error): Internal errors
```

----------------------------------------

TITLE: Streamable HTTP Server Implementation (Python)
DESCRIPTION: Shows a Python server implementation using Starlette to handle MCP requests. It supports HTTP POST for JSON-RPC requests, returning either JSON or SSE streams, and HTTP GET for server-initiated SSE streams.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/transports

LANGUAGE: Python
CODE:
```
from mcp.server.http import HttpServerTransport
from starlette.applications import Starlette
from starlette.routing import Route

app = Server("example-server")

async def handle_mcp(scope, receive, send):
    if scope["method"] == "POST":
        # Handle JSON-RPC request
        response = await app.handle_request(request_body)

        if needs_streaming:
            # Return SSE stream
            await send_sse_response(send, response)
        else:
            # Return JSON response
            await send_json_response(send, response)

    elif scope["method"] == "GET":
        # Optional: Support server-initiated SSE streams
        await send_sse_stream(send)

starlette_app = Starlette(
    routes=[
        Route("/mcp", endpoint=handle_mcp, methods=["POST", "GET"]),
    ]
)
```

----------------------------------------

TITLE: Declare MCP Resources Capability with Full Support
DESCRIPTION: Example JSON demonstrating a server's declaration of the 'resources' capability, enabling both 'subscribe' for individual resource change notifications and 'listChanged' for notifications when the overall list of resources changes.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/resources

LANGUAGE: JSON
CODE:
```
{
  "capabilities": {
    "resources": {
      "subscribe": true,
      "listChanged": true
    }
  }
}
```

----------------------------------------

TITLE: API Definition: PromptMessage Data Type
DESCRIPTION: Defines the structure of messages within a prompt. Each message specifies the speaker's `role` (either 'user' or 'assistant') and its `content`, which can be one of several types like text, image, audio, or embedded resources.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/prompts

LANGUAGE: APIDOC
CODE:
```
PromptMessage:
  role: Either "user" or "assistant" to indicate the speaker
  content: One of the following content types
```

----------------------------------------

TITLE: Example prompts/get request with embedded resources
DESCRIPTION: This JSON demonstrates a 'prompts/get' request where user messages include both text and embedded resources. It shows how to include log data (text/plain) and a Python code file (text/x-python) directly within the prompt for analysis, using URIs to specify the resource type and location.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/prompts

LANGUAGE: JSON
CODE:
```
{
  "messages": [
    {
      "role": "user",
      "content": {
        "type": "text",
        "text": "Analyze these system logs and the code file for any issues:"
      }
    },
    {
      "role": "user",
      "content": {
        "type": "resource",
        "resource": {
          "uri": "logs://recent?timeframe=1h",
          "text": "[2024-03-14 15:32:11] ERROR: Connection timeout in network.py:127\n[2024-03-14 15:32:15] WARN: Retrying connection (attempt 2/3)\n[2024-03-14 15:32:20] ERROR: Max retries exceeded",
          "mimeType": "text/plain"
        }
      }
    },
    {
      "role": "user",
      "content": {
        "type": "resource",
        "resource": {
          "uri": "file:///path/to/code.py",
          "text": "def connect_to_service(timeout=30):\n    retries = 3\n    for attempt in range(retries):\n        try:\n            return establish_connection(timeout)\n        except TimeoutError:\n            if attempt == retries - 1:\n                raise\n            time.sleep(5)\n\ndef establish_connection(timeout):\n    # Connection implementation\n    pass",
          "mimeType": "text/x-python"
        }
      }
    }
  ]
}
```

----------------------------------------

TITLE: Request to List Available Tools in MCP
DESCRIPTION: Clients can discover available tools by sending a 'tools/list' request to the server. This JSON-RPC request includes an optional 'cursor' parameter to support pagination, allowing clients to retrieve tools in batches.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/tools

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/list",
  "params": {
    "cursor": "optional-cursor-value"
  }
}
```

----------------------------------------

TITLE: Implement Error Handling in TypeScript Custom Transport
DESCRIPTION: This TypeScript snippet illustrates how to incorporate robust error handling within a custom `Transport` implementation. It wraps connection and message sending logic in try-catch blocks, invoking the `onerror` callback to report failures and re-throwing errors for upstream handling.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/transports

LANGUAGE: TypeScript
CODE:
```
class ExampleTransport implements Transport {
  async start() {
    try {
      // Connection logic
    } catch (error) {
      this.onerror?.(new Error(`Failed to connect: ${error}`));
      throw error;
    }
  }

  async send(message: JSONRPCMessage) {
    try {
      // Sending logic
    } catch (error) {
      this.onerror?.(new Error(`Failed to send message: ${error}`));
      throw error;
    }
  }
}
```

----------------------------------------

TITLE: Discovering Available Prompts via prompts/list
DESCRIPTION: Illustrates how clients can discover available prompts by making a 'prompts/list' request. The example shows both the simple request payload and the expected response, which contains an array of prompt objects, each detailing its name, description, and any required arguments.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/prompts

LANGUAGE: JSON
CODE:
```
// Request
{
  "method": "prompts/list"
}

// Response
{
  "prompts": [
    {
      "name": "analyze-code",
      "description": "Analyze code for potential improvements",
      "arguments": [
        {
          "name": "language",
          "description": "Programming language",
          "required": true
        }
      ]
    }
  ]
}
```

----------------------------------------

TITLE: Run Model Context Protocol Server via Stdio
DESCRIPTION: This snippet defines the `main` function responsible for initializing and running the Model Context Protocol (MCP) server. It uses `StdioServerTransport` to establish a connection and logs server status to `console.error`. The function also includes robust error handling to catch and report fatal errors during server startup, ensuring the process exits gracefully.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: TypeScript
CODE:
```
async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error("Weather MCP Server running on stdio");
}

main().catch((error) => {
  console.error("Fatal error in main():", error);
  process.exit(1);
});
```

----------------------------------------

TITLE: Run Interactive Chat Loop in Python
DESCRIPTION: This asynchronous method provides an interactive command-line chat interface for the MCP client. It continuously prompts the user for queries, processes them using the 'process_query' method, and prints the responses. The loop can be exited by typing 'quit'.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: python
CODE:
```
async def chat_loop(self):
    """Run an interactive chat loop"""
    print("\nMCP Client Started!")
    print("Type your queries or 'quit' to exit.")

    while True:
        try:
            query = input("\nQuery: ").strip()

            if query.lower() == 'quit':
                break

            response = await self.process_query(query)
            print("\n" + response)

        except Exception as e:
            print(f"\nError: {str(e)}")
```

----------------------------------------

TITLE: Manually Run Filesystem MCP Server
DESCRIPTION: Commands to manually run the Model Context Protocol (MCP) filesystem server to diagnose connection issues, replacing 'username' with the actual user directory. Includes versions for both macOS/Linux and Windows.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/user

LANGUAGE: Shell
CODE:
```
npx -y @modelcontextprotocol/server-filesystem /Users/username/Desktop /Users/username/Downloads
```

LANGUAGE: Windows Command Prompt
CODE:
```
npx -y @modelcontextprotocol/server-filesystem C:\Users\username\Desktop C:\Users\username\Downloads
```

----------------------------------------

TITLE: Model Context Protocol: sampling/createMessage Request
DESCRIPTION: Defines the structure for a server's request to a client for language model generation. It includes an array of messages, model preferences (hints, intelligence, speed priority), an optional system prompt, and a maximum token limit.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/client/sampling

LANGUAGE: APIDOC
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "sampling/createMessage",
  "params": {
    "messages": [
      {
        "role": "user",
        "content": {
          "type": "text",
          "text": "What is the capital of France?"
        }
      }
    ],
    "modelPreferences": {
      "hints": [
        {
          "name": "claude-3-sonnet"
        }
      ],
      "intelligencePriority": 0.8,
      "speedPriority": 0.5
    },
    "systemPrompt": "You are a helpful assistant.",
    "maxTokens": 100
  }
}
```

----------------------------------------

TITLE: Configure MCP server with absolute path in claude_desktop_config.json
DESCRIPTION: This JSON configuration snippet demonstrates how to specify an absolute path for the server's working directory within `claude_desktop_config.json`. This ensures reliable operation when the server is launched via Claude Desktop, as its working directory may otherwise be undefined.
SOURCE: https://modelcontextprotocol.io/introduction/docs/tools/debugging

LANGUAGE: JSON
CODE:
```
{
  "command": "npx",
  "args": [
    "-y",
    "@modelcontextprotocol/server-filesystem",
    "/Users/username/data"
  ]
}
```

----------------------------------------

TITLE: MCP stdio Transport Specification
DESCRIPTION: Details the Model Context Protocol's standard input/output transport mechanism. The client launches the server as a subprocess, communicating via JSON-RPC messages delimited by newlines over stdin/stdout. Specifies rules for logging via stderr and restrictions on stdout/stdin content.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/basic/transports

LANGUAGE: APIDOC
CODE:
```
stdio Transport:
  Mechanism: Client launches server as subprocess.
  Communication:
    - Server reads JSON-RPC messages from its standard input (stdin).
    - Server sends JSON-RPC messages to its standard output (stdout).
    - Messages are individual JSON-RPC requests, notifications, or responses.
    - Messages MUST be UTF-8 encoded.
    - Messages are delimited by newlines.
    - Messages MUST NOT contain embedded newlines.
  Logging:
    - Server MAY write UTF-8 strings to its standard error (stderr) for logging purposes.
    - Clients MAY capture, forward, or ignore this logging.
  Constraints:
    - Server MUST NOT write anything to its stdout that is not a valid MCP message.
    - Client MUST NOT write anything to the server’s stdin that is not a valid MCP message.
```

----------------------------------------

TITLE: Run Spring AI Brave Chatbot Application
DESCRIPTION: Command to run the Spring Boot application using the Maven Wrapper, starting the chatbot server.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: Bash
CODE:
```
./mvnw spring-boot:run
```

----------------------------------------

TITLE: Implement Sync Server with AI Sampling Tool in Java
DESCRIPTION: This Java code demonstrates how to set up a synchronous MCP server and define a tool that leverages client-side AI sampling capabilities. The tool checks for client sampling support, constructs a CreateMessageRequest with model preferences (hints, intelligence/speed priority), sends it to the client for generation, and processes the text result. It's designed for immediate, blocking responses.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-server

LANGUAGE: Java
CODE:
```
// Create a server
McpSyncServer server = McpServer.sync(transportProvider)
    .serverInfo("my-server", "1.0.0")
    .build();

// Define a tool that uses sampling
var calculatorTool = new McpServerFeatures.SyncToolSpecification(
    new Tool("ai-calculator", "Performs calculations using AI", schema),
    (exchange, arguments) -> {
        // Check if client supports sampling
        if (exchange.getClientCapabilities().sampling() == null) {
            return new CallToolResult("Client does not support AI capabilities", false);
        }

        // Create a sampling request
        McpSchema.CreateMessageRequest request = McpSchema.CreateMessageRequest.builder()
            .messages(List.of(new McpSchema.SamplingMessage(McpSchema.Role.USER,
                new McpSchema.TextContent("Calculate: " + arguments.get("expression"))))
            .modelPreferences(McpSchema.ModelPreferences.builder()
                .hints(List.of(
                    McpSchema.ModelHint.of("claude-3-sonnet"),
                    McpSchema.ModelHint.of("claude")
                ))
                .intelligencePriority(0.8)  // Prioritize intelligence
                .speedPriority(0.5)         // Moderate speed importance
                .build())
            .systemPrompt("You are a helpful calculator assistant. Provide only the numerical answer.")
            .maxTokens(100)
            .build();

        // Request sampling from the client
        McpSchema.CreateMessageResult result = exchange.createMessage(request);

        // Process the result
        String answer = result.content().text();
        return new CallToolResult(answer, false);
    }
);

// Add the tool to the server
server.addTool(calculatorTool);
```

----------------------------------------

TITLE: MCP Server Authorization Error Responses
DESCRIPTION: MCP servers must return specific HTTP status codes for various authorization errors. This table outlines the required status codes, their descriptions, and their appropriate usage, ensuring consistent error reporting for clients.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/basic/authorization

LANGUAGE: APIDOC
CODE:
```
Error Responses:
  401 Unauthorized:
    Description: Authorization required or token invalid
  403 Forbidden:
    Description: Invalid scopes or insufficient permissions
  400 Bad Request:
    Description: Malformed authorization request
```

----------------------------------------

TITLE: API Definition: Embedded Resources Content Type for Messages
DESCRIPTION: Allows referencing server-side resources directly in messages. Resources can contain either text or binary (blob) data and must include a valid resource URI, the appropriate MIME type, and either text content or base64-encoded blob data.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/prompts

LANGUAGE: APIDOC
CODE:
```
Embedded Resources:
  type: "resource"
  resource:
    uri: "resource://example"
    mimeType: "text/plain"
    text: "Resource content"
```

LANGUAGE: JSON
CODE:
```
{
  "type": "resource",
  "resource": {
    "uri": "resource://example",
    "mimeType": "text/plain",
    "text": "Resource content"
  }
}
```

----------------------------------------

TITLE: Error Handling Mechanisms
DESCRIPTION: Describes the two primary mechanisms for error reporting: Protocol Errors (standard JSON-RPC) and Tool Execution Errors (reported within tool results with 'isError: true').
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/tools

LANGUAGE: APIDOC
CODE:
```
Error Handling:
  1. Protocol Errors:
    - Mechanism: Standard JSON-RPC errors.
    - Examples: Unknown tools, invalid arguments, server errors.
  2. Tool Execution Errors:
    - Mechanism: Reported in tool results with `isError: true`.
    - Examples: API failures, invalid input data, business logic errors.
```

----------------------------------------

TITLE: Model Context Protocol JSON-RPC 2.0 Message Types
DESCRIPTION: Defines the three fundamental message types used in the Model Context Protocol, adhering to the JSON-RPC 2.0 specification: Requests, Responses, and Notifications. Responses are further categorized into successful results or errors.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/basic

LANGUAGE: APIDOC
CODE:
```
Type: Requests
  Description: Messages sent to initiate an operation
  Requirements: Must include unique ID and method name

Type: Responses
  Description: Messages sent in reply to requests
  Requirements: Must include same ID as request
  Sub-categories:
    - Successful results (any JSON object structure)
    - Errors (must include error code and message at minimum)

Type: Notifications
  Description: One-way messages with no reply
  Requirements: Must not include an ID
```

----------------------------------------

TITLE: Run MCP Client with Python or Node.js Server
DESCRIPTION: Commands to execute the MCP client using `uv run`, demonstrating how to connect to both Python and Node.js based MCP servers by specifying the server script path.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: Shell
CODE:
```
uv run client.py path/to/server.py # python server
uv run client.py path/to/build/index.js # node server
```

----------------------------------------

TITLE: Define Model Preference JSON Structure
DESCRIPTION: Illustrates the JSON structure for specifying model preferences in MCP, combining model hints (preferred models/families) with capability priorities (cost, speed, intelligence) to guide model selection by the client.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/client/sampling

LANGUAGE: JSON
CODE:
```
{
  "hints": [
    { "name": "claude-3-sonnet" },
    { "name": "claude" }
  ],
  "costPriority": 0.3,
  "speedPriority": 0.8,
  "intelligencePriority": 0.5
}
```

----------------------------------------

TITLE: Response for Listing Filesystem Roots
DESCRIPTION: Clients respond to a 'roots/list' request with a JSON RPC response. The 'result' object contains an array of 'roots', where each root specifies a 'uri' and an optional 'name'.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/client/roots

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "roots": [
      {
        "uri": "file:///home/user/projects/myproject",
        "name": "My Project"
      }
    ]
  }
}
```

----------------------------------------

TITLE: Server `initialize` Response
DESCRIPTION: The server responds to the `initialize` request with its own capabilities, server information, and optional instructions. This response confirms protocol version compatibility and completes the capability negotiation, allowing the client to understand the server's supported features.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/basic/lifecycle

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "protocolVersion": "2025-03-26",
    "capabilities": {
      "logging": {},
      "prompts": {
        "listChanged": true
      },
      "resources": {
        "subscribe": true,
        "listChanged": true
      },
      "tools": {
        "listChanged": true
      }
    },
    "serverInfo": {
      "name": "ExampleServer",
      "version": "1.0.0"
    },
    "instructions": "Optional instructions for the client"
  }
}
```

----------------------------------------

TITLE: Declare Model Context Protocol Roots Capability
DESCRIPTION: Clients supporting the 'roots' feature in Model Context Protocol must declare this capability during initialization. The 'listChanged' flag indicates whether the client will send notifications when the list of roots changes.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/client

LANGUAGE: JSON
CODE:
```
{
  "capabilities": {
    "roots": {
      "listChanged": true
    }
  }
}
```

----------------------------------------

TITLE: Main Execution Logic for MCP Client in Python
DESCRIPTION: This asynchronous function serves as the main entry point for the MCP client application. It parses command-line arguments to get the server script path, initializes the MCPClient, connects to the server, runs the interactive chat loop, and ensures resources are cleaned up in a finally block.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: python
CODE:
```
async def main():
    if len(sys.argv) < 2:
        print("Usage: python client.py <path_to_server_script>")
        sys.exit(1)

    client = MCPClient()
    try:
        await client.connect_to_server(sys.argv[1])
        await client.chat_loop()
    finally:
        await client.cleanup()

if __name__ == "__main__":
    import sys
    import asyncio
    asyncio.run(main())
```

----------------------------------------

TITLE: Define Prompt Specification (Sync and Async) in Java
DESCRIPTION: This snippet illustrates how to define synchronous and asynchronous prompt specifications using `McpServerFeatures.SyncPromptSpecification` and `McpServerFeatures.AsyncPromptSpecification` in Java. Prompt specifications provide a standardized way for servers to expose prompt templates to clients, enabling consistent message formatting, parameter substitution, and context injection. Each specification includes a `Prompt` definition (with name, description, and a list of arguments) and a handler function to process requests and return formatted templates via `GetPromptResult`. The handler function receives an `McpAsyncServerExchange` for client interaction and a `GetPromptRequest` instance.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-server

LANGUAGE: Java
CODE:
```
var syncPromptSpecification = new McpServerFeatures.SyncPromptSpecification(
    new Prompt("greeting", "description", List.of(
        new PromptArgument("name", "description", true)
    )),
    (exchange, request) -> {
        // Prompt implementation
        return new GetPromptResult(description, messages);
    }
);
```

LANGUAGE: Java
CODE:
```
var asyncPromptSpecification = new McpServerFeatures.AsyncPromptSpecification(
    new Prompt("greeting", "description", List.of(
        new PromptArgument("name", "description", true)
    )),
    (exchange, request) -> {
        // Prompt implementation
        return Mono.just(new GetPromptResult(description, messages));
    }
);
```

----------------------------------------

TITLE: Declare Model Context Protocol Completion Capability
DESCRIPTION: Servers that support autocompletion in the Model Context Protocol must declare the 'completions' capability within their capabilities object to signal their support for this feature.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/utilities/completion

LANGUAGE: JSON
CODE:
```
{
  "capabilities": {
    "completions": {}
  }
}
```

----------------------------------------

TITLE: Connect to MCP Server Method
DESCRIPTION: Implements the 'connect_to_server' method within the 'MCPClient' class. This method handles establishing a connection to an MCP server, supporting both Python and JavaScript server scripts, and initializes the client session.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: python
CODE:
```
async def connect_to_server(self, server_script_path: str):
    """Connect to an MCP server

    Args:
        server_script_path: Path to the server script (.py or .js)
    """
    is_python = server_script_path.endswith('.py')
    is_js = server_script_path.endswith('.js')
    if not (is_python or is_js):
        raise ValueError("Server script must be a .py or .js file")

    command = "python" if is_python else "node"
    server_params = StdioServerParameters(
        command=command,
        args=[server_script_path],
        env=None
    )

    stdio_transport = await self.exit_stack.enter_async_context(stdio_client(server_params))
    self.stdio, self.write = stdio_transport
    self.session = await self.exit_stack.enter_async_context(ClientSession(self.stdio, self.write))

    await self.session.initialize()

    # List available tools
    response = await self.session.list_tools()
    tools = response.tools
    print("\nConnected to server with tools:", [tool.name for tool in tools])
```

----------------------------------------

TITLE: Model Context Protocol Error Handling
DESCRIPTION: Specifies standard JSON-RPC error codes and their corresponding failure cases for the protocol.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/utilities/completion

LANGUAGE: APIDOC
CODE:
```
Error Handling:
  Method not found: -32601 (Capability not supported)
  Invalid prompt name: -32602 (Invalid params)
  Missing required arguments: -32602 (Invalid params)
  Internal errors: -32603 (Internal error)
```

----------------------------------------

TITLE: Run FastMCP Server in Python
DESCRIPTION: This final snippet demonstrates how to initialize and run the FastMCP server. It uses a standard `if __name__ == "__main__":` block to ensure the server starts only when the script is executed directly. The `mcp.run(transport='stdio')` command launches the server, making it ready to receive requests via standard input/output.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: python
CODE:
```
if __name__ == "__main__":
    # Initialize and run the server
    mcp.run(transport='stdio')
```

----------------------------------------

TITLE: MCP Client Authorization Header Format
DESCRIPTION: MCP clients must include the Authorization request header field in every HTTP request to the server. This header carries the Bearer token, which is the access token obtained during the OAuth flow, ensuring secure communication.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/basic/authorization

LANGUAGE: HTTP
CODE:
```
Authorization: Bearer <access-token>
```

----------------------------------------

TITLE: Respond with Model Context Protocol Roots List
DESCRIPTION: A successful response to a 'roots/list' request, containing an array of root definitions. Each root includes a 'uri' (a 'file://' URI) and an optional 'name' for display.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/client

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "roots": [
      {
        "uri": "file:///home/user/projects/myproject",
        "name": "My Project"
      }
    ]
  }
}
```

----------------------------------------

TITLE: Model Context Protocol Client Notification for Root List Changes
DESCRIPTION: Clients that support the 'listChanged' capability must send a 'notifications/roots/list_changed' notification to the server whenever the list of exposed roots changes. This informs the server to re-query the roots.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/client

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "method": "notifications/roots/list_changed"
}
```

----------------------------------------

TITLE: Define Resource Specification (Sync and Async) in Java
DESCRIPTION: This snippet demonstrates how to define synchronous and asynchronous resource specifications using `McpServerFeatures.SyncResourceSpecification` and `McpServerFeatures.AsyncResourceSpecification` in Java. Resources provide context to AI models by exposing data like file contents or database records. Each specification includes a `Resource` definition (with URI, name, description, MIME type) and a handler function to implement resource reading, returning a `ReadResourceResult`. The handler function receives an `McpAsyncServerExchange` for client interaction and a `McpSchema.ReadResourceRequest`.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-server

LANGUAGE: Java
CODE:
```
var syncResourceSpecification = new McpServerFeatures.SyncResourceSpecification(
    new Resource("custom://resource", "name", "description", "mime-type", null),
    (exchange, request) -> {
        // Resource read implementation
        return new ReadResourceResult(contents);
    }
);
```

LANGUAGE: Java
CODE:
```
var asyncResourceSpecification = new McpServerFeatures.AsyncResourceSpecification(
    new Resource("custom://resource", "name", "description", "mime-type", null),
    (exchange, request) -> {
        // Resource read implementation
        return Mono.just(new ReadResourceResult(contents));
    }
);
```

----------------------------------------

TITLE: Response to LLM Generation Request
DESCRIPTION: The response to a 'sampling/createMessage' request contains the generated content from the language model. It includes the role of the generator (e.g., 'assistant'), the content itself (type and text), the specific model that generated the response, and the reason for stopping the generation.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client/sampling

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "role": "assistant",
    "content": {
      "type": "text",
      "text": "The capital of France is Paris."
    },
    "model": "claude-3-sonnet-20240307",
    "stopReason": "endTurn"
  }
}
```

----------------------------------------

TITLE: Example JSON-RPC Error Response
DESCRIPTION: Illustrates a standard JSON-RPC error structure for common failure cases, such as unsupported methods, including specific error codes, messages, and optional data for detailed reasons.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/client/roots

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -32601,
    "message": "Roots not supported",
    "data": {
      "reason": "Client does not have roots capability"
    }
  }
}
```

----------------------------------------

TITLE: JSON: Example LLM Client Sampling Request
DESCRIPTION: Illustrates a sample JSON request to the LLM client's `sampling/createMessage` method, demonstrating message structure, system prompt, context inclusion, and token limits for generating a response.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/sampling

LANGUAGE: JSON
CODE:
```
{
  "method": "sampling/createMessage",
  "params": {
    "messages": [
      {
        "role": "user",
        "content": {
          "type": "text",
          "text": "What files are in the current directory?"
        }
      }
    ],
    "systemPrompt": "You are a helpful file system assistant.",
    "includeContext": "thisServer",
    "maxTokens": 100
  }
}
```

----------------------------------------

TITLE: Perform MCP Client Roots Operations
DESCRIPTION: Shows how to dynamically add and remove filesystem roots, and notify the server about changes to the roots list using the MCP client's roots capability.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-client

LANGUAGE: Java
CODE:
```
// Add a root dynamically
client.addRoot(new Root("file:///path", "description"));

// Remove a root
client.removeRoot("file:///path");

// Notify server of roots changes
client.rootsListChangedNotification();
```

----------------------------------------

TITLE: MCP _meta Property/Parameter Specification
DESCRIPTION: Details the `_meta` property reserved by MCP for attaching additional metadata to interactions. It specifies reserved key names for protocol-level metadata and defines the valid key name format, including prefix and name segments.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/basic

LANGUAGE: APIDOC
CODE:
```
_meta:
  Purpose: Reserved by MCP to allow clients and servers to attach additional metadata to their interactions.
  Reserved Keys:
    - Certain key names are reserved by MCP for protocol-level metadata.
    - Implementations must not make assumptions about values at these keys.
    - Schema definitions may reserve particular names for purpose-specific metadata.
  Key Name Format:
    Segments: optional prefix, name
    Prefix:
      - Format: series of labels separated by dots (.), followed by a slash (/).
      - Labels: start with a letter, end with a letter or digit; interior characters can be letters, digits, or hyphens (-).
      - Reserved: `modelcontextprotocol.[*]/` and `mcp.[*]/` (where `[*]` stands for any top-level domain).
    Name:
      - Format: Unless empty, must begin and end with an alphanumeric character ([a-z0-9A-Z]).
      - Allowed Chars: hyphens (-), underscores (_), dots (.), and alphanumerics in between.
```

----------------------------------------

TITLE: Declare Tools Capability in Model Context Protocol
DESCRIPTION: Servers supporting tools in the Model Context Protocol must declare the 'tools' capability within their capabilities object. The 'listChanged' property indicates whether the server will emit notifications when the list of available tools changes.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/tools

LANGUAGE: json
CODE:
```
{
  "capabilities": {
    "tools": {
      "listChanged": true
    }
  }
}
```

----------------------------------------

TITLE: Declare Prompts Capability in Server Initialization
DESCRIPTION: Servers that support prompts must declare the 'prompts' capability during initialization. The 'listChanged' field indicates whether the server will emit notifications when the list of available prompts changes.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/prompts

LANGUAGE: JSON
CODE:
```
{
  "capabilities": {
    "prompts": {
      "listChanged": true
    }
  }
}
```

----------------------------------------

TITLE: Declare Client Sampling Capability
DESCRIPTION: Clients that support the Model Context Protocol's sampling feature must declare this capability during their initialization process. This JSON snippet shows the structure for including the 'sampling' capability within the 'capabilities' object.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client/sampling

LANGUAGE: JSON
CODE:
```
{
  "capabilities": {
    "sampling": {}
  }
}
```

----------------------------------------

TITLE: APIDOC: Text Content Structure for MCP Messages
DESCRIPTION: This API documentation defines the structure for text-based content within Model Context Protocol messages. It specifies that content of type 'text' must include a 'text' field containing the actual message string.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/client/sampling

LANGUAGE: APIDOC
CODE:
```
{
  "type": "text",
  "text": "The message content"
}
```

----------------------------------------

TITLE: Create and Connect to MCP Client
DESCRIPTION: Initializes the Model Context Protocol (MCP) client using a `StdioClientTransport` for inter-process communication. After creation, it connects to the specified server and lists all available tools, demonstrating successful server interaction.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: C#
CODE:
```
var (command, arguments) = GetCommandAndArguments(args);

var clientTransport = new StdioClientTransport(new()
{
    Name = "Demo Server",
    Command = command,
    Arguments = arguments,
});

await using var mcpClient = await McpClientFactory.CreateAsync(clientTransport);

var tools = await mcpClient.ListToolsAsync();
foreach (var tool in tools)
{
    Console.WriteLine($"Connected to server with tools: {tool.Name}");
}
```

----------------------------------------

TITLE: Basic MCP Server Implementation Example
DESCRIPTION: Demonstrates how to set up a basic Model Context Protocol (MCP) server using the provided SDK, handling requests and connecting via Stdio transport.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/architecture

LANGUAGE: TypeScript
CODE:
```
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";

const server = new Server({
  name: "example-server",
  version: "1.0.0"
}, {
  capabilities: {
    resources: {}
  }
});

// Handle requests
server.setRequestHandler(ListResourcesRequestSchema, async () => {
  return {
    resources: [
      {
        uri: "example://resource",
        name: "Example Resource"
      }
    ]
  };
});

// Connect transport
const transport = new StdioServerTransport();
await server.connect(transport);
```

LANGUAGE: Python
CODE:
```
import asyncio
import mcp.types as types
from mcp.server import Server
from mcp.server.stdio import stdio_server

app = Server("example-server")

@app.list_resources()
async def list_resources() -> list[types.Resource]:
    return [
        types.Resource(
            uri="example://resource",
            name="Example Resource"
        )
    ]

async def main():
    async with stdio_server() as streams:
        await app.run(
            streams[0],
            streams[1],
            app.create_initialization_options()
        )

if __name__ == "__main__":
    asyncio.run(main())
```

----------------------------------------

TITLE: JSON Schema for Structured Data Elicitation Request
DESCRIPTION: This JSON snippet illustrates the structure of the "requestedSchema" field, which defines the expected response data. It shows how to specify properties with types, titles, descriptions, and validation rules like minimum/maximum values, along with required fields.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client/elicitation

LANGUAGE: json
CODE:
```
"requestedSchema": {
  "type": "object",
  "properties": {
    "propertyName": {
      "type": "string",
      "title": "Display Name",
      "description": "Description of the property"
    },
    "anotherProperty": {
      "type": "number",
      "minimum": 0,
      "maximum": 100
    }
  },
  "required": ["propertyName"]
}
```

----------------------------------------

TITLE: Define Tool with Output Schema
DESCRIPTION: This JSON snippet defines a tool named 'get_weather_data' including its input and output schemas. The output schema specifies the expected structure for weather data results, including temperature, conditions, and humidity, ensuring structured and valid responses from the tool.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/tools

LANGUAGE: JSON
CODE:
```
{
  "name": "get_weather_data",
  "title": "Weather Data Retriever",
  "description": "Get current weather data for a location",
  "inputSchema": {
    "type": "object",
    "properties": {
      "location": {
        "type": "string",
        "description": "City name or zip code"
      }
    },
    "required": ["location"]
  },
  "outputSchema": {
    "type": "object",
    "properties": {
      "temperature": {
        "type": "number",
        "description": "Temperature in celsius"
      },
      "conditions": {
        "type": "string",
        "description": "Weather conditions description"
      },
      "humidity": {
        "type": "number",
        "description": "Humidity percentage"
      }
    },
    "required": ["temperature", "conditions", "humidity"]
  }
}
```

----------------------------------------

TITLE: Protocol Capability Negotiation
DESCRIPTION: Describes the key capabilities that can be negotiated between client and server during a protocol session, including client-side and server-side features and sub-capabilities.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/basic/lifecycle

LANGUAGE: APIDOC
CODE:
```
Key capabilities include:

Category | Capability | Description
--- | --- | ---
Client | `roots` | Ability to provide filesystem roots
Client | `sampling` | Support for LLM sampling requests
Client | `experimental` | Describes support for non-standard experimental features
Server | `prompts` | Offers prompt templates
Server | `resources` | Provides readable resources
Server | `tools` | Exposes callable tools
Server | `logging` | Emits structured log messages
Server | `experimental` | Describes support for non-standard experimental features

Capability objects can describe sub-capabilities like:
* `listChanged`: Support for list change notifications (for prompts, resources, and tools)
* `subscribe`: Support for subscribing to individual items’ changes (resources only)
```

----------------------------------------

TITLE: Example: MCP Protocol Version Header for Server Metadata Discovery
DESCRIPTION: Clients should include the 'MCP-Protocol-Version' header during Server Metadata Discovery to allow the MCP server to respond based on the specified protocol version.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/basic/authorization

LANGUAGE: APIDOC
CODE:
```
MCP-Protocol-Version: 2024-11-05
```

----------------------------------------

TITLE: Model Context Protocol Authorization Flow Overview
DESCRIPTION: Outlines the essential requirements for Model Context Protocol (MCP) authorization servers and clients to conform to OAuth 2.1 and relevant OAuth 2.0 specifications. This includes support for dynamic client registration, protected resource metadata for discovery, and authorization server metadata.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/basic/authorization

LANGUAGE: APIDOC
CODE:
```
1. MCP authorization servers MUST implement OAuth 2.1 with appropriate security measures for both confidential and public clients.
2. MCP authorization servers and MCP clients SHOULD support the OAuth 2.0 Dynamic Client Registration Protocol (RFC7591).
3. MCP servers MUST implement OAuth 2.0 Protected Resource Metadata (RFC9728). MCP clients MUST use OAuth 2.0 Protected Resource Metadata for authorization server discovery.
4. MCP authorization servers MUST provide OAuth 2.0 Authorization Server Metadata (RFC8414). MCP clients MUST use the OAuth 2.0 Authorization Server Metadata.
```

----------------------------------------

TITLE: Define MCP Transport Interface
DESCRIPTION: This snippet defines the `Transport` interface, which custom transport implementations must conform to. It specifies methods for starting, sending JSON-RPC messages, closing connections, and optional callbacks for handling close, error, and message events.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/transports

LANGUAGE: TypeScript
CODE:
```
interface Transport {
  // Start processing messages
  start(): Promise<void>;

  // Send a JSON-RPC message
  send(message: JSONRPCMessage): Promise<void>;

  // Close the connection
  close(): Promise<void>;

  // Callbacks
  onclose?: () => void;
  onerror?: (error: Error) => void;
  onmessage?: (message: JSONRPCMessage) => void;
}
```

----------------------------------------

TITLE: MCP HTTP Transport Security Requirements
DESCRIPTION: Details essential security measures for servers implementing Streamable HTTP transport for the Model Context Protocol (MCP) to prevent common attacks like DNS rebinding and ensure secure local operation.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/basic/transports

LANGUAGE: APIDOC
CODE:
```
Servers MUST validate the 'Origin' header on all incoming connections to prevent DNS rebinding attacks.
When running locally, servers SHOULD bind only to localhost (127.0.0.1) rather than all network interfaces (0.0.0.0).
Servers SHOULD implement proper authentication for all connections.
```

----------------------------------------

TITLE: Streamable HTTP Server Implementation (TypeScript)
DESCRIPTION: Demonstrates a TypeScript server using Express to handle Model Context Protocol (MCP) requests over HTTP. It supports both POST for client-to-server JSON-RPC and GET for optional server-initiated SSE streams, managing single JSON responses or SSE streams based on 'needsStreaming'.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/transports

LANGUAGE: TypeScript
CODE:
```
import express from "express";

const app = express();

const server = new Server({
  name: "example-server",
  version: "1.0.0"
}, {
  capabilities: {}
});

// MCP endpoint handles both POST and GET
app.post("/mcp", async (req, res) => {
  // Handle JSON-RPC request
  const response = await server.handleRequest(req.body);

  // Return single response or SSE stream
  if (needsStreaming) {
    res.setHeader("Content-Type", "text/event-stream");
    // Send SSE events...
  } else {
    res.json(response);
  }
});

app.get("/mcp", (req, res) => {
  // Optional: Support server-initiated SSE streams
  res.setHeader("Content-Type", "text/event-stream");
  // Send server notifications/requests...
});

app.listen(3000);
```

----------------------------------------

TITLE: Configure MCP Client Logging and Set Level
DESCRIPTION: Explains how to configure an MCP client to receive log messages from the server by registering a logging consumer and setting the minimum logging level to filter messages.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-client

LANGUAGE: Java
CODE:
```
var mcpClient = McpClient.sync(transport)
        .loggingConsumer(notification -> {
            System.out.println("Received log message: " + notification.data());
        })
        .build();

mcpClient.initialize();

mcpClient.setLoggingLevel(McpSchema.LoggingLevel.INFO);

// Call the tool that can sends logging notifications
CallToolResult result = mcpClient.callTool(new McpSchema.CallToolRequest("logging-test", Map.of()));
```

----------------------------------------

TITLE: MCP: HTTPS URI Scheme Usage
DESCRIPTION: Describes the usage of the `https://` URI scheme within the Model Context Protocol. It specifies that this scheme should only be used when clients can directly fetch the resource from the web, without server intervention.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/resources

LANGUAGE: APIDOC
CODE:
```
https://:
  Description: Used to represent a resource available on the web.
  Usage Constraint: Servers SHOULD use this scheme only when the client is able to fetch and load the resource directly from the web on its own—that is, it doesn’t need to read the resource via the MCP server.
  Alternative: For other use cases, servers SHOULD prefer to use another URI scheme, or define a custom one, even if the server will itself be downloading resource contents over the internet.
```

----------------------------------------

TITLE: Configure Environment Variables for MCP Server
DESCRIPTION: Demonstrates how to specify custom environment variables for an MCP server by adding an 'env' key to the 'claude_desktop_config.json' file. This allows overriding default variables or providing new ones for the server process.
SOURCE: https://modelcontextprotocol.io/introduction/docs/tools/debugging

LANGUAGE: JSON
CODE:
```
{
  "myserver": {
    "command": "mcp-server-myapp",
    "env": {
      "MYAPP_API_KEY": "some_key"
    }
  }
}
```

----------------------------------------

TITLE: CreateMessageRequest Object Properties
DESCRIPTION: Describes the configurable properties of the `CreateMessageRequest` object used when sending messages to the model. These properties allow control over the input content, model selection hints, behavioral instructions, and response length.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-server

LANGUAGE: APIDOC
CODE:
```
CreateMessageRequest:
  Content: The input text or image for the model
  Model Preferences: Hints and priorities for model selection
  System Prompt: Instructions for the model’s behavior
  Max Tokens: Maximum length of the generated response
```

----------------------------------------

TITLE: Access Resources Asynchronously with MCP Client (Java)
DESCRIPTION: Demonstrates how to list available server-side resources and retrieve their content using a URI template via the asynchronous API of the Model Context Protocol (MCP) client. This leverages reactive patterns for non-blocking resource access.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-client

LANGUAGE: Java
CODE:
```
// List available resources asynchronously
client.listResources()
    .doOnNext(resources -> resources.forEach(resource ->
        System.out.println(resource.getName())))
    .subscribe();

// Retrieve resource content asynchronously
client.getResource("file", Map.of(
            "path", "/path/to/file.txt"
        ))
    .subscribe();
```

----------------------------------------

TITLE: Tool Definition Data Type
DESCRIPTION: Defines the structure and properties of a tool. It includes a unique name, an optional human-readable title, a description of its functionality, JSON schemas for its input and output parameters, and optional annotations describing its behavior.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/tools

LANGUAGE: APIDOC
CODE:
```
Tool:
  name: Unique identifier for the tool
  title: Optional human-readable name of the tool for display purposes.
  description: Human-readable description of functionality
  inputSchema: JSON Schema defining expected parameters
  outputSchema: Optional JSON Schema defining expected output structure
  annotations: optional properties describing tool behavior
```

----------------------------------------

TITLE: Client Guidelines for Backwards Compatibility with HTTP+SSE Transport
DESCRIPTION: Steps for clients to determine if a server supports the new Streamable HTTP transport or the older HTTP+SSE transport based on initial request attempts and expected responses.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/basic/transports

LANGUAGE: APIDOC
CODE:
```
Clients wanting to support older servers should:
1. Accept an MCP server URL from the user, which may point to either a server using the old transport or the new transport.
2. Attempt to POST an InitializeRequest to the server URL, with an Accept header.
   - If it succeeds, the client can assume this is a server supporting the new Streamable HTTP transport.
   - If it fails with an HTTP 4xx status code (e.g., 405 Method Not Allowed or 404 Not Found):
     + Issue a GET request to the server URL, expecting that this will open an SSE stream and return an endpoint event as the first event.
     + When the endpoint event arrives, the client can assume this is a server running the old HTTP+SSE transport, and should use that transport for all subsequent communication.
```

----------------------------------------

TITLE: Example Protocol Initialization Error Response (JSON)
DESCRIPTION: An example JSON response illustrating an error during the protocol initialization phase, specifically for an unsupported protocol version. It includes the error code, message, and details about supported and requested versions.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/basic/lifecycle

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -32602,
    "message": "Unsupported protocol version",
    "data": {
      "supported": ["2024-11-05"],
      "requested": "1.0.0"
    }
  }
}
```

----------------------------------------

TITLE: Implement MCP Server with Standard I/O Transport
DESCRIPTION: Demonstrates how to set up an MCP server using the Standard Input/Output (stdio) transport. This transport is suitable for local integrations and command-line tools, enabling communication via standard streams.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/transports

LANGUAGE: TypeScript
CODE:
```
const server = new Server({
  name: "example-server",
  version: "1.0.0"
}, {
  capabilities: {}
});

const transport = new StdioServerTransport();
await server.connect(transport);

```

LANGUAGE: Python
CODE:
```
app = Server("example-server")

async with stdio_server() as streams:
    await app.run(
        streams[0],
        streams[1],
        app.create_initialization_options()
    )

```

----------------------------------------

TITLE: Streamable HTTP Client Connection (TypeScript)
DESCRIPTION: Illustrates how a TypeScript client connects to an MCP endpoint using `HttpClientTransport`. It initializes a client instance and establishes a connection to the server.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/transports

LANGUAGE: TypeScript
CODE:
```
const client = new Client({
  name: "example-client",
  version: "1.0.0"
}, {
  capabilities: {}
});

const transport = new HttpClientTransport(
  new URL("http://localhost:3000/mcp")
);
await client.connect(transport);
```

----------------------------------------

TITLE: Model Context Protocol Implementation Considerations
DESCRIPTION: Guidelines for implementing the protocol, covering server responsibilities like sorting and rate limiting, and client responsibilities like debouncing and caching.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/utilities/completion

LANGUAGE: APIDOC
CODE:
```
Implementation Considerations:
  Servers SHOULD:
    - Return suggestions sorted by relevance
    - Implement fuzzy matching where appropriate
    - Rate limit completion requests
    - Validate all inputs
  Clients SHOULD:
    - Debounce rapid completion requests
    - Cache completion results where appropriate
    - Handle missing or partial results gracefully
```

----------------------------------------

TITLE: Implement Error Handling in Python Custom Transport with AnyIO
DESCRIPTION: This Python snippet shows an example of error handling within an `anyio`-based custom transport. It uses try-except blocks to catch exceptions during transport initialization and message handling, logging errors and ensuring resource cleanup via `finally` blocks and task group cancellation.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/transports

LANGUAGE: Python
CODE:
```
@contextmanager
async def example_transport(scope: Scope, receive: Receive, send: Send):
    try:
        # Create streams for bidirectional communication
        read_stream_writer, read_stream = anyio.create_memory_object_stream(0)
        write_stream, write_stream_reader = anyio.create_memory_object_stream(0)

        async def message_handler():
            try:
                async with read_stream_writer:
                    # Message handling logic
                    pass
            except Exception as exc:
                logger.error(f"Failed to handle message: {exc}")
                raise exc

        async with anyio.create_task_group() as tg:
            tg.start_soon(message_handler)
            try:
                # Yield streams for communication
                yield read_stream, write_stream
            except Exception as exc:
                logger.error(f"Transport error: {exc}")
                raise exc
            finally:
                tg.cancel_scope.cancel()
                await write_stream.aclose()
                await read_stream.aclose()
    except Exception as exc:
        logger.error(f"Failed to initialize transport: {exc}")
        raise exc
```

----------------------------------------

TITLE: Run Python MCP Server with uvx or pip
DESCRIPTION: Shows how to run a Python-based Model Context Protocol (MCP) server using either `uvx` (recommended) or `pip` for installation and execution.
SOURCE: https://modelcontextprotocol.io/introduction/examples

LANGUAGE: bash
CODE:
```
# Using uvx
uvx mcp-server-git
```

LANGUAGE: bash
CODE:
```
# Using pip
pip install mcp-server-git
python -m mcp_server_git
```

----------------------------------------

TITLE: Listening for Server-Initiated Messages from MCP Server via HTTP GET (SSE)
DESCRIPTION: Outlines how clients can establish a Server-Sent Events (SSE) stream with the Model Context Protocol (MCP) server using HTTP GET to receive server-initiated messages. It specifies header requirements, server response types, and the types of messages the server can send on such a stream.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/basic/transports

LANGUAGE: APIDOC
CODE:
```
Server to Client Communication (HTTP GET for SSE):
- Endpoint: MCP endpoint
- Method: HTTP GET (optional for client)
- Headers:
    - Accept: "text/event-stream"
- Server Response:
    - Content-Type: "text/event-stream" (initiates SSE stream)
    - HTTP 405 Method Not Allowed (if server does not offer SSE stream at this endpoint)
- SSE Stream Behavior (if initiated by server):
    - Server may send JSON-RPC requests and notifications on the stream (may be batched)
    - These messages should be unrelated to any concurrently-running JSON-RPC request from the client
    - Server MUST NOT send a JSON-RPC response on the stream, unless resuming a stream associated with a previous client request
    - Server may close the SSE stream at any time
    - Client may close the SSE stream at any time
```

----------------------------------------

TITLE: APIDOC: Model Context Protocol Capability Negotiation
DESCRIPTION: Explains how client and server establish available optional protocol features. Lists key capabilities for both client and server, such as 'roots', 'sampling', 'prompts', and 'tools', and describes sub-capabilities like 'listChanged' and 'subscribe'.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/basic/lifecycle

LANGUAGE: APIDOC
CODE:
```
Capability Negotiation Process:
  Establishes optional protocol features for the session.

Key Capabilities:
  Client:
    roots: Ability to provide filesystem roots.
    sampling: Support for LLM sampling requests.
    elicitation: Support for server elicitation requests.
    experimental: Support for non-standard experimental features.
  Server:
    prompts: Offers prompt templates.
    resources: Provides readable resources.
    tools: Exposes callable tools.
    logging: Emits structured log messages.
    completions: Supports argument autocompletion.
    experimental: Support for non-standard experimental features.

Sub-Capabilities:
  listChanged: Support for list change notifications (prompts, resources, tools).
  subscribe: Support for subscribing to individual items' changes (resources only).
```

----------------------------------------

TITLE: Resource Subscription API Request and Update Notification
DESCRIPTION: The protocol supports optional subscriptions to resource changes. Clients can subscribe to specific resources using `resources/subscribe` and receive `notifications/resources/updated` when the subscribed resource changes.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/resources

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 4,
  "method": "resources/subscribe",
  "params": {
    "uri": "file:///project/src/main.rs"
  }
}
```

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "method": "notifications/resources/updated",
  "params": {
    "uri": "file:///project/src/main.rs",
    "title": "Rust Software Application Main File"
  }
}
```

----------------------------------------

TITLE: MCP stdio Transport Protocol Specification
DESCRIPTION: Defines the standard input/output transport for Model Context Protocol, where the client launches the server as a subprocess and messages are exchanged via stdin/stdout, delimited by newlines.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/basic/transports

LANGUAGE: APIDOC
CODE:
```
stdio Transport:
  - Client launches server as subprocess.
  - Server receives JSON-RPC messages on stdin, writes responses to stdout.
  - Messages are newline-delimited, MUST NOT contain embedded newlines.
  - Server MAY write UTF-8 strings to stderr for logging.
  - Server MUST NOT write anything to stdout that is not a valid MCP message.
  - Client MUST NOT write anything to server's stdin that is not a valid MCP message.
```

----------------------------------------

TITLE: API Response: List Available Prompts
DESCRIPTION: The server responds to a 'prompts/list' request with a list of available prompts. Each prompt includes its name, description, and a list of arguments. A 'nextCursor' is provided for pagination to retrieve more results.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/prompts

LANGUAGE: APIDOC
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "prompts": [
      {
        "name": "code_review",
        "description": "Asks the LLM to analyze code quality and suggest improvements",
        "arguments": [
          {
            "name": "code",
            "description": "The code to review",
            "required": true
          }
        ]
      }
    ],
    "nextCursor": "next-page-cursor"
  }
}
```

----------------------------------------

TITLE: Create STDIO Client Transport (In-Process)
DESCRIPTION: Configures and creates an in-process STDIO client transport for MCP, using ServerParameters to specify the server executable and arguments for local communication.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-client

LANGUAGE: Java
CODE:
```
ServerParameters params = ServerParameters.builder("npx")
    .args("-y", "@modelcontextprotocol/server-everything", "dir")
    .build();
McpTransport transport = new StdioClientTransport(params);
```

----------------------------------------

TITLE: Declare Prompts Capability in MCP Server Initialization
DESCRIPTION: Servers that support prompt functionality within the Model Context Protocol must declare the 'prompts' capability during their initialization phase. The 'listChanged' flag indicates whether the server will emit notifications when the list of available prompts is updated.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/prompts

LANGUAGE: json
CODE:
```
{
  "capabilities": {
    "prompts": {
      "listChanged": true
    }
  }
}
```

----------------------------------------

TITLE: Model Context Protocol Security Requirements
DESCRIPTION: Mandatory security measures for protocol implementations, including input validation, rate limiting, access control, and preventing information disclosure.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/utilities/completion

LANGUAGE: APIDOC
CODE:
```
Security:
  Implementations MUST:
    - Validate all completion inputs
    - Implement appropriate rate limiting
    - Control access to sensitive suggestions
    - Prevent completion-based information disclosure
```

----------------------------------------

TITLE: Define Basic MCP Client Class Structure
DESCRIPTION: Outlines the initial TypeScript code for the `MCPClient` class, including necessary imports from Anthropic and MCP SDKs, environment variable loading for the API key, and class property declarations for managing connections and tools.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: typescript
CODE:
```
import { Anthropic } from "@anthropic-ai/sdk";
import {
  MessageParam,
  Tool,
} from "@anthropic-ai/sdk/resources/messages/messages.mjs";
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { StdioClientTransport } from "@modelcontextprotocol/sdk/client/stdio.js";
import readline from "readline/promises";
import dotenv from "dotenv";

dotenv.config();

const ANTHROPIC_API_KEY = process.env.ANTHROPIC_API_KEY;
if (!ANTHROPIC_API_KEY) {
  throw new Error("ANTHROPIC_API_KEY is not set");
}

class MCPClient {
  private mcp: Client;
  private anthropic: Anthropic;
  private transport: StdioClientTransport | null = null;
  private tools: Tool[] = [];

  constructor() {
    this.anthropic = new Anthropic({
      apiKey: ANTHROPIC_API_KEY,
    });
    this.mcp = new Client({ name: "mcp-client-cli", version: "1.0.0" });
  }
  // methods will go here
}
```

----------------------------------------

TITLE: Create Spring Boot Application for MCP Server Tool Registration
DESCRIPTION: Illustrates the main Spring Boot application class (`McpServerApplication`) responsible for running the MCP server. It shows how to register `@Tool` annotated services, like `WeatherService`, as `ToolCallbackProvider` beans using `MethodToolCallbackProvider` for automatic tool registration with the MCP server.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: Java
CODE:
```
@SpringBootApplication
public class McpServerApplication {

	public static void main(String[] args) {
		SpringApplication.run(McpServerApplication.class, args);
	}

	@Bean
	public ToolCallbackProvider weatherTools(WeatherService weatherService) {
		return  MethodToolCallbackProvider.builder().toolObjects(weatherService).build();
	}
}
```

----------------------------------------

TITLE: MCP: Subscribe to Resource Changes Request
DESCRIPTION: Clients send this JSON-RPC request to subscribe to changes for a specific resource. The `uri` parameter identifies the resource to monitor.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/resources

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 4,
  "method": "resources/subscribe",
  "params": {
    "uri": "file:///project/src/main.rs"
  }
}
```

----------------------------------------

TITLE: Server Request to List Roots
DESCRIPTION: Servers send a 'roots/list' request to retrieve the current list of roots from the client. This is a standard JSON-RPC request.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client/roots

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "roots/list"
}
```

----------------------------------------

TITLE: List Resources API Request and Response
DESCRIPTION: Clients use the `resources/list` method to discover available resources. This operation supports pagination, allowing for efficient retrieval of large resource sets. The response includes a list of resources and an optional cursor for the next page.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/resources

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "resources/list",
  "params": {
    "cursor": "optional-cursor-value"
  }
}
```

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "resources": [
      {
        "uri": "file:///project/src/main.rs",
        "name": "main.rs",
        "title": "Rust Software Application Main File",
        "description": "Primary application entry point",
        "mimeType": "text/x-rust"
      }
    ],
    "nextCursor": "next-page-cursor"
  }
}
```

----------------------------------------

TITLE: MCP Resources List Request Message
DESCRIPTION: JSON message for a client's 'resources/list' request, used to discover available resources. It includes a unique ID and an optional 'cursor' parameter for pagination.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/resources

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "resources/list",
  "params": {
    "cursor": "optional-cursor-value"
  }
}
```

----------------------------------------

TITLE: Build and Run MCP Client with Gradle and Java
DESCRIPTION: These commands demonstrate how to build the MCP client using Gradle and then run it with Java, connecting to different types of MCP servers (JVM, Python, Node.js). The `gradlew build` command compiles the project, and `java -jar` executes the compiled client JAR, requiring the path to the server JAR/script as an argument.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: shell
CODE:
```
./gradlew build

# Run the client
java -jar build/libs/<your-jar-name>.jar path/to/server.jar # jvm server
java -jar build/libs/<your-jar-name>.jar path/to/server.py # python server
java -jar build/libs/<your-jar-name>.jar path/to/build/index.js # node server
```

----------------------------------------

TITLE: Configure Spring AI ChatClient with MCP Tools
DESCRIPTION: This Java snippet demonstrates how to build a Spring AI ChatClient, integrating Model Context Protocol (MCP) tools, setting a default system prompt, and enabling in-memory chat memory for conversation context. It highlights the use of `.defaultToolCallbacks()` for MCP tool registration.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: Java
CODE:
```
var chatClient = chatClientBuilder
    .defaultSystem("You are useful assistant, expert in AI and Java.")
    .defaultToolCallbacks((Object[]) mcpToolAdapter.toolCallbacks())
    .defaultAdvisors(new MessageChatMemoryAdvisor(new InMemoryChatMemory()))
    .build();
```

----------------------------------------

TITLE: MCP stdio Transport Mechanism
DESCRIPTION: Details how client-server communication occurs over standard input/output (stdin/stdout) using JSON-RPC messages. It specifies message formatting, batching, and handling of logging.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/basic/transports

LANGUAGE: APIDOC
CODE:
```
stdio Transport:
  Description: Communication over standard input (stdin) and standard output (stdout).
  Client-Server Interaction:
    - Client launches MCP server as a subprocess.
    - Server reads JSON-RPC messages from stdin, sends to stdout.
  Message Format:
    - JSON-RPC messages.
    - UTF-8 encoded.
    - Delimited by newlines.
    - MUST NOT contain embedded newlines.
    - Messages can be requests, notifications, responses, or JSON-RPC batches.
  Logging:
    - Server MAY write UTF-8 strings to stderr for logging.
    - Clients MAY capture, forward, or ignore stderr logging.
  Constraints:
    - Server MUST NOT write anything to stdout that is not a valid MCP message.
    - Client MUST NOT write anything to server's stdin that is not a valid MCP message.
```

----------------------------------------

TITLE: Send prompts/list Request for Available Prompts
DESCRIPTION: Clients send a 'prompts/list' request to retrieve available prompts. This operation supports pagination, allowing for an optional 'cursor' parameter to fetch subsequent pages of results.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/prompts

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "prompts/list",
  "params": {
    "cursor": "optional-cursor-value"
  }
}
```

----------------------------------------

TITLE: Model Context Protocol JSON-RPC Response Message
DESCRIPTION: Defines the structure for response messages sent in reply to requests. Responses must include the same ID as the corresponding request and contain either a `result` for successful operations or an `error` for failures, but never both. Errors must include a numeric code and a message.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/basic

LANGUAGE: APIDOC
CODE:
```
{
  jsonrpc: "2.0";
  id: string | number;
  result?: {
    [key: string]: unknown;
  }
  error?: {
    code: number;
    message: string;
    data?: unknown;
  }
}
```

----------------------------------------

TITLE: Protocol Version Negotiation Flow
DESCRIPTION: Describes the handshake process for establishing a compatible protocol version between client and server, including rules for response and disconnection.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/basic/lifecycle

LANGUAGE: APIDOC
CODE:
```
Version Negotiation Process:
  Client MUST send latest supported protocol version in 'initialize' request.
  Server Response:
    If server supports requested version: MUST respond with same version.
    If server does NOT support requested version: MUST respond with latest supported version.
  Client Action:
    If client does NOT support version in server's response: SHOULD disconnect.
```

----------------------------------------

TITLE: Model Context Protocol Cancellation Notification
DESCRIPTION: Defines the structure and behavior of the `notifications/cancelled` notification in the Model Context Protocol, used to terminate in-progress requests. It includes the request ID and an optional reason for cancellation, with specific requirements for senders and receivers regarding timing and resource management.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/basic/utilities/cancellation

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "method": "notifications/cancelled",
  "params": {
    "requestId": "123",
    "reason": "User requested cancellation"
  }
}
```

LANGUAGE: APIDOC
CODE:
```
Method: notifications/cancelled
Type: Notification
Purpose: Indicates that a previously-issued request should be terminated.

Parameters:
  - requestId: string
    Description: The ID of the request to cancel. (Required)
  - reason: string (Optional)
    Description: An optional reason string that can be logged or displayed.

Behavior Requirements:
1. Cancellation notifications MUST only reference requests that:
   - Were previously issued in the same direction
   - Are believed to still be in-progress
2. The `initialize` request MUST NOT be cancelled by clients.
3. Receivers of cancellation notifications SHOULD:
   - Stop processing the cancelled request
   - Free associated resources
   - Not send a response for the cancelled request
4. Receivers MAY ignore cancellation notifications if:
   - The referenced request is unknown
   - Processing has already completed
   - The request cannot be cancelled
5. The sender of the cancellation notification SHOULD ignore any response to the request that arrives afterward.

Timing Considerations:
Due to network latency, cancellation notifications may arrive after request processing has completed, and potentially after a response has already been sent. Both parties MUST handle these race conditions gracefully.

Implementation Notes:
- Both parties SHOULD log cancellation reasons for debugging.
- Application UIs SHOULD indicate when cancellation is requested.
```

----------------------------------------

TITLE: Model Context Protocol: notifications/cancelled Notification API
DESCRIPTION: Defines the `notifications/cancelled` notification message within the Model Context Protocol. This message is sent by either party to request the termination of a previously issued and in-progress request. Receivers should stop processing, free resources, and not send a response for the cancelled request.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/basic/utilities/cancellation

LANGUAGE: APIDOC
CODE:
```
Method: notifications/cancelled
Type: Notification
Purpose: Signals the cancellation of an in-progress request.

Parameters:
  requestId: string
    Description: The ID of the request to cancel.
    Required: Yes
  reason: string (optional)
    Description: An optional string providing the reason for cancellation, useful for logging or display.
    Required: No

Behavior Requirements:
  1. Cancellation notifications MUST only reference requests that:
     - Were previously issued in the same direction
     - Are believed to still be in-progress
  2. The 'initialize' request MUST NOT be cancelled by clients
  3. Receivers of cancellation notifications SHOULD:
     - Stop processing the cancelled request
     - Free associated resources
     - Not send a response for the cancelled request
  4. Receivers MAY ignore cancellation notifications if:
     - The referenced request is unknown
     - Processing has already completed
     - The request cannot be cancelled
  5. The sender of the cancellation notification SHOULD ignore any response to the request that arrives afterward
```

----------------------------------------

TITLE: Example Model Context Protocol Cancellation Notification
DESCRIPTION: This JSON snippet illustrates the structure of a `notifications/cancelled` message, which is used to signal the termination of an in-progress request. It includes the `requestId` of the request to be cancelled and an optional `reason`.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/basic/utilities/cancellation

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "method": "notifications/cancelled",
  "params": {
    "requestId": "123",
    "reason": "User requested cancellation"
  }
}
```

----------------------------------------

TITLE: Request Model Context Protocol Roots List
DESCRIPTION: Servers send a 'roots/list' request to a Model Context Protocol client to retrieve the current list of exposed filesystem roots.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/client

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "roots/list"
}
```

----------------------------------------

TITLE: Declare Client Roots Capability
DESCRIPTION: Clients supporting the 'roots' feature must declare this capability during initialization. The 'listChanged' property indicates whether the client will send notifications when the list of roots changes.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client/roots

LANGUAGE: JSON
CODE:
```
{
  "capabilities": {
    "roots": {
      "listChanged": true
    }
  }
}
```

----------------------------------------

TITLE: Declare Model Context Protocol Resources Capability with No Features
DESCRIPTION: This JSON snippet demonstrates how a server declares the 'resources' capability without supporting any optional features like 'subscribe' or 'listChanged'. This indicates that the server can expose resources but does not provide real-time updates or change notifications.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/resources

LANGUAGE: JSON
CODE:
```
{
  "capabilities": {
    "resources": {}
  }
}
```

----------------------------------------

TITLE: JSON Structure for Text Content in Prompt Messages
DESCRIPTION: This defines the structure for plain text messages within a prompt, which is the most common content type for natural language interactions.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/prompts

LANGUAGE: JSON
CODE:
```
{
  "type": "text",
  "text": "The text content of the message"
}
```

----------------------------------------

TITLE: Setting up a new Python project with uv
DESCRIPTION: This snippet demonstrates how to initialize a new Python project directory, create and activate a virtual environment, install necessary packages (mcp, anthropic, python-dotenv), and remove boilerplate files using the `uv` package manager. It includes commands for both Windows and Unix/MacOS environments.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: Shell
CODE:
```
# Create project directory
uv init mcp-client
cd mcp-client

# Create virtual environment
uv venv

# Activate virtual environment
# On Windows:
.venv\Scripts\activate
# On Unix or MacOS:
source .venv/bin/activate

# Install required packages
uv add mcp anthropic python-dotenv

# Remove boilerplate files
# On Windows:
del main.py
# On Unix or MacOS:
rm main.py

# Create our main file
touch client.py
```

----------------------------------------

TITLE: Define Main Execution Logic for MCP Client in Python
DESCRIPTION: This Python snippet provides the main entry point for the MCP client, handling command-line arguments for server connection, initiating the chat loop, and ensuring resource cleanup upon exit.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: Python
CODE:
```
async def main():
    if len(sys.argv) < 2:
        print("Usage: python client.py <path_to_server_script>")
        sys.exit(1)

    client = MCPClient()
    try:
        await client.connect_to_server(sys.argv[1])
        await client.chat_loop()
    finally:
        await client.cleanup()

if __name__ == "__main__":
    import sys
    asyncio.run(main())
```

----------------------------------------

TITLE: Initialize Model Context Protocol Server and List Prompts in Python
DESCRIPTION: This Python snippet initializes a `Server` instance and defines an asynchronous function `list_prompts` decorated with `@app.list_prompts()`. This function returns a list of all defined prompts, making them discoverable by clients interacting with the server.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/prompts

LANGUAGE: Python
CODE:
```
app = Server("example-prompts-server")

@app.list_prompts()
async def list_prompts() -> list[types.Prompt]:
    return list(PROMPTS.values())
```

----------------------------------------

TITLE: Configure WebFlux SSE Server Transport (Java)
DESCRIPTION: This configuration class sets up a WebFlux-based SSE server transport for the MCP SDK. It requires the `mcp-spring-webflux` dependency and provides reactive HTTP streaming, concurrent client connections, and message routing using Spring WebFlux.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-server

LANGUAGE: Java
CODE:
```
@Configuration
class McpConfig {
    @Bean
    WebFluxSseServerTransportProvider webFluxSseServerTransportProvider(ObjectMapper mapper) {
        return new WebFluxSseServerTransportProvider(mapper, "/mcp/message");
    }

    @Bean
    RouterFunction<?> mcpRouterFunction(WebFluxSseServerTransportProvider transportProvider) {
        return transportProvider.getRouterFunction();
    }
}
```

----------------------------------------

TITLE: Configure Model Context Protocol Server in Program.cs
DESCRIPTION: This C# code configures a basic Model Context Protocol (MCP) server within a .NET console application. It uses `CreateEmptyApplicationBuilder` for STDIO transport, adds MCP server services, includes tools from the assembly, and registers an `HttpClient` with a custom User-Agent for external API calls, such as to weather.gov.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: C#
CODE:
```
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using ModelContextProtocol;
using System.Net.Http.Headers;

var builder = Host.CreateEmptyApplicationBuilder(settings: null);

builder.Services.AddMcpServer()
    .WithStdioServerTransport()
    .WithToolsFromAssembly();

builder.Services.AddSingleton(_ =>
{
    var client = new HttpClient() { BaseAddress = new Uri("https://api.weather.gov") };
    client.DefaultRequestHeaders.UserAgent.Add(new ProductInfoHeaderValue("weather-tool", "1.0"));
    return client;
});

var app = builder.Build();

await app.RunAsync();
```

----------------------------------------

TITLE: Integrate Tool Annotations in Python Server with FastMCP
DESCRIPTION: This Python snippet demonstrates how to define and register a tool using the `FastMCP` framework. It shows a `calculate_sum` asynchronous function decorated with `@mcp.tool` to include `annotations` like `title`, `readOnlyHint`, and `openWorldHint`, making the tool available to the server.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/tools

LANGUAGE: Python
CODE:
```
from mcp.server.fastmcp import FastMCP

mcp = FastMCP("example-server")

@mcp.tool(
    annotations={
        "title": "Calculate Sum",
        "readOnlyHint": True,
        "openWorldHint": False
    }
)
async def calculate_sum(a: float, b: float) -> str:
    """Add two numbers together.

    Args:
        a: First number to add
        b: Second number to add
    """
    result = a + b
    return str(result)
```

----------------------------------------

TITLE: MCP: Resource List Changed Notification
DESCRIPTION: Servers that support the `listChanged` capability should send this JSON-RPC notification to clients when the list of available resources has been updated.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/resources

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "method": "notifications/resources/list_changed"
}
```

----------------------------------------

TITLE: JSON-RPC Notification: Prompt List Changed
DESCRIPTION: Servers that support the `listChanged` capability should send this notification to clients when the list of available prompts has been updated. This informs clients that they may need to refresh their prompt lists.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/prompts

LANGUAGE: APIDOC
CODE:
```
{
  "jsonrpc": "2.0",
  "method": "notifications/prompts/list_changed"
}
```

----------------------------------------

TITLE: APIDOC: notifications/roots/list_changed Notification
DESCRIPTION: Describes the JSON-RPC 2.0 notification sent by a client to a server when the list of roots changes, provided the client supports the 'listChanged' capability.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client

LANGUAGE: APIDOC
CODE:
```
Notification: notifications/roots/list_changed
  jsonrpc: string (2.0)
  method: string ("notifications/roots/list_changed")
```

----------------------------------------

TITLE: MCP Pagination Implementation Guidelines
DESCRIPTION: Guidelines for implementing pagination in Model Context Protocol (MCP) for both servers and clients, covering cursor stability, error handling, and client behavior regarding cursor opacity and session persistence.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/utilities/pagination

LANGUAGE: APIDOC
CODE:
```
Servers SHOULD:
  - Provide stable cursors
  - Handle invalid cursors gracefully
Clients SHOULD:
  - Treat a missing nextCursor as the end of results
  - Support both paginated and non-paginated flows
Clients MUST treat cursors as opaque tokens:
  - Don’t make assumptions about cursor format
  - Don’t attempt to parse or modify cursors
  - Don’t persist cursors across sessions
```

----------------------------------------

TITLE: MCP Client-to-Server Message Sending via HTTP POST
DESCRIPTION: Specifies the protocol for clients sending JSON-RPC messages to the MCP endpoint using HTTP POST requests, detailing header requirements, body content, and server response behaviors for requests, notifications, and responses.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/basic/transports

LANGUAGE: APIDOC
CODE:
```
Client-to-Server Communication (HTTP POST):
  Method: HTTP POST for every JSON-RPC message.
  Headers:
    Accept: MUST include 'application/json' and 'text/event-stream'.
  Body: MUST be a single JSON-RPC request, notification, or response.

  If input is JSON-RPC response or notification:
    Server accepts: MUST return HTTP 202 Accepted with no body.
    Server cannot accept: MUST return HTTP error status (e.g., 400 Bad Request).
      Response Body: MAY comprise a JSON-RPC error response with no 'id'.

  If input is JSON-RPC request:
    Server Response Content-Type: MUST be 'text/event-stream' (SSE) or 'application/json' (single JSON object).
    Client: MUST support both cases.

  If server initiates SSE stream (for a request):
    Stream Content: SHOULD eventually include JSON-RPC response for the originating request.
    Intermediate Messages: MAY send JSON-RPC requests and notifications before the final response, related to the originating client request.
    Stream Closure: SHOULD NOT close before sending the JSON-RPC response, unless session expires. SHOULD close after sending the response.
    Disconnection: MAY occur at any time.
      Interpretation: SHOULD NOT be interpreted as client cancelling.
      Cancellation: Client SHOULD explicitly send an MCP 'CancelledNotification'.
      Resumability: Server MAY make stream resumable to avoid message loss.
```

----------------------------------------

TITLE: Server-Side Tool Sending Structured Logging Notifications
DESCRIPTION: This Java example shows how a server-side tool, specifically an `AsyncToolSpecification`, can send structured log messages to connected clients. It uses the `exchange.loggingNotification()` method to send a `DEBUG` level message with a specific logger and data, demonstrating real-time communication of operational insights.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-server

LANGUAGE: Java
CODE:
```
var tool = new McpServerFeatures.AsyncToolSpecification(
    new McpSchema.Tool("logging-test", "Test logging notifications", emptyJsonSchema),
    (exchange, request) -> {

      exchange.loggingNotification( // Use the exchange to send log messages
          McpSchema.LoggingMessageNotification.builder()
            .level(McpSchema.LoggingLevel.DEBUG)
            .logger("test-logger")
            .data("Debug message")
            .build())
        .block();

      return Mono.just(new CallToolResult("Logging test completed", false));
    });

var mcpServer = McpServer.async(mcpServerTransportProvider)
  .serverInfo("test-server", "1.0.0")
  .capabilities(
    ServerCapabilities.builder()
      .logging() // Enable logging support
      .tools(true)
      .build())
  .tools(tool)
  .build();
```

----------------------------------------

TITLE: Server Initialize Response (JSON-RPC)
DESCRIPTION: The server responds to the client's 'initialize' request with its own protocol version, capabilities, and server implementation information. This response completes the capability negotiation phase, allowing the client to understand the server's supported features.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/basic/lifecycle

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "protocolVersion": "2024-11-05",
    "capabilities": {
      "logging": {},
      "prompts": {
        "listChanged": true
      },
      "resources": {
        "subscribe": true,
        "listChanged": true
      },
      "tools": {
        "listChanged": true
      }
    },
    "serverInfo": {
      "name": "ExampleServer",
      "title": "Example Server Display Name",
      "version": "1.0.0"
    },
    "instructions": "Optional instructions for the client"
  }
}
```

----------------------------------------

TITLE: MCP Tool Annotations Reference
DESCRIPTION: Defines the available annotations for Model Context Protocol (MCP) tools. These annotations provide additional metadata for clients, such as UI display hints, read-only status, destructive potential, idempotency, and interaction with external entities. They are intended as hints and should not be used for security decisions.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/tools

LANGUAGE: APIDOC
CODE:
```
Tool Annotations:
  title:
    Type: string
    Default: -
    Description: A human-readable title for the tool, useful for UI display.
  readOnlyHint:
    Type: boolean
    Default: false
    Description: If true, indicates the tool does not modify its environment.
  destructiveHint:
    Type: boolean
    Default: true
    Description: If true, the tool may perform destructive updates (only meaningful when readOnlyHint is false).
  idempotentHint:
    Type: boolean
    Default: false
    Description: If true, calling the tool repeatedly with the same arguments has no additional effect (only meaningful when readOnlyHint is false).
  openWorldHint:
    Type: boolean
    Default: true
    Description: If true, the tool may interact with an “open world” of external entities.
```

----------------------------------------

TITLE: Receive Model Context Protocol Completion Results
DESCRIPTION: Servers respond to 'completion/complete' requests with a JSON-RPC response containing an array of suggested values. This example shows a successful response with 'python', 'pytorch', and 'pyside' as suggestions, indicating a total of 10 matches and more results available.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/utilities/completion

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "completion": {
      "values": ["python", "pytorch", "pyside"],
      "total": 10,
      "hasMore": true
    }
  }
}
```

----------------------------------------

TITLE: Set Anthropic API Key in .env File
DESCRIPTION: Illustrates how to create a `.env` file and store the Anthropic API key within it. It also includes a command to add `.env` to `.gitignore` for security.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: bash
CODE:
```
echo "ANTHROPIC_API_KEY=<your key here>" > .env

echo ".env" >> .gitignore
```

----------------------------------------

TITLE: Call Tool Request (JSON-RPC)
DESCRIPTION: Demonstrates the JSON-RPC request format for invoking a tool, specifying the tool's name and its arguments.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/tools

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "tools/call",
  "params": {
    "name": "get_weather",
    "arguments": {
      "location": "New York"
    }
  }
}
```

----------------------------------------

TITLE: Configure WebMvc SSE Server Transport (Java)
DESCRIPTION: This configuration class demonstrates how to create a WebMvc-based SSE server transport for the MCP SDK. It integrates with Spring WebMVC to provide server-side event streaming and synchronous operation handling for traditional web applications, requiring the `mcp-spring-webmvc` dependency.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-server

LANGUAGE: Java
CODE:
```
@Configuration
@EnableWebMvc
class McpConfig {
    @Bean
    WebMvcSseServerTransportProvider webMvcSseServerTransportProvider(ObjectMapper mapper) {
        return new WebMvcSseServerTransportProvider(mapper, "/mcp/message");
    }

    @Bean
    RouterFunction<ServerResponse> mcpRouterFunction(WebMvcSseServerTransportProvider transportProvider) {
        return transportProvider.getRouterFunction();
    }
}
```

----------------------------------------

TITLE: Implement FastMCP Tool Execution Handlers in Python
DESCRIPTION: This snippet implements the core logic for two FastMCP tools: `get_alerts` and `get_forecast`. `get_alerts` fetches active weather alerts for a specified US state by querying the NWS API and formats them using the `format_alert` helper. `get_forecast` retrieves the detailed weather forecast for given latitude and longitude coordinates, making multiple NWS API calls to get grid points and then the forecast, finally formatting the periods into a readable output.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: python
CODE:
```
@mcp.tool()
async def get_alerts(state: str) -> str:
    """Get weather alerts for a US state.

    Args:
        state: Two-letter US state code (e.g. CA, NY)
    """
    url = f"{NWS_API_BASE}/alerts/active/area/{state}"
    data = await make_nws_request(url)

    if not data or "features" not in data:
        return "Unable to fetch alerts or no alerts found."

    if not data["features"]:
        return "No active alerts for this state."

    alerts = [format_alert(feature) for feature in data["features"]]
    return "\n---\n".join(alerts)

@mcp.tool()
async def get_forecast(latitude: float, longitude: float) -> str:
    """Get weather forecast for a location.

    Args:
        latitude: Latitude of the location
        longitude: Longitude of the location
    """
    # First get the forecast grid endpoint
    points_url = f"{NWS_API_BASE}/points/{latitude},{longitude}"
    points_data = await make_nws_request(points_url)

    if not points_data:
        return "Unable to fetch forecast data for this location."

    # Get the forecast URL from the points response
    forecast_url = points_data["properties"]["forecast"]
    forecast_data = await make_nws_request(forecast_url)

    if not forecast_data:
        return "Unable to fetch detailed forecast."

    # Format the periods into a readable forecast
    periods = forecast_data["properties"]["periods"]
    forecasts = []
    for period in periods[:5]:  # Only show next 5 periods
        forecast = f"""
{period['name']}:
Temperature: {period['temperature']}°{period['temperatureUnit']}
Wind: {period['windSpeed']} {period['windDirection']}
Forecast: {period['detailedForecast']}
"""
        forecasts.append(forecast)

    return "\n---\n".join(forecasts)
```

----------------------------------------

TITLE: Sending JSON-RPC Messages to MCP Server via HTTP POST
DESCRIPTION: Defines the requirements for clients sending JSON-RPC requests, notifications, or responses to the Model Context Protocol (MCP) server using HTTP POST. It specifies header requirements, body formats, and server responses for different message types, including the initiation of Server-Sent Events (SSE) streams.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/basic/transports

LANGUAGE: APIDOC
CODE:
```
Client to Server Communication (HTTP POST):
- Endpoint: MCP endpoint
- Method: HTTP POST
- Headers:
    - Accept: "application/json", "text/event-stream"
- Request Body:
    - A single JSON-RPC request, notification, or response
    - An array batching one or more requests and/or notifications
    - An array batching one or more responses
- Server Responses (based on input):
    - If input consists solely of JSON-RPC responses or notifications:
        - Success: HTTP 202 Accepted (no body)
        - Failure: HTTP error status (e.g., 400 Bad Request), optional JSON-RPC error response (no id)
    - If input contains any JSON-RPC requests:
        - Content-Type: "text/event-stream" (initiates SSE stream)
        - Content-Type: "application/json" (returns one JSON object)
- SSE Stream Behavior (if initiated by server):
    - Should eventually include one JSON-RPC response per each JSON-RPC request sent in POST body
    - May send JSON-RPC requests and notifications before responses (should relate to originating client request)
    - Should NOT close the SSE stream before sending all responses, unless session expires
    - Should close the SSE stream after all JSON-RPC responses have been sent
    - Disconnection:
        - Should NOT be interpreted as client cancelling its request
        - To cancel, client should explicitly send an MCP CancelledNotification
        - Server may make the stream resumable to avoid message loss
```

----------------------------------------

TITLE: JSON-RPC Request for Tool Invocation
DESCRIPTION: Clients send this JSON-RPC request to invoke a specific tool, providing its name and any required arguments. The 'id' field is used to correlate the request with its corresponding response.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/tools

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "tools/call",
  "params": {
    "name": "get_weather",
    "arguments": {
      "location": "New York"
    }
  }
}
```

----------------------------------------

TITLE: Importing Packages and Initializing McpServer Instance
DESCRIPTION: This snippet demonstrates how to import necessary packages like `@modelcontextprotocol/sdk` and `zod`, define constants for the NWS API base URL and user agent, and initialize an `McpServer` instance with basic capabilities for a weather application.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: typescript
CODE:
```
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";

const NWS_API_BASE = "https://api.weather.gov";
const USER_AGENT = "weather-app/1.0";

// Create server instance
const server = new McpServer({
  name: "weather",
  version: "1.0.0",
  capabilities: {
    resources: {},
    tools: {},
  },
});
```

----------------------------------------

TITLE: Define Data Processing Tool Schema (CSV Analysis)
DESCRIPTION: This JSON schema defines an 'analyze_csv' tool for data processing, specifying 'filepath' and 'operations' (with enum values like "sum", "average", "count") as input properties.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/tools

LANGUAGE: JSON
CODE:
```
{
  "name": "analyze_csv",
  "description": "Analyze a CSV file",
  "inputSchema": {
    "type": "object",
    "properties": {
      "filepath": { "type": "string" },
      "operations": {
        "type": "array",
        "items": {
          "enum": ["sum", "average", "count"]
        }
      }
    }
  }
}
```

----------------------------------------

TITLE: MCP Streamable HTTP Transport Mechanism
DESCRIPTION: Explains the HTTP-based transport, where the server operates independently and handles multiple client connections using HTTP POST and GET requests. It also covers the optional use of Server-Sent Events (SSE) for streaming.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/basic/transports

LANGUAGE: APIDOC
CODE:
```
Streamable HTTP Transport:
  Description: Server operates as an independent process, handling multiple client connections using HTTP POST and GET requests.
  Features:
    - Replaces HTTP+SSE transport from protocol version 2024-11-05.
    - Server can optionally use Server-Sent Events (SSE) for streaming multiple server messages.
    - Supports basic MCP servers and feature-rich servers with streaming/notifications.
  Endpoint:
    - Server MUST provide a single HTTP endpoint path (MCP endpoint).
    - Supports both POST and GET methods.
    - Example URL: https://example.com/mcp
```

----------------------------------------

TITLE: Model Context Protocol CompleteRequest Data Type
DESCRIPTION: Defines the structure of the `CompleteRequest` object, including references, arguments, and context information for completion requests.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/utilities/completion

LANGUAGE: APIDOC
CODE:
```
CompleteRequest:
  ref: PromptReference or ResourceReference
  argument:
    name: Argument name
    value: Current value
  context:
    arguments: Mapping of already-resolved argument names to their values
```

----------------------------------------

TITLE: Request to Get a Specific Prompt
DESCRIPTION: Clients send a `prompts/get` request to retrieve a specific prompt by its name. Arguments for the prompt can be provided within the `params` field, such as code for a code review prompt, which may be auto-completed via the completion API.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/prompts

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "prompts/get",
  "params": {
    "name": "code_review",
    "arguments": {
      "code": "def hello():\n    print('world')"
    }
  }
}
```

----------------------------------------

TITLE: Tool Result Embedded Resource Content Format
DESCRIPTION: JSON structure for embedding a resource directly within a tool result. It includes the resource's URI, title, MIME type, and its actual content, allowing for immediate data access.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/tools

LANGUAGE: json
CODE:
```
{
  "type": "resource",
  "resource": {
    "uri": "file:///project/src/main.rs",
    "title": "Project Rust Main File",
    "mimeType": "text/x-rust",
    "text": "fn main() {\n    println!(\"Hello world!\");\n}"
  }
}
```

----------------------------------------

TITLE: JSON Structure for Embedded Resources in Prompt Messages
DESCRIPTION: This defines how server-side resources can be referenced directly within messages. Resources can contain text or binary data, requiring a URI, MIME type, and content, allowing seamless incorporation of server-managed content.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/prompts

LANGUAGE: JSON
CODE:
```
{
  "type": "resource",
  "resource": {
    "uri": "resource://example",
    "mimeType": "text/plain",
    "text": "Resource content"
  }
}
```

----------------------------------------

TITLE: List Resource Templates Response
DESCRIPTION: The server's response to a `resources/templates/list` request, providing a list of available resource templates, each with a URI template, name, description, and MIME type.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/resources

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 3,
  "result": {
    "resourceTemplates": [
      {
        "uriTemplate": "file:///{path}",
        "name": "Project Files",
        "description": "Access files in the project directory",
        "mimeType": "application/octet-stream"
      }
    ]
  }
}
```

----------------------------------------

TITLE: Protocol Operation Phase Guidelines
DESCRIPTION: Outlines the general rules for client-server message exchange during the operational phase, emphasizing adherence to negotiated protocol versions and capabilities.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/basic/lifecycle

LANGUAGE: APIDOC
CODE:
```
Operation Phase Guidelines:
  Both parties SHOULD:
    - Respect the negotiated protocol version.
    - Only use capabilities that were successfully negotiated.
```

----------------------------------------

TITLE: Sending Progress Notifications
DESCRIPTION: The receiver may send progress notifications containing the original progress token, the current progress value, and an optional total value. The 'progress' value must increase with each notification, even if the total is unknown. Both 'progress' and 'total' may be floating point.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/basic/utilities/progress

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "method": "notifications/progress",
  "params": {
    "progressToken": "abc123",
    "progress": 50,
    "total": 100
  }
}
```

----------------------------------------

TITLE: Requesting Autocompletion with MCP Client (Asynchronous Java)
DESCRIPTION: Illustrates how to make an asynchronous autocompletion request using the Model Context Protocol (MCP) client in Java. It constructs a CompleteRequest for a 'code_review' prompt with 'language' as 'py', and then invokes completeCompletion on an asynchronous client, returning a Mono<CompleteResult>.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-client

LANGUAGE: java
CODE:
```
CompleteRequest request = new CompleteRequest(
        new PromptReference("code_review"),
        new CompleteRequest.CompleteArgument("language", "py"));

Mono<CompleteResult> result = mcpClient.completeCompletion(request);
```

----------------------------------------

TITLE: MCP: Protocol Versioning with MCP-Protocol-Version Header
DESCRIPTION: Explains the use of the 'MCP-Protocol-Version' HTTP header for clients to indicate the MCP protocol version to the server. It specifies the format, negotiation, and server fallback behavior for identifying the protocol version.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/basic/transports

LANGUAGE: APIDOC
CODE:
```
MCP Protocol Versioning:
  1. Client Request Header:
     - Client MUST include 'MCP-Protocol-Version: <protocol-version>' HTTP header on all subsequent requests.
     - Example: 'MCP-Protocol-Version: 2025-03-26'
     - Protocol version SHOULD be the one negotiated during initialization.
  2. Server Fallback Behavior:
     - If server does NOT receive 'MCP-Protocol-Version' header and has no other way to identify version, it SHOULD assume '2025-03-26'.
  3. Invalid Version Handling:
     - If server receives request with invalid or unsupported 'MCP-Protocol-Version', it MUST respond with '400 Bad Request'.
```

----------------------------------------

TITLE: Binary Resource Content Data Type Example
DESCRIPTION: An example structure for resource content when the content is binary. It includes the resource's URI, name, title, MIME type, and the binary data encoded as a base64 string.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/resources

LANGUAGE: JSON
CODE:
```
{
  "uri": "file:///example.png",
  "name": "example.png",
  "title": "Example Image",
  "mimeType": "image/png",
  "blob": "base64-encoded-data"
}
```

----------------------------------------

TITLE: Model Context Protocol SDK Available Dependencies
DESCRIPTION: This section lists the core, optional transport, and testing dependencies managed by the Model Context Protocol SDK Bill of Materials (BOM), along with their brief descriptions.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-overview

LANGUAGE: APIDOC
CODE:
```
Core Dependencies:
  io.modelcontextprotocol.sdk:mcp - Core MCP library providing base functionality and APIs, including default STDIO and SSE client/server transport implementations. No external web frameworks required.

Optional Transport Dependencies (convenience if using Spring Framework):
  io.modelcontextprotocol.sdk:mcp-spring-webflux - WebFlux-based Server-Sent Events (SSE) transport implementation for reactive applications.
  io.modelcontextprotocol.sdk:mcp-spring-webmvc - WebMVC-based Server-Sent Events (SSE) transport implementation for servlet-based applications.

Testing Dependencies:
  io.modelcontextprotocol.sdk:mcp-test - Testing utilities and support for MCP-based applications.
```

----------------------------------------

TITLE: JSON-RPC Example of a Tool Execution Error
DESCRIPTION: This example illustrates how tool execution errors, such as API failures or business logic errors, are reported within a tool result. The 'isError' flag is set to true, and the 'content' array provides details about the failure.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/tools

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 4,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "Failed to fetch weather data: API rate limit exceeded"
      }
    ],
    "isError": true
  }
}
```

----------------------------------------

TITLE: Add Anthropic API Key to .env
DESCRIPTION: Example of how to add your Anthropic API key to the '.env' file. Replace '<your key here>' with your actual key.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: plaintext
CODE:
```
ANTHROPIC_API_KEY=<your key here>
```

----------------------------------------

TITLE: Example Valid Response for Tool with Output Schema
DESCRIPTION: This JSON-RPC response demonstrates a valid structured result for the 'get_weather_data' tool. It includes both text content and a 'structuredContent' object that conforms to the tool's defined output schema, providing temperature, conditions, and humidity.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/tools

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 5,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "{\"temperature\": 22.5, \"conditions\": \"Partly cloudy\", \"humidity\": 65}"
      }
    ],
    "structuredContent": {
      "temperature": 22.5,
      "conditions": "Partly cloudy",
      "humidity": 65
    }
  }
}
```

----------------------------------------

TITLE: Configure Spring AI MCP Client Properties
DESCRIPTION: Application properties (application.yml) to enable and configure the Spring AI MCP client, including its name, version, type, request timeout, stdio settings, and enabling the tool callback mechanism. It also configures the Anthropic API key.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: YAML
CODE:
```
spring:
  ai:
    mcp:
      client:
        enabled: true
        name: brave-search-client
        version: 1.0.0
        type: SYNC
        request-timeout: 20s
        stdio:
          root-change-notification: true
          servers-configuration: classpath:/mcp-servers-config.json
        toolcallback:
          enabled: true
    anthropic:
      api-key: ${ANTHROPIC_API_KEY}
```

----------------------------------------

TITLE: List Resource Templates Request
DESCRIPTION: Clients request a list of available resource templates from the server. Resource templates allow servers to expose parameterized resources using URI templates.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/resources

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 3,
  "method": "resources/templates/list"
}
```

----------------------------------------

TITLE: Tool Result Image Content Format
DESCRIPTION: Specifies the JSON structure for an image-based content item within a tool's result, including base64-encoded data and MIME type.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/tools

LANGUAGE: JSON
CODE:
```
{
  "type": "image",
  "data": "base64-encoded-data",
  "mimeType": "image/png"
}
```

----------------------------------------

TITLE: JSON Structure for Image Content in Prompt Messages
DESCRIPTION: This defines the structure for including visual information in prompt messages. Image data must be base64-encoded and include a valid MIME type, enabling multi-modal interactions.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/prompts

LANGUAGE: JSON
CODE:
```
{
  "type": "image",
  "data": "base64-encoded-image-data",
  "mimeType": "image/png"
}
```

----------------------------------------

TITLE: Model Context Protocol JSON-RPC Notification Message
DESCRIPTION: Defines the structure for one-way notification messages sent between Model Context Protocol clients and servers. Notifications do not expect a response and therefore must not include an `id` field.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/basic

LANGUAGE: APIDOC
CODE:
```
{
  jsonrpc: "2.0";
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

----------------------------------------

TITLE: Request Model Context Protocol Completions
DESCRIPTION: Clients request completion suggestions by sending a 'completion/complete' JSON-RPC request. This example demonstrates a request for autocompletion on the 'language' argument within the 'code_review' prompt, with a partial value 'py'.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/utilities/completion

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "completion/complete",
  "params": {
    "ref": {
      "type": "ref/prompt",
      "name": "code_review"
    },
    "argument": {
      "name": "language",
      "value": "py"
    }
  }
}
```

----------------------------------------

TITLE: APIDOC: Model Context Protocol Version Negotiation
DESCRIPTION: Details the process for client and server to negotiate the protocol version during the 'initialize' request, including rules for response and disconnection based on supported versions. Specifies the 'MCP-Protocol-Version' HTTP header for subsequent requests.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/basic/lifecycle

LANGUAGE: APIDOC
CODE:
```
Version Negotiation Process:
  Client MUST send latest supported protocol version in 'initialize' request.
  Server MUST respond with same version if supported, else with latest supported version.
  Client SHOULD disconnect if server's version is unsupported.
  HTTP Requirement: Client MUST include 'MCP-Protocol-Version: <protocol-version>' header on all subsequent requests.
```

----------------------------------------

TITLE: Inspect Servers from NPM or PyPi using MCP Inspector
DESCRIPTION: Illustrates how to use the MCP Inspector to connect to and inspect servers distributed via NPM or PyPi, providing examples for both package types.
SOURCE: https://modelcontextprotocol.io/introduction/docs/tools/inspector

LANGUAGE: Shell
CODE:
```
npx -y @modelcontextprotocol/inspector npx <package-name> <args>
# For example
npx -y @modelcontextprotocol/inspector npx server-postgres postgres://127.0.0.1/testdb
```

LANGUAGE: Shell
CODE:
```
npx @modelcontextprotocol/inspector uvx <package-name> <args>
# For example
npx @modelcontextprotocol/inspector uvx mcp-server-git --repository ~/code/mcp/servers.git
```

----------------------------------------

TITLE: Model Context Protocol Completion Results Structure
DESCRIPTION: Servers return completion results as an array of values, ranked by relevance. Responses are limited to a maximum of 100 items per response, can include an optional total number of available matches, and a boolean indicating if additional results exist.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/utilities/completion

LANGUAGE: APIDOC
CODE:
```
Completion Results Structure:
- Maximum 100 items per response
- Optional total number of available matches
- Boolean indicating if additional results exist
```

----------------------------------------

TITLE: Notify of Model Context Protocol Root List Changes
DESCRIPTION: Clients that support the 'listChanged' capability must send this 'notifications/roots/list_changed' notification when the list of exposed roots changes.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/client

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "method": "notifications/roots/list_changed"
}
```

----------------------------------------

TITLE: Notification for Prompt List Changes
DESCRIPTION: Servers that declare the `listChanged` capability should send this notification (`notifications/prompts/list_changed`) to clients when the list of available prompts changes. This informs clients to update their local prompt lists.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/prompts

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "method": "notifications/prompts/list_changed"
}
```

----------------------------------------

TITLE: Implement Model Context Protocol Layer
DESCRIPTION: The Protocol layer handles message framing, request/response linking, and high-level communication patterns within the Model Context Protocol. It provides methods for setting handlers for incoming requests and notifications, and for sending outgoing requests and one-way notifications. This layer is fundamental for communication between MCP clients and servers.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/architecture

LANGUAGE: TypeScript
CODE:
```
class Protocol<Request, Notification, Result> {
    // Handle incoming requests
    setRequestHandler<T>(schema: T, handler: (request: T, extra: RequestHandlerExtra) => Promise<Result>): void

    // Handle incoming notifications
    setNotificationHandler<T>(schema: T, handler: (notification: T) => Promise<void>): void

    // Send requests and await responses
    request<T>(request: Request, schema: T, options?: RequestOptions): Promise<T>

    // Send one-way notifications
    notification(notification: Notification): Promise<void>
}
```

LANGUAGE: Python
CODE:
```
class Session(BaseSession[RequestT, NotificationT, ResultT]):
    async def send_request(
        self,
        request: RequestT,
        result_type: type[Result]
    ) -> Result:
        """Send request and wait for response. Raises McpError if response contains error."""
        # Request handling implementation

    async def send_notification(
        self,
        notification: NotificationT
    ) -> None:
        """Send one-way notification that doesn't expect response."""
        # Notification handling implementation

    async def _received_request(
        self,
        responder: RequestResponder[ReceiveRequestT, ResultT]
    ) -> None:
        """Handle incoming request from other side."""
        # Request handling implementation

    async def _received_notification(
        self,
        notification: ReceiveNotificationT
    ) -> None:
        """Handle incoming notification from other side."""
        # Notification handling implementation
}
```

----------------------------------------

TITLE: Initialize .NET Project and Add Dependencies
DESCRIPTION: These commands guide the user through setting up a new .NET console project and adding necessary NuGet packages for the Model Context Protocol client, including `ModelContextProtocol`, `Anthropic.SDK`, `Microsoft.Extensions.Hosting`, and `Microsoft.Extensions.AI`. This prepares the project for development.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: shell
CODE:
```
dotnet new console -n QuickstartClient
cd QuickstartClient
```

LANGUAGE: shell
CODE:
```
dotnet add package ModelContextProtocol --prerelease
dotnet add package Anthropic.SDK
dotnet add package Microsoft.Extensions.Hosting
dotnet add package Microsoft.Extensions.AI
```

----------------------------------------

TITLE: API Definition: Image Content Type for Messages
DESCRIPTION: Allows including visual information in messages. The image data must be base64-encoded and include a valid MIME type, enabling multi-modal interactions where visual context is important.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/prompts

LANGUAGE: APIDOC
CODE:
```
Image Content:
  type: "image"
  data: "base64-encoded-image-data"
  mimeType: "image/png"
```

LANGUAGE: JSON
CODE:
```
{
  "type": "image",
  "data": "base64-encoded-image-data",
  "mimeType": "image/png"
}
```

----------------------------------------

TITLE: Initialize FastMCP Server and Constants in Python
DESCRIPTION: This snippet demonstrates the initial setup for a FastMCP server. It imports necessary Python packages like `typing`, `httpx`, and `FastMCP`, then initializes the `FastMCP` instance for a 'weather' application. Additionally, it defines global constants for the National Weather Service (NWS) API base URL and a user agent string, essential for subsequent API interactions.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: python
CODE:
```
from typing import Any
import httpx
from mcp.server.fastmcp import FastMCP

# Initialize FastMCP server
mcp = FastMCP("weather")

# Constants
NWS_API_BASE = "https://api.weather.gov"
USER_AGENT = "weather-app/1.0"
```

----------------------------------------

TITLE: APIDOC: PromptMessage Data Type Definition
DESCRIPTION: Defines the structure of individual messages within a prompt. Each message specifies the speaker's role ('user' or 'assistant') and contains content, which can be of various types like text, image, audio, or embedded resources.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/prompts

LANGUAGE: APIDOC
CODE:
```
PromptMessage:
  role: string
    Either "user" or "assistant" to indicate the speaker.
  content: object
    One of the following content types: Text, Image, Audio, Resource.
```

----------------------------------------

TITLE: Handle Tool Errors in MCP
DESCRIPTION: Demonstrates how to properly report errors within the result object for Model Context Protocol (MCP) tools, allowing the LLM to process them. Errors are indicated by setting `isError` to `true` and including details in the `content` array, rather than using protocol-level errors.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/tools

LANGUAGE: TypeScript
CODE:
```
try {
  // Tool operation
  const result = performOperation();
  return {
    content: [
      {
        type: "text",
        text: `Operation successful: ${result}`
      }
    ]
  };
} catch (error) {
  return {
    isError: true,
    content: [
      {
        type: "text",
        text: `Error: ${error.message}`
      }
    ]
  };
}
```

LANGUAGE: Python
CODE:
```
try:
    # Tool operation
    result = perform_operation()
    return types.CallToolResult(
        content=[
            types.TextContent(
                type="text",
                text=f"Operation successful: {result}"
            )
        ]
    )
except Exception as error:
    return types.CallToolResult(
        isError=True,
        content=[
            types.TextContent(
                type="text",
                text=f"Error: {str(error)}"
            )
        ]
    )
```

----------------------------------------

TITLE: Declare Client Roots Capability
DESCRIPTION: Clients supporting the 'roots' feature must declare this capability during initialization. The 'listChanged' property indicates whether the client will emit notifications when the list of roots changes.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/client/roots

LANGUAGE: JSON
CODE:
```
{
  "capabilities": {
    "roots": {
      "listChanged": true
    }
  }
}
```

----------------------------------------

TITLE: API Definition: Prompt Data Type
DESCRIPTION: Defines the structure of a prompt, including its unique identifier (`name`), an optional human-readable description, and an optional list of arguments for customization.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/prompts

LANGUAGE: APIDOC
CODE:
```
Prompt:
  name: Unique identifier for the prompt
  description: Optional human-readable description
  arguments: Optional list of arguments for customization
```

----------------------------------------

TITLE: APIDOC: PromptMessage Data Type Definition
DESCRIPTION: Defines the structure of messages within a prompt, specifying the speaker's role and the content type, which can be text, image, or embedded resource.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/prompts

LANGUAGE: APIDOC
CODE:
```
PromptMessage:
  role: "user" | "assistant" - Indicates the speaker
  content: TextContent | ImageContent | EmbeddedResource - One of the following content types
```

----------------------------------------

TITLE: Check Claude's Logs for Errors
DESCRIPTION: Provides a shell command to view the last 20 lines of Claude's Model Context Protocol (MCP) logs in real-time, which is useful for identifying errors and debugging issues related to server communication or tool calls.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: Shell
CODE:
```
tail -n 20 -f ~/Library/Logs/Claude/mcp*.log
```

----------------------------------------

TITLE: MCP Streamable HTTP Transport Specification
DESCRIPTION: Describes the Model Context Protocol's HTTP-based transport, replacing the older HTTP+SSE. The server operates independently, handling multiple client connections via HTTP POST and GET requests. Optionally uses Server-Sent Events (SSE) for streaming and server-to-client notifications, requiring a single MCP endpoint supporting both methods.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/basic/transports

LANGUAGE: APIDOC
CODE:
```
Streamable HTTP Transport:
  Mechanism: Server operates as an independent process that can handle multiple client connections.
  Replaces: HTTP+SSE transport from protocol version 2024-11-05.
  Requests: Uses HTTP POST and GET requests.
  Streaming:
    - Server can optionally make use of Server-Sent Events (SSE) to stream multiple server messages.
    - Permits basic MCP servers, as well as more feature-rich servers supporting streaming and server-to-client notifications and requests.
  Endpoint:
    - Server MUST provide a single HTTP endpoint path (MCP endpoint).
    - MCP endpoint MUST support both POST and GET methods.
    - Example: https://example.com/mcp
```

----------------------------------------

TITLE: MCP Pagination Response Format
DESCRIPTION: This JSON snippet illustrates the server's response format for paginated list operations. It includes the current page of results and an optional `nextCursor` field, which indicates if more results are available and provides the token for the next page.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/utilities/pagination

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "id": "123",
  "result": {
    "resources": [...],
    "nextCursor": "eyJwYWdlIjogM30="
  }
}
```

----------------------------------------

TITLE: Declare Server Tools Capability in MCP
DESCRIPTION: Servers supporting tools in the Model Context Protocol must declare the 'tools' capability within their capabilities object. The 'listChanged' property indicates whether the server will emit notifications when the list of available tools changes, allowing clients to stay updated.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/tools

LANGUAGE: JSON
CODE:
```
{
  "capabilities": {
    "tools": {
      "listChanged": true
    }
  }
}
```

----------------------------------------

TITLE: Resource Updated Notification
DESCRIPTION: Servers send this notification to clients that have subscribed to a resource when its content or metadata has been updated, indicating the URI of the changed resource.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/resources

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "method": "notifications/resources/updated",
  "params": {
    "uri": "file:///project/src/main.rs"
  }
}
```

----------------------------------------

TITLE: Declare Prompts Capability in Server Initialization
DESCRIPTION: Servers that support prompts must declare the 'prompts' capability during initialization. The 'listChanged' flag indicates whether the server will emit notifications when the list of available prompts changes.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/prompts

LANGUAGE: JSON
CODE:
```
{
  "capabilities": {
    "prompts": {
      "listChanged": true
    }
  }
}
```

----------------------------------------

TITLE: Tools List Changed Notification JSON-RPC
DESCRIPTION: JSON-RPC notification sent by servers to clients when the list of available tools changes. This notification is sent by servers that declare the 'listChanged' capability.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/tools

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "method": "notifications/tools/list_changed"
}
```

----------------------------------------

TITLE: Subscribe to Resource Changes Request
DESCRIPTION: Clients send a `resources/subscribe` request to subscribe to changes for a specific resource, identified by its URI. This enables receiving notifications when the resource is updated.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/resources

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 4,
  "method": "resources/subscribe",
  "params": {
    "uri": "file:///project/src/main.rs"
  }
}
```

----------------------------------------

TITLE: Configure MCP Client with Spring Boot Starter
DESCRIPTION: Shows how to add the `spring-ai-starter-mcp-client` dependency to a Spring Boot application's build file and configure the `spring.ai.mcp.client.stdio.servers-configuration` property to automatically create MCP clients from a specified JSON configuration file.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: XML
CODE:
```
<dependency>
    <groupId>org.springframework.ai</groupId>
    <artifactId>spring-ai-starter-mcp-client</artifactId>
</dependency>
```

LANGUAGE: Properties
CODE:
```
spring.ai.mcp.client.stdio.servers-configuration=file:PATH/TO/claude_desktop_config.json
```

----------------------------------------

TITLE: Server `initialize` Response for MCP
DESCRIPTION: The server responds to the client's `initialize` request, confirming protocol version compatibility and providing its own capabilities and server implementation information. This completes the capability negotiation phase.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/basic/lifecycle

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "protocolVersion": "2024-11-05",
    "capabilities": {
      "logging": {},
      "prompts": {
        "listChanged": true
      },
      "resources": {
        "subscribe": true,
        "listChanged": true
      },
      "tools": {
        "listChanged": true
      }
    },
    "serverInfo": {
      "name": "ExampleServer",
      "version": "1.0.0"
    }
  }
}
```

----------------------------------------

TITLE: JSON-RPC Response for Successful Tool Invocation
DESCRIPTION: This JSON-RPC response indicates the successful execution of a tool, returning the tool's output content as an array of content items and an 'isError' flag set to false. The 'id' matches the original request.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/tools

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "Current weather in New York:\nTemperature: 72°F\nConditions: Partly cloudy"
      }
    ],
    "isError": false
  }
}
```

----------------------------------------

TITLE: Implement Get Prompt Logic for Model Context Protocol in Python
DESCRIPTION: This Python code defines the `get_prompt` asynchronous function, decorated with `@app.get_prompt()`, which handles requests for specific prompts. It validates the prompt name, extracts arguments, and constructs `PromptMessage` objects based on the requested prompt ('git-commit' or 'explain-code'), returning a `types.GetPromptResult`.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/prompts

LANGUAGE: Python
CODE:
```
@app.get_prompt()
async def get_prompt(
    name: str, arguments: dict[str, str] | None = None
) -> types.GetPromptResult:
    if name not in PROMPTS:
        raise ValueError(f"Prompt not found: {name}")

    if name == "git-commit":
        changes = arguments.get("changes") if arguments else ""
        return types.GetPromptResult(
            messages=[
                types.PromptMessage(
                    role="user",
                    content=types.TextContent(
                        type="text",
                        text=f"Generate a concise but descriptive commit message "
                        f"for these changes:\n\n{changes}"
                    )
                )
            ]
        )

    if name == "explain-code":
        code = arguments.get("code") if arguments else ""
        language = arguments.get("language", "Unknown") if arguments else "Unknown"
        return types.GetPromptResult(
            messages=[
                types.PromptMessage(
                    role="user",
                    content=types.TextContent(
                        type="text",
                        text=f"Explain how this {language} code works:\n\n{code}"
                    )
                )
            ]
        )

    raise ValueError("Prompt implementation not found")
```

----------------------------------------

TITLE: Using a Specific Prompt via prompts/get
DESCRIPTION: Demonstrates how clients can use a specific prompt by sending a 'prompts/get' request. The request includes the prompt's name and any necessary arguments. The response provides the prompt's description and a list of messages, typically containing the content to be sent to an LLM.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/prompts

LANGUAGE: JSON
CODE:
```
// Request
{
  "method": "prompts/get",
  "params": {
    "name": "analyze-code",
    "arguments": {
      "language": "python"
    }
  }
}

// Response
{
  "description": "Analyze Python code for potential improvements",
  "messages": [
    {
      "role": "user",
      "content": {
        "type": "text",
        "text": "Please analyze the following Python code for potential improvements:\n\n```python\ndef calculate_sum(numbers):\n    total = 0\n    for num in numbers:\n        total = total + num\n    return total\n\nresult = calculate_sum([1, 2, 3, 4, 5])\nprint(result)\n```"
      }
    }
  ]
}
```

----------------------------------------

TITLE: API Definition: Audio Content Type for Messages
DESCRIPTION: Allows including audio information in messages. The audio data must be base64-encoded and include a valid MIME type, enabling multi-modal interactions where audio context is important.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/prompts

LANGUAGE: APIDOC
CODE:
```
Audio Content:
  type: "audio"
  data: "base64-encoded-audio-data"
  mimeType: "audio/wav"
```

LANGUAGE: JSON
CODE:
```
{
  "type": "audio",
  "data": "base64-encoded-audio-data",
  "mimeType": "audio/wav"
}
```

----------------------------------------

TITLE: HTTP Authorization Header Format for MCP Requests
DESCRIPTION: Defines the mandatory format for the Authorization request header field, using a Bearer token, which MCP clients must include in every HTTP request to MCP servers as per OAuth 2.1 Section 5.1.1.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/basic/authorization

LANGUAGE: HTTP
CODE:
```
Authorization: Bearer <access-token>
```

----------------------------------------

TITLE: Example HTTP GET Request to MCP Server with Bearer Token
DESCRIPTION: Illustrates a complete HTTP GET request to an MCP server, showing the inclusion of the Host header and the Authorization header with a sample Bearer token, demonstrating proper client-server communication.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/basic/authorization

LANGUAGE: HTTP
CODE:
```
GET /mcp HTTP/1.1
Host: mcp.example.com
Authorization: Bearer eyJhbGciOiJIUzI1NiIs...
```

----------------------------------------

TITLE: Model Context Protocol Direct Resource Schema
DESCRIPTION: Describes the JSON structure for individual resources exposed via the 'resources/list' endpoint. Each resource includes a unique identifier, a human-readable name, and optional metadata such as a description, MIME type, and size in bytes.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/resources

LANGUAGE: APIDOC
CODE:
```
{
  uri: string;           // Unique identifier for the resource
  name: string;          // Human-readable name
  description?: string;  // Optional description
  mimeType?: string;     // Optional MIME type
  size?: number;         // Optional size in bytes
}
```

----------------------------------------

TITLE: Read Resource Response
DESCRIPTION: The server's response to a `resources/read` request, containing the contents of the requested resource, including its URI, MIME type, and text content.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/resources

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "contents": [
      {
        "uri": "file:///project/src/main.rs",
        "mimeType": "text/x-rust",
        "text": "fn main() {\n    println!(\"Hello world!\");\n}"
      }
    ]
  }
}
```

----------------------------------------

TITLE: Client-Side Configuration for Receiving Server Log Messages
DESCRIPTION: This Java code illustrates how to initialize an `McpClient` to receive structured log messages from the server. It registers a `loggingConsumer` to process incoming notifications and sets the minimum logging level to `INFO`, ensuring only messages of INFO severity or higher are received.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-server

LANGUAGE: Java
CODE:
```
var mcpClient = McpClient.sync(transport)
        .loggingConsumer(notification -> {
            System.out.println("Received log message: " + notification.data());
        })
        .build();

mcpClient.initialize();

mcpClient.setLoggingLevel(McpSchema.LoggingLevel.INFO);

// Call the tool that sends logging notifications
CallToolResult result = mcpClient.callTool(new McpSchema.CallToolRequest("logging-test", Map.of()));
```

----------------------------------------

TITLE: Receive Log Message Notification in Model Context Protocol (JSON-RPC)
DESCRIPTION: Servers send structured log messages to clients using 'notifications/message' JSON-RPC notifications. This example illustrates an error-level log message originating from a 'database' logger, including detailed, arbitrary JSON-serializable data about a connection failure.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/utilities/logging

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "method": "notifications/message",
  "params": {
    "level": "error",
    "logger": "database",
    "data": {
      "error": "Connection failed",
      "details": {
        "host": "localhost",
        "port": 5432
      }
    }
  }
}
```

----------------------------------------

TITLE: Create STDIO Server Transport Provider (Java)
DESCRIPTION: This snippet demonstrates how to create an in-process `StdioServerTransportProvider`. It enables bidirectional JSON-RPC message handling over standard input/output streams, offering non-blocking processing and graceful shutdown for simple, lightweight process-based integration.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-server

LANGUAGE: Java
CODE:
```
StdioServerTransportProvider transportProvider = new StdioServerTransportProvider(new ObjectMapper());
```

----------------------------------------

TITLE: API: LLM Client Completion Response Format
DESCRIPTION: Defines the structure of the completion result returned by the LLM client, including the model name, an optional stop reason, the role of the content, and the content itself which can be text or image data.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/sampling

LANGUAGE: APIDOC
CODE:
```
{
  model: string,  // Name of the model used
  stopReason?: "endTurn" | "stopSequence" | "maxTokens" | string,
  role: "user" | "assistant",
  content: {
    type: "text" | "image",
    text?: string,
    data?: string,
    mimeType?: string
  }
}
```

----------------------------------------

TITLE: Model Context Protocol `CompleteRequest` Data Type Definition
DESCRIPTION: The `CompleteRequest` data type defines the structure for requesting completions. It includes a `ref` field, which can be a `PromptReference` or `ResourceReference`, and an `argument` object specifying the argument's name and current value.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/utilities/completion

LANGUAGE: APIDOC
CODE:
```
CompleteRequest:
  ref: A PromptReference or ResourceReference
  argument: Object containing:
    name: Argument name
    value: Current value
```

----------------------------------------

TITLE: Create WebFlux SSE Client Transport
DESCRIPTION: Sets up a WebFlux-based SSE client transport for MCP, requiring the mcp-webflux-sse-transport dependency and using a WebClient.Builder to configure the base URL.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-client

LANGUAGE: Java
CODE:
```
WebClient.Builder webClientBuilder = WebClient.builder()
    .baseUrl("http://your-mcp-server");
McpTransport transport = new WebFluxSseClientTransport(webClientBuilder);
```

----------------------------------------

TITLE: Set Up Python Project Environment on MacOS/Linux
DESCRIPTION: These commands initialize a new `uv` project named 'weather', create and activate a virtual environment, install necessary dependencies (`mcp[cli]` and `httpx`), and create the main server file `weather.py` on MacOS/Linux systems.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: Shell
CODE:
```
# Create a new directory for our project
uv init weather
cd weather

# Create virtual environment and activate it
uv venv
source .venv/bin/activate

# Install dependencies
uv add "mcp[cli]" httpx

# Create our server file
touch weather.py
```

----------------------------------------

TITLE: Implement Async Server with AI Sampling Tool in Java
DESCRIPTION: This Java code illustrates how to configure an asynchronous MCP server and define a tool that utilizes client-side AI sampling. Similar to the synchronous version, it verifies client sampling support and builds a CreateMessageRequest with specific model preferences. However, it uses Mono.just for reactive programming, indicating non-blocking operations suitable for asynchronous environments. The snippet is truncated but shows the setup for an async tool.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-server

LANGUAGE: Java
CODE:
```
// Create a server
McpAsyncServer server = McpServer.async(transportProvider)
    .serverInfo("my-server", "1.0.0")
    .build();

// Define a tool that uses sampling
var calculatorTool = new McpServerFeatures.AsyncToolSpecification(
    new Tool("ai-calculator", "Performs calculations using AI", schema),
    (exchange, arguments) -> {
        // Check if client supports sampling
        if (exchange.getClientCapabilities().sampling() == null) {
            return Mono.just(new CallToolResult("Client does not support AI capabilities", false));
        }

        // Create a sampling request
        McpSchema.CreateMessageRequest request = McpSchema.CreateMessageRequest.builder()
            .content(new McpSchema.TextContent("Calculate: " + arguments.get("expression")))
            .modelPreferences(McpSchema.ModelPreferences.builder()
                .hints(List.of(
                    McpSchema.ModelHint.of("claude-3-sonnet"),
                    McpSchema.ModelHint.of("claude")
                ))

```

----------------------------------------

TITLE: Execute Tools Synchronously with MCP Client (Java)
DESCRIPTION: Demonstrates how to list available server-side tools and execute a specific tool with parameters using the synchronous API of the Model Context Protocol (MCP) client. Tools are server-side functions that accept a map of parameters and return a result.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-client

LANGUAGE: Java
CODE:
```
// List available tools and their names
var tools = client.listTools();
tools.forEach(tool -> System.out.println(tool.getName()));

// Execute a tool with parameters
var result = client.callTool("calculator", Map.of(
    "operation", "add",
    "a", 1,
    "b", 2
));
```

----------------------------------------

TITLE: Receive Log Message (notifications/message) Notification
DESCRIPTION: Servers send log messages to clients using 'notifications/message' notifications. Each notification includes a severity level, an optional logger name, and arbitrary JSON-serializable data providing details about the event.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/utilities/logging

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "method": "notifications/message",
  "params": {
    "level": "error",
    "logger": "database",
    "data": {
      "error": "Connection failed",
      "details": {
        "host": "localhost",
        "port": 5432
      }
    }
  }
}
```

----------------------------------------

TITLE: Declare Logging Capability in Model Context Protocol
DESCRIPTION: Servers that emit log message notifications must declare the 'logging' capability within their capabilities object. This JSON snippet shows the required structure for declaring this capability, indicating the server's support for sending log messages.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/utilities/logging

LANGUAGE: JSON
CODE:
```
{
  "capabilities": {
    "logging": {}
  }
}
```

----------------------------------------

TITLE: Request Model Context Protocol Completions for a Prompt Argument
DESCRIPTION: Clients send a 'completion/complete' request to obtain autocompletion suggestions for a specific argument of a prompt or URI template. The request specifies the reference type and the argument being completed, and the response provides a list of suggested values.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/utilities/completion

LANGUAGE: JSON (Request)
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "completion/complete",
  "params": {
    "ref": {
      "type": "ref/prompt",
      "name": "code_review"
    },
    "argument": {
      "name": "language",
      "value": "py"
    }
  }
}
```

LANGUAGE: JSON (Response)
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "completion": {
      "values": ["python", "pytorch", "pyside"],
      "total": 10,
      "hasMore": true
    }
  }
}
```

----------------------------------------

TITLE: Declare Roots Capability in Model Context Protocol Initialization
DESCRIPTION: Clients supporting roots must declare the `roots` capability during initialization. The `listChanged` property indicates whether the client will emit notifications when the list of roots changes.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/client/roots

LANGUAGE: JSON
CODE:
```
{
  "capabilities": {
    "roots": {
      "listChanged": true
    }
  }
}
```

----------------------------------------

TITLE: JSON-RPC Example of a Protocol Error
DESCRIPTION: This example demonstrates a standard JSON-RPC error response for issues like unknown tools or invalid arguments. It includes an error code and a human-readable message to describe the problem.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/tools

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 3,
  "error": {
    "code": -32602,
    "message": "Unknown tool: invalid_tool_name"
  }
}
```

----------------------------------------

TITLE: Declare Model Context Protocol Resources Capability with Full Support
DESCRIPTION: Servers supporting resources in the Model Context Protocol must declare the 'resources' capability. This example shows a declaration where both 'subscribe' and 'listChanged' features are supported, allowing clients to subscribe to resource changes and receive notifications when the list of available resources changes.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/resources

LANGUAGE: JSON
CODE:
```
{
  "capabilities": {
    "resources": {
      "subscribe": true,
      "listChanged": true
    }
  }
}
```

----------------------------------------

TITLE: Send Simple Text Elicitation Request
DESCRIPTION: Servers initiate an elicitation process by sending an 'elicitation/create' request. This example demonstrates a simple request for a user's GitHub username, specifying the prompt message and a JSON schema to validate the expected string input.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client/elicitation

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "elicitation/create",
  "params": {
    "message": "Please provide your GitHub username",
    "requestedSchema": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        }
      },
      "required": ["name"]
    }
  }
}
```

----------------------------------------

TITLE: Add Core MCP SDK Dependency
DESCRIPTION: Add the fundamental Model Context Protocol (MCP) SDK dependency to your project. This module includes default STDIO and SSE transport implementations and does not require external web frameworks.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-overview

LANGUAGE: Maven
CODE:
```
<dependency>
    <groupId>io.modelcontextprotocol.sdk</groupId>
    <artifactId>mcp</artifactId>
</dependency>
```

LANGUAGE: Gradle
CODE:
```
dependencies {
  implementation platform("io.modelcontextprotocol.sdk:mcp")
  //...
}
```

----------------------------------------

TITLE: Set Minimum Log Level in Model Context Protocol (JSON-RPC Request)
DESCRIPTION: Clients can configure the minimum log level they wish to receive by sending a 'logging/setLevel' JSON-RPC request to the server. This example demonstrates how to set the minimum log level to 'info', meaning the client will only receive messages of 'info' severity or higher.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/utilities/logging

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "logging/setLevel",
  "params": {
    "level": "info"
  }
}
```

----------------------------------------

TITLE: Kotlin: Run Model Context Protocol Server
DESCRIPTION: A concise Kotlin `main` function to start the Model Context Protocol (MCP) server. It invokes the `run mcp server()` utility function to initialize and run the server instance.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: kotlin
CODE:
```
fun main() = `run mcp server`()
```

----------------------------------------

TITLE: JSON: Image Content Type for PromptMessage
DESCRIPTION: Allows including visual information in messages. The image data must be base64-encoded and accompanied by a valid MIME type, enabling multi-modal interactions where visual context is important.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/prompts

LANGUAGE: APIDOC
CODE:
```
{
  "type": "image",
  "data": "base64-encoded-image-data",
  "mimeType": "image/png"
}
```

----------------------------------------

TITLE: Inspect Locally Developed Servers with MCP Inspector
DESCRIPTION: Provides commands for using the MCP Inspector to debug servers developed locally, including examples for both Node.js (TypeScript) and Python-based servers.
SOURCE: https://modelcontextprotocol.io/introduction/docs/tools/inspector

LANGUAGE: Shell
CODE:
```
npx @modelcontextprotocol/inspector node path/to/server/index.js args...
```

LANGUAGE: Shell
CODE:
```
npx @modelcontextprotocol/inspector \
  uv \
  --directory path/to/server \
  run \
  package-name \
  args...
```

----------------------------------------

TITLE: JSON-RPC Request to Get a Specific Prompt
DESCRIPTION: Clients send a `prompts/get` request to retrieve a specific prompt. Arguments can be auto-completed via the completion API. This snippet shows an example request for a 'code_review' prompt with embedded code.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/prompts

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "prompts/get",
  "params": {
    "name": "code_review",
    "arguments": {
      "code": "def hello():\n    print('world')"
    }
  }
}
```

----------------------------------------

TITLE: Receive sampling/createMessage Response with LLM Output
DESCRIPTION: Upon processing a `sampling/createMessage` request, the client returns a JSON-RPC response containing the generated content. This example shows an assistant's text response, the model used, and the reason for stopping generation.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/client/sampling

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "role": "assistant",
    "content": {
      "type": "text",
      "text": "The capital of France is Paris."
    },
    "model": "claude-3-sonnet-20240307",
    "stopReason": "endTurn"
  }
}
```

----------------------------------------

TITLE: Send Log Message Notification from MCP Server
DESCRIPTION: Shows how to send a log message notification from an MCP server to the client. This method is applicable across all transports and allows providing structured logging information, such as server initialization status.
SOURCE: https://modelcontextprotocol.io/introduction/docs/tools/debugging

LANGUAGE: Python
CODE:
```
server.request_context.session.send_log_message(
  level="info",
  data="Server started successfully",
)
```

LANGUAGE: TypeScript
CODE:
```
server.sendLoggingMessage({
  level: "info",
  data: "Server started successfully"
});
```

----------------------------------------

TITLE: Example Model Context Protocol Roots for Multiple Repositories
DESCRIPTION: This example illustrates how multiple 'Root' objects can be provided to represent distinct repositories or directories. Each root has its own file URI and an optional descriptive name.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/client

LANGUAGE: JSON
CODE:
```
[
  {
    "uri": "file:///home/user/repos/frontend",
    "name": "Frontend Repository"
  },
  {
    "uri": "file:///home/user/repos/backend",
    "name": "Backend Repository"
  }
]
```

----------------------------------------

TITLE: Tools Call Response JSON-RPC
DESCRIPTION: JSON-RPC response received by clients after a tool invocation. It contains the result of the tool's execution, which can include various content types, and an 'isError' flag.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/tools

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "Current weather in New York:\nTemperature: 72°F\nConditions: Partly cloudy"
      }
    ],
    "isError": false
  }
}
```

----------------------------------------

TITLE: Add Model Context Protocol BOM to Maven and Gradle Projects
DESCRIPTION: The Bill of Materials (BOM) declares recommended versions for dependencies, simplifying dependency management and ensuring tested versions. Add the MCP BOM to your project's build script to automatically manage dependency versions.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-overview

LANGUAGE: Maven
CODE:
```
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>io.modelcontextprotocol.sdk</groupId>
            <artifactId>mcp-bom</artifactId>
            <version>0.10.0</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

LANGUAGE: Gradle
CODE:
```
dependencies {
  implementation platform("io.modelcontextprotocol.sdk:mcp-bom:0.10.0")
  //...
}
```

----------------------------------------

TITLE: Resource Data Type Definition
DESCRIPTION: Defines the structure of a resource object, including its unique identifier, name, optional display title, description, MIME type, and size.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/resources

LANGUAGE: APIDOC
CODE:
```
Resource:
  uri: string - Unique identifier for the resource
  name: string - The name of the resource
  title: string (optional) - Human-readable name for display
  description: string (optional) - Description of the resource
  mimeType: string (optional) - MIME type of the resource
  size: number (optional) - Size in bytes
```

----------------------------------------

TITLE: Request List of Roots from Model Context Protocol Client
DESCRIPTION: Servers retrieve the current list of roots from a Model Context Protocol client by sending a 'roots/list' request. This request is a standard JSON-RPC 2.0 message.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/client

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "roots/list"
}
```

----------------------------------------

TITLE: MCP Client Server Path Usage Examples
DESCRIPTION: Illustrates various ways to specify the server script path when running the MCP client, including relative, absolute, and Windows-specific path formats. This helps in resolving `FileNotFoundError` issues.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: Shell
CODE:
```
# Relative path
uv run client.py ./server/weather.py

# Absolute path
uv run client.py /Users/username/projects/mcp-server/weather.py

# Windows path (either format works)
uv run client.py C:/projects/mcp-server/weather.py
uv run client.py C:\\projects\\mcp-server\\weather.py
```

----------------------------------------

TITLE: MCP Server HTTP Error Status Codes for Authorization
DESCRIPTION: Documents the required HTTP status codes that MCP servers must return for various authorization-related errors, including 401 Unauthorized for invalid tokens, 403 Forbidden for insufficient permissions, and 400 Bad Request for malformed requests, aligning with OAuth 2.1 error handling.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/basic/authorization

LANGUAGE: APIDOC
CODE:
```
Status Code | Description | Usage
--- | --- | ---
401 | Unauthorized | Authorization required or token invalid
403 | Forbidden | Invalid scopes or insufficient permissions
400 | Bad Request | Malformed authorization request
```

----------------------------------------

TITLE: Client Initialized Notification (JSON-RPC)
DESCRIPTION: After receiving a successful 'initialize' response from the server, the client sends an 'initialized' notification. This signals that the client is ready to begin normal protocol operations, and both parties can now send and receive regular requests.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/basic/lifecycle

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "method": "notifications/initialized"
}
```

----------------------------------------

TITLE: Define JSON-RPC Error Response Structure
DESCRIPTION: Provides an example of a JSON-RPC error response in MCP, detailing the error code and message for common failure cases like user rejection.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/client/sampling

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -1,
    "message": "User rejected sampling request"
  }
}
```

----------------------------------------

TITLE: Client `initialized` Notification for MCP
DESCRIPTION: After successfully receiving the server's `initialize` response, the client sends an `initialized` notification. This signals to the server that the client is ready to proceed with normal protocol operations.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/basic/lifecycle

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "method": "notifications/initialized"
}
```

----------------------------------------

TITLE: Resource Template Definition (APIDOC)
DESCRIPTION: Specifies the structure for URI templates used by clients to construct URIs for dynamic resources, adhering to RFC 6570. Includes fields for the template string, a human-readable name, an optional description, and an optional MIME type.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/resources

LANGUAGE: APIDOC
CODE:
```
{
  uriTemplate: string;   // URI template following RFC 6570
  name: string;          // Human-readable name for this type
  description?: string;  // Optional description
  mimeType?: string;     // Optional MIME type for all matching resources
}
```

----------------------------------------

TITLE: Example JSON-RPC Initialization Error Response
DESCRIPTION: An example of a JSON-RPC error response indicating an unsupported protocol version during initialization. This structure includes the JSON-RPC version, a request ID, and an error object with a specific code, a human-readable message, and additional data detailing the supported and requested protocol versions.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/basic/lifecycle

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -32602,
    "message": "Unsupported protocol version",
    "data": {
      "supported": ["2024-11-05"],
      "requested": "1.0.0"
    }
  }
}
```

----------------------------------------

TITLE: Client `initialized` Notification
DESCRIPTION: After successful initialization, the client sends an `initialized` notification to indicate it is ready to begin normal operations. This notification signals the transition from the initialization phase to the operation phase, allowing both client and server to proceed with standard protocol communication.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/basic/lifecycle

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "method": "notifications/initialized"
}
```

----------------------------------------

TITLE: Example MCP Client Roots Configuration
DESCRIPTION: Demonstrates how a typical Model Context Protocol client might expose a list of roots, including their URIs and descriptive names, in a JSON format. This configuration guides the server's focus to specific local repositories and API endpoints.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/roots

LANGUAGE: JSON
CODE:
```
{
  "roots": [
    {
      "uri": "file:///home/user/projects/frontend",
      "name": "Frontend Repository"
    },
    {
      "uri": "https://api.example.com/v1",
      "name": "API Endpoint"
    }
  ]
}
```

----------------------------------------

TITLE: JSON Schema: String Type Definition
DESCRIPTION: This JSON Schema snippet defines a string property, demonstrating common constraints like "minLength", "maxLength", "pattern", and "format". Supported formats include "email", "uri", "date", and "date-time".
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client/elicitation

LANGUAGE: json
CODE:
```
{
  "type": "string",
  "title": "Display Name",
  "description": "Description text",
  "minLength": 3,
  "maxLength": 50,
  "pattern": "^[A-Za-z]+$",
  "format": "email"
}
```

----------------------------------------

TITLE: Add Spring AI MCP Client Dependencies
DESCRIPTION: Required Maven dependencies to be added to your pom.xml file for integrating Spring AI's Model Context Protocol client and the Anthropic AI model.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: XML
CODE:
```
<dependency>
    <groupId>org.springframework.ai</groupId>
    <artifactId>spring-ai-starter-mcp-client</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.ai</groupId>
    <artifactId>spring-ai-starter-model-anthropic</artifactId>
</dependency>
```

----------------------------------------

TITLE: Read Resource Request
DESCRIPTION: Clients send a `resources/read` request to retrieve resource contents. The request includes the URI of the resource to be read.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/resources

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "resources/read",
  "params": {
    "uri": "file:///project/src/main.rs"
  }
}
```

----------------------------------------

TITLE: Model Context Protocol Standard JSON-RPC Error Handling
DESCRIPTION: Servers in the Model Context Protocol should return standard JSON-RPC errors for common failure cases related to logging operations. This API documentation specifies the recommended error codes for issues such as invalid log levels and general configuration errors.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/utilities/logging

LANGUAGE: APIDOC
CODE:
```
Error Cases:
- Invalid log level:
  - JSON-RPC Code: -32602
  - Description: Invalid params
- Configuration errors:
  - JSON-RPC Code: -32603
  - Description: Internal error
```

----------------------------------------

TITLE: Add Spring AI MCP Server Dependencies
DESCRIPTION: Configuration snippets for Maven and Gradle to include the `spring-ai-starter-mcp-server` and `spring-web` dependencies required for building a Spring AI Model Context Protocol (MCP) server.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: XML (Maven)
CODE:
```
<dependencies>
      <dependency>
          <groupId>org.springframework.ai</groupId>
          <artifactId>spring-ai-starter-mcp-server</artifactId>
      </dependency>

      <dependency>
          <groupId>org.springframework</groupId>
          <artifactId>spring-web</artifactId>
      </dependency>
</dependencies>
```

LANGUAGE: Groovy (Gradle)
CODE:
```
dependencies {
  implementation platform("org.springframework.ai:spring-ai-starter-mcp-server")
  implementation platform("org.springframework:spring-web")
}
```

----------------------------------------

TITLE: Set Minimum Log Level (logging/setLevel) Request
DESCRIPTION: Clients can configure the minimum log level they wish to receive by sending a 'logging/setLevel' JSON-RPC request. This allows clients to control the verbosity of log messages from the server.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/utilities/logging

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "logging/setLevel",
  "params": {
    "level": "info"
  }
}
```

----------------------------------------

TITLE: Declare Elicitation Capability in MCP Initialization
DESCRIPTION: Clients that support the Elicitation feature must declare the 'elicitation' capability during the initial handshake or lifecycle initialization phase. This signals to the server that the client is capable of handling elicitation requests.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client/elicitation

LANGUAGE: JSON
CODE:
```
{
  "capabilities": {
    "elicitation": {}
  }
}
```

----------------------------------------

TITLE: Model Context Protocol Root Data Type Example: Multiple Repositories
DESCRIPTION: An example of an array of root definitions, demonstrating how multiple repositories or directories can be exposed as roots.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/client/roots

LANGUAGE: JSON
CODE:
```
[
  {
    "uri": "file:///home/user/repos/frontend",
    "name": "Frontend Repository"
  },
  {
    "uri": "file:///home/user/repos/backend",
    "name": "Backend Repository"
  }
]
```

----------------------------------------

TITLE: Tools Call Request JSON-RPC
DESCRIPTION: JSON-RPC request sent by clients to invoke a specific tool. It includes the tool's name and a JSON object containing its arguments.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/tools

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "tools/call",
  "params": {
    "name": "get_weather",
    "arguments": {
      "location": "New York"
    }
  }
}
```

----------------------------------------

TITLE: JSON Structure for Text Tool Result Content
DESCRIPTION: Represents a text-based content item that can be included within a tool result. It specifies the content type as 'text' and contains the actual text string.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/tools

LANGUAGE: JSON
CODE:
```
{
  "type": "text",
  "text": "Tool result text"
}
```

----------------------------------------

TITLE: Add MCP Kotlin SDK and Ktor Dependencies to Gradle
DESCRIPTION: Illustrates how to add necessary dependencies like `kotlin-sdk`, `slf4j-nop`, `ktor-client-content-negotiation`, and `ktor-serialization-kotlinx-json` to both Kotlin DSL (`build.gradle.kts`) and Groovy DSL (`build.gradle`) build scripts for an MCP server project.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: Gradle Kotlin DSL
CODE:
```
val mcpVersion = "0.4.0"
val slf4jVersion = "2.0.9"
val ktorVersion = "3.1.1"

dependencies {
    implementation("io.modelcontextprotocol:kotlin-sdk:$mcpVersion")
    implementation("org.slf4j:slf4j-nop:$slf4jVersion")
    implementation("io.ktor:ktor-client-content-negotiation:$ktorVersion")
    implementation("io.ktor:ktor-serialization-kotlinx-json:$ktorVersion")
}
```

LANGUAGE: Gradle Groovy DSL
CODE:
```
val mcpVersion = "0.4.0"
val slf4jVersion = "2.0.9"
val ktorVersion = "3.1.1"

dependencies {
    implementation("io.modelcontextprotocol:kotlin-sdk:$mcpVersion")
    implementation("org.slf4j:slf4j-nop:$slf4jVersion")
    implementation("io.ktor:ktor-client-content-negotiation:$ktorVersion")
    implementation("io.ktor:ktor-serialization-kotlinx-json:$ktorVersion")
}
```

----------------------------------------

TITLE: Response for Getting a Specific Prompt
DESCRIPTION: The server's response to a `prompts/get` request, containing the prompt's description and a list of messages. Each message includes a role and content, which can be various types like text.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/prompts

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "description": "Code review prompt",
    "messages": [
      {
        "role": "user",
        "content": {
          "type": "text",
          "text": "Please review this Python code:\ndef hello():\n    print('world')"
        }
      }
    ]
  }
}
```

----------------------------------------

TITLE: JSON-RPC Error Response Example
DESCRIPTION: Demonstrates a standard JSON-RPC error response for cases like 'Method not found' (e.g., roots not supported). It includes the error code, a descriptive message, and optional data for further context.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/client

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -32601,
    "message": "Roots not supported",
    "data": {
      "reason": "Client does not have roots capability"
    }
  }
}
```

----------------------------------------

TITLE: Root Data Type Definition
DESCRIPTION: This API documentation defines the structure of a 'Root' object. It includes a mandatory 'uri' (a file:// URI) and an optional 'name' for display purposes.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/client/roots

LANGUAGE: APIDOC
CODE:
```
Root:
  uri: Unique identifier for the root. This MUST be a file:// URI in the current specification.
  name: Optional human-readable name for display purposes.
```

----------------------------------------

TITLE: MCP: Binary Resource Content Structure
DESCRIPTION: Defines the JSON structure for resources containing binary data. It includes the resource's URI, MIME type (e.g., `image/png`), and the binary data encoded as a base64 string.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/resources

LANGUAGE: JSON
CODE:
```
{
  "uri": "file:///example.png",
  "mimeType": "image/png",
  "blob": "base64-encoded-data"
}
```

----------------------------------------

TITLE: MCP JSON-RPC Error Response Example
DESCRIPTION: This JSON snippet provides an example of a standard JSON-RPC error response that clients should return for common failure cases. It includes the JSON-RPC version, a request ID, and an error object containing a numeric code and a human-readable message.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/client/sampling

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -1,
    "message": "User rejected sampling request"
  }
}
```

----------------------------------------

TITLE: Define System Operations Tool Schema
DESCRIPTION: This JSON schema defines a tool named 'execute_command' for running shell commands, specifying 'command' and 'args' as input properties.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/tools

LANGUAGE: JSON
CODE:
```
{
  "name": "execute_command",
  "description": "Run a shell command",
  "inputSchema": {
    "type": "object",
    "properties": {
      "command": { "type": "string" },
      "args": { "type": "array", "items": { "type": "string" } }
    }
  }
}
```

----------------------------------------

TITLE: MCP Server-to-Client Message Listening via HTTP GET
DESCRIPTION: Outlines the mechanism for clients to listen for messages from the MCP server by issuing an HTTP GET request to open an SSE stream, detailing header requirements and server behavior.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/basic/transports

LANGUAGE: APIDOC
CODE:
```
Server-to-Client Communication (HTTP GET):
  Method: Client MAY issue HTTP GET to open an SSE stream.
  Headers:
    Accept: MUST include 'text/event-stream'.

  Server Response:
    MUST return 'Content-Type: text/event-stream' OR HTTP 405 Method Not Allowed (if SSE not offered).

  If server initiates SSE stream:
    Stream Content: MAY send JSON-RPC requests and notifications.
    Message Relation: SHOULD be unrelated to any concurrently-running client requests.
    JSON-RPC Response: MUST NOT send a JSON-RPC response UNLESS resuming a stream associated with a previous client request.
    Stream Closure: Server MAY close at any time. Client MAY close at any time.
```

----------------------------------------

TITLE: Model Context Protocol Resource URI Format
DESCRIPTION: Defines the standard URI format used to identify resources within the Model Context Protocol, consisting of a protocol, host, and path. Servers can define their own custom URI schemes.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/resources

LANGUAGE: APIDOC
CODE:
```
[protocol]://[host]/[path]
```

----------------------------------------

TITLE: Example Root: Single Project Directory
DESCRIPTION: An example of a single root definition, typically used to expose a specific project directory to the server.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client/roots

LANGUAGE: JSON
CODE:
```
{
  "uri": "file:///home/user/projects/myproject",
  "name": "My Project"
}
```

----------------------------------------

TITLE: Run TypeScript MCP Server with npx
DESCRIPTION: Demonstrates how to quickly run a TypeScript-based Model Context Protocol (MCP) server directly from the command line using `npx`.
SOURCE: https://modelcontextprotocol.io/introduction/examples

LANGUAGE: bash
CODE:
```
npx -y @modelcontextprotocol/server-memory
```

----------------------------------------

TITLE: Declare Logging Capability in MCP
DESCRIPTION: Servers that support emitting log message notifications must declare the 'logging' capability within their protocol capabilities object to inform clients of this feature.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/utilities/logging

LANGUAGE: JSON
CODE:
```
{
  "capabilities": {
    "logging": {}
  }
}
```

----------------------------------------

TITLE: Sending Progress Notification Message
DESCRIPTION: A server can send progress notifications to the client using the `notifications/progress` method. These notifications include the original `progressToken`, the current `progress` value (which must increase), an optional `total` value, and an optional human-readable `message`.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/basic/utilities/progress

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "method": "notifications/progress",
  "params": {
    "progressToken": "abc123",
    "progress": 50,
    "total": 100,
    "message": "Reticulating splines..."
  }
}
```

----------------------------------------

TITLE: Requesting Progress Updates with a Token
DESCRIPTION: To receive progress updates for a long-running operation, a client includes a `progressToken` in the request's metadata. This token must be a unique string or integer identifier for the specific request.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/basic/utilities/progress

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "some_method",
  "params": {
    "_meta": {
      "progressToken": "abc123"
    }
  }
}
```

----------------------------------------

TITLE: Sampling Request Message Format
DESCRIPTION: Defines the standardized JSON structure for sampling requests sent from the server to the client. This format includes the conversation history, model selection preferences, an optional system prompt, and other parameters for controlling the LLM's behavior.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/sampling

LANGUAGE: APIDOC
CODE:
```
{
  messages: [
    {
      role: "user" | "assistant",
      content: {
        type: "text" | "image",

        // For text:
        text?: string,

        // For images:
        data?: string,             // base64 encoded
        mimeType?: string
      }
    }
  ],
  modelPreferences?: {
    hints?: [{
      name?: string                // Suggested model name/family
    }],
    costPriority?: number,         // 0-1, importance of minimizing cost
    speedPriority?: number,        // 0-1, importance of low latency
    intelligencePriority?: number  // 0-1, importance of capabilities
  },
  systemPrompt?: string,
  includeContext?: "none" | "thisServer" | "allServers",
  temperature?: number,
  maxTokens: number,
  stopSequences?: string[],
  metadata?: Record<string, unknown>
}
```

----------------------------------------

TITLE: JSON: Embedded Resource Content Type for PromptMessage
DESCRIPTION: Enables referencing server-side resources directly within messages. Resources must include a valid URI, appropriate MIME type, and either text content or base64-encoded blob data, allowing prompts to seamlessly incorporate server-managed content like documentation or code samples.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/prompts

LANGUAGE: APIDOC
CODE:
```
{
  "type": "resource",
  "resource": {
    "uri": "resource://example",
    "name": "example",
    "title": "My Example Resource",
    "mimeType": "text/plain",
    "text": "Resource content"
  }
}
```

----------------------------------------

TITLE: Notify MCP Server of Root List Changes
DESCRIPTION: Clients that support the 'listChanged' capability must send a 'notifications/roots/list_changed' notification to the server whenever the list of exposed roots is modified. This is a JSON-RPC 2.0 notification without an ID.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "method": "notifications/roots/list_changed"
}
```

----------------------------------------

TITLE: JSON-RPC 2.0 Request Message Format
DESCRIPTION: Defines the structure for a JSON-RPC 2.0 request message, including the protocol version, a unique identifier, the method name to be invoked, and optional parameters.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/transports

LANGUAGE: APIDOC
CODE:
```
{
  jsonrpc: "2.0",
  id: number | string,
  method: string,
  params?: object
}

```

----------------------------------------

TITLE: Execute Prompt Templates Asynchronously with MCP Client (Java)
DESCRIPTION: Illustrates how to list available server-side prompt templates and execute a specific template with custom parameters using the asynchronous API of the Model Context Protocol (MCP) client. This leverages reactive streams for non-blocking prompt execution.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-client

LANGUAGE: Java
CODE:
```
// List available prompt templates asynchronously
client.listPrompts()
    .doOnNext(prompts -> prompts.forEach(prompt ->
        System.out.println(prompt.getName())))
    .subscribe();

// Execute a prompt template asynchronously
client.executePrompt("echo", Map.of(
        "text", "Hello, World!"
    ))
    .subscribe();
```

----------------------------------------

TITLE: Model Context Protocol Logging API Specification
DESCRIPTION: The Model Context Protocol (MCP) defines a standardized logging utility. Servers emitting log messages must declare the 'logging' capability. The protocol uses standard syslog severity levels (debug, info, notice, warning, error, critical, alert, emergency). Clients can set the minimum log level, and servers send structured log notifications.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/utilities/logging

LANGUAGE: APIDOC
CODE:
```
Capabilities:
  logging: {}
    Description: Servers MUST declare this capability to indicate support for logging.

Log Levels (RFC 5424 syslog severity levels):
  debug: Detailed debugging information
  info: General informational messages
  notice: Normal but significant events
  warning: Warning conditions
  error: Error conditions
  critical: Critical conditions
  alert: Action must be taken immediately
  emergency: System is unusable

Protocol Messages:
  logging/setLevel Request:
    Method: "logging/setLevel"
    Params:
      level: string (Required)
        Description: The minimum log level to set (e.g., "info", "debug", "error").

  notifications/message Notification:
    Method: "notifications/message"
    Params:
      level: string (Required)
        Description: The severity level of the log message (e.g., "error", "warning").
      logger: string (Optional)
        Description: The name of the logger (e.g., "database").
      data: object (Optional)
        Description: Arbitrary JSON-serializable data related to the log message.
```

----------------------------------------

TITLE: MCP Resources List Response Message
DESCRIPTION: JSON message for the server's response to a 'resources/list' request. It contains a list of 'resources' objects, each with URI, name, description, and MIME type, and an optional 'nextCursor' for pagination.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/resources

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "resources": [
      {
        "uri": "file:///project/src/main.rs",
        "name": "main.rs",
        "description": "Primary application entry point",
        "mimeType": "text/x-rust"
      }
    ],
    "nextCursor": "next-page-cursor"
  }
}
```

----------------------------------------

TITLE: Implement Interactive Chat Loop and Cleanup
DESCRIPTION: This snippet defines an asynchronous chat loop that allows users to interact with the MCP client via the console. It continuously prompts for queries, processes them using `processQuery`, and displays responses. It also includes a cleanup function to close the MCP connection gracefully.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: TypeScript
CODE:
```
async chatLoop() {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  try {
    console.log("\nMCP Client Started!");
    console.log("Type your queries or 'quit' to exit.");

    while (true) {
      const message = await rl.question("\nQuery: ");
      if (message.toLowerCase() === "quit") {
        break;
      }
      const response = await this.processQuery(message);
      console.log("\n" + response);
    }
  } finally {
    rl.close();
  }
}

async cleanup() {
  await this.mcp.close();
}
```

----------------------------------------

TITLE: Connect MCP Client using Standard I/O Transport
DESCRIPTION: Illustrates how to establish a connection for an MCP client using the Standard Input/Output (stdio) transport. This setup is ideal for interacting with local MCP servers or command-line applications.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/transports

LANGUAGE: TypeScript
CODE:
```
const client = new Client({
  name: "example-client",
  version: "1.0.0"
}, {
  capabilities: {}
});

const transport = new StdioClientTransport({
  command: "./server",
  args: ["--option", "value"]
});
await client.connect(transport);

```

LANGUAGE: Python
CODE:
```
params = StdioServerParameters(
    command="./server",
    args=["--option", "value"]
)

async with stdio_client(params) as streams:
    async with ClientSession(streams[0], streams[1]) as session:
        await session.initialize()

```

----------------------------------------

TITLE: Request to List Available Tools in Model Context Protocol
DESCRIPTION: Clients send a 'tools/list' request to discover available tools. This operation supports pagination, allowing clients to specify a 'cursor' for retrieving subsequent pages of results.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/tools

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/list",
  "params": {
    "cursor": "optional-cursor-value"
  }
}
```

----------------------------------------

TITLE: Declare Sampling Capability in MCP Client Initialization
DESCRIPTION: Clients supporting the Model Context Protocol's sampling feature must declare this capability during their initialization phase. This JSON snippet shows the required structure to include the 'sampling' capability within the 'capabilities' object.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/client/sampling

LANGUAGE: JSON
CODE:
```
{
  "capabilities": {
    "sampling": {}
  }
}
```

----------------------------------------

TITLE: Declare Sampling Capability during Client Initialization
DESCRIPTION: Clients supporting sampling must declare the 'sampling' capability during initialization to inform the server of their functionality and enable sampling features.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/client/sampling

LANGUAGE: JSON
CODE:
```
{
  "capabilities": {
    "sampling": {}
  }
}
```

----------------------------------------

TITLE: APIDOC: CompleteRequest Structure
DESCRIPTION: Defines the structure for a completion request, including references and arguments.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/utilities/completion

LANGUAGE: APIDOC
CODE:
```
CompleteRequest:
  ref: A PromptReference or ResourceReference
  argument:
    name: Argument name
    value: Current value
```

----------------------------------------

TITLE: Model Context Protocol Pagination Response Format
DESCRIPTION: This JSON snippet illustrates the server's response format when supporting pagination. It includes the current page of results and an optional `nextCursor` field if more results are available for subsequent requests.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/utilities/pagination

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": "123",
  "result": {
    "resources": [...],
    "nextCursor": "eyJwYWdlIjogM30="
  }
}
```

----------------------------------------

TITLE: Resource Data Type Definition
DESCRIPTION: Defines the structure of a resource, including its unique identifier, human-readable name, optional description, MIME type, and size.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/resources

LANGUAGE: plaintext
CODE:
```
Resource:
  uri: Unique identifier for the resource
  name: Human-readable name
  description: Optional description
  mimeType: Optional MIME type
  size: Optional size in bytes
```

----------------------------------------

TITLE: APIDOC: Image Content Structure for MCP Messages
DESCRIPTION: This API documentation defines the structure for image-based content within Model Context Protocol messages. It requires a 'type' of 'image', 'data' containing the base64-encoded image, and 'mimeType' specifying the image format (e.g., 'image/jpeg').
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/client/sampling

LANGUAGE: APIDOC
CODE:
```
{
  "type": "image",
  "data": "base64-encoded-image-data",
  "mimeType": "image/jpeg"
}
```

----------------------------------------

TITLE: JSON Structure for Audio Content in MCP
DESCRIPTION: Defines the JSON structure for representing audio data within the Model Context Protocol, including base64 encoded data and MIME type for specifying the audio format.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client/sampling

LANGUAGE: json
CODE:
```
{
  "type": "audio",
  "data": "base64-encoded-audio-data",
  "mimeType": "audio/wav"
}
```

----------------------------------------

TITLE: JSON-RPC 2.0 Notification Message Format
DESCRIPTION: Defines the structure for a JSON-RPC 2.0 notification message. Notifications are requests without a response expected, including the protocol version, the method name, and optional parameters.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/transports

LANGUAGE: APIDOC
CODE:
```
{
  jsonrpc: "2.0",
  method: string,
  params?: object
}

```

----------------------------------------

TITLE: JSON Structure for Image Content in MCP
DESCRIPTION: Defines the JSON structure for representing image data within the Model Context Protocol, including base64 encoded data and MIME type for specifying the image format.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client/sampling

LANGUAGE: json
CODE:
```
{
  "type": "image",
  "data": "base64-encoded-image-data",
  "mimeType": "image/jpeg"
}
```

----------------------------------------

TITLE: Configure Claude for Desktop with MCP Server
DESCRIPTION: JSON configuration to add an MCP server entry (e.g., 'weather') to Claude for Desktop's `claude_desktop_config.json`, specifying the command and arguments to launch the Node.js server. Paths are adjusted for different operating systems.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: JSON (MacOS/Linux)
CODE:
```
{
  "mcpServers": {
    "weather": {
      "command": "node",
      "args": ["/ABSOLUTE/PATH/TO/PARENT/FOLDER/weather/build/index.js"]
    }
  }
}
```

LANGUAGE: JSON (Windows)
CODE:
```
{
  "mcpServers": {
    "weather": {
      "command": "node",
      "args": ["C:\\PATH\\TO\\PARENT\\FOLDER\\weather\\build\\index.js"]
    }
  }
}
```

----------------------------------------

TITLE: Configure MCP Brave Search Server
DESCRIPTION: JSON configuration for the Model Context Protocol server, specifying the command to run the Brave Search server using npx and passing the Brave API key as an environment variable.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: JSON
CODE:
```
{
  "mcpServers": {
    "brave-search": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-brave-search"],
      "env": {
        "BRAVE_API_KEY": "<PUT YOUR BRAVE API KEY>"
      }
    }
  }
}
```

----------------------------------------

TITLE: Example Root for a Single Project Directory
DESCRIPTION: This JSON snippet provides an example of a single root definition, typically used to expose a specific project directory to the server.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/client/roots

LANGUAGE: JSON
CODE:
```
{
  "uri": "file:///home/user/projects/myproject",
  "name": "My Project"
}
```

----------------------------------------

TITLE: Include Progress Token in Request Metadata
DESCRIPTION: To receive progress updates for a long-running operation, a client includes a unique 'progressToken' (string or integer) within the '_meta' field of the request's parameters. This token identifies the specific operation for which progress notifications are expected.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/basic/utilities/progress

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "some_method",
  "params": {
    "_meta": {
      "progressToken": "abc123"
    }
  }
}
```

----------------------------------------

TITLE: Implementing Custom Transport Mechanisms for Model Context Protocol
DESCRIPTION: Rules and recommendations for implementers who choose to support custom transport mechanisms, emphasizing adherence to the JSON-RPC message format and lifecycle requirements defined by MCP, and the importance of documentation for interoperability.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/basic/transports

LANGUAGE: APIDOC
CODE:
```
Clients and servers MAY implement additional custom transport mechanisms to suit their specific needs.
Implementers who choose to support custom transports:
- MUST ensure they preserve the JSON-RPC message format and lifecycle requirements defined by MCP.
- SHOULD document their specific connection establishment and message exchange patterns to aid interoperability.
```

----------------------------------------

TITLE: Model Context Protocol Root Data Type Definition
DESCRIPTION: The 'Root' data type in the Model Context Protocol defines a single filesystem root. It includes a mandatory 'uri' (a file:// URI) and an optional 'name' for display purposes.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/client

LANGUAGE: APIDOC
CODE:
```
Root:
  uri: string (required)
    Description: Unique identifier for the root. This MUST be a file:// URI in the current specification.
  name: string (optional)
    Description: Human-readable name for display purposes.
```

----------------------------------------

TITLE: Open Claude for Desktop Configuration File
DESCRIPTION: These commands open the Claude for Desktop configuration file `claude_desktop_config.json` in a text editor (e.g., VS Code). The path varies slightly between MacOS/Linux and Windows operating systems.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: Shell
CODE:
```
code ~/Library/Application\ Support/Claude/claude_desktop_config.json
```

LANGUAGE: Shell
CODE:
```
code $env:AppData\Claude\claude_desktop_config.json
```

----------------------------------------

TITLE: Example JSON-RPC Protocol Error
DESCRIPTION: This JSON-RPC response illustrates a protocol error, specifically an 'Unknown tool' error with code -32602. This type of error indicates issues at the protocol level, such as requesting a non-existent tool.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/tools

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 3,
  "error": {
    "code": -32602,
    "message": "Unknown tool: invalid_tool_name"
  }
}
```

----------------------------------------

TITLE: JSON-RPC Error Example for Roots Not Supported
DESCRIPTION: This JSON-RPC error example demonstrates a standard response when a client does not support 'roots'. It includes the error code -32601 (Method not found), a descriptive message, and additional data specifying the reason for the error.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/client

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -32601,
    "message": "Roots not supported",
    "data": {
      "reason": "Client does not have roots capability"
    }
  }
}
```

----------------------------------------

TITLE: Streamable HTTP Session Management Example
DESCRIPTION: Illustrates how session IDs are managed in Streamable HTTP. The server assigns an `Mcp-Session-Id` during initialization, and the client includes this ID in subsequent requests for state persistence.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/transports

LANGUAGE: JavaScript
CODE:
```
// Server assigns session ID during initialization
app.post("/mcp", (req, res) => {
  if (req.body.method === "initialize") {
    const sessionId = generateSecureId();
    res.setHeader("Mcp-Session-Id", sessionId);
    // Store session state...
  }
  // Handle request...
});

// Client includes session ID in subsequent requests
fetch("/mcp", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
    "Mcp-Session-Id": sessionId,
  },
  body: JSON.stringify(request),
});
```

----------------------------------------

TITLE: Declare Roots Capability in Model Context Protocol Client Initialization
DESCRIPTION: Clients supporting the 'roots' feature in the Model Context Protocol must declare this capability during initialization. The 'listChanged' property indicates whether the client will send notifications when the list of roots is modified.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/client

LANGUAGE: JSON
CODE:
```
{
  "capabilities": {
    "roots": {
      "listChanged": true
    }
  }
}
```

----------------------------------------

TITLE: Request Model Context Protocol Completions with Prior Argument Context
DESCRIPTION: For prompts or URI templates with multiple arguments, clients should include previously completed arguments in the 'context.arguments' object. This provides relevant context to the server, allowing for more accurate and refined autocompletion suggestions for subsequent requests.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/utilities/completion

LANGUAGE: JSON (Request)
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "completion/complete",
  "params": {
    "ref": {
      "type": "ref/prompt",
      "name": "code_review"
    },
    "argument": {
      "name": "framework",
      "value": "fla"
    },
    "context": {
      "arguments": {
        "language": "python"
      }
    }
  }
}
```

LANGUAGE: JSON (Response)
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "completion": {
      "values": ["flask"],
      "total": 1,
      "hasMore": false
    }
  }
}
```

----------------------------------------

TITLE: Declare Server Tools Capability in MCP
DESCRIPTION: Servers supporting tools in the Model Context Protocol must declare the 'tools' capability within their capabilities object. The 'listChanged' property indicates if the server will notify clients when the list of available tools changes.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/tools

LANGUAGE: JSON
CODE:
```
{
  "capabilities": {
    "tools": {
      "listChanged": true
    }
  }
}
```

----------------------------------------

TITLE: Execute Prompt Templates Synchronously with MCP Client (Java)
DESCRIPTION: Explains how to list available server-side prompt templates and execute a specific template with custom parameters using the synchronous API of the Model Context Protocol (MCP) client. This enables dynamic text generation based on predefined patterns.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-client

LANGUAGE: Java
CODE:
```
// List available prompt templates
var prompts = client.listPrompts();
prompts.forEach(prompt -> System.out.println(prompt.getName()));

// Execute a prompt template with parameters
var response = client.executePrompt("echo", Map.of(
    "text", "Hello, World!"
));
```

----------------------------------------

TITLE: Define JSON-RPC 2.0 Notification Structure for MCP
DESCRIPTION: Specifies the one-way JSON-RPC 2.0 notification format used in the Model Context Protocol. Notifications do not require an ID and are not expected to receive a response from the receiver. They include a method name and optional parameters.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/basic

LANGUAGE: APIDOC
CODE:
```
{
  jsonrpc: "2.0";
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

----------------------------------------

TITLE: JSON-RPC Response: Get a Prompt
DESCRIPTION: The server's response to a `prompts/get` request, providing the requested prompt's description and a structured list of messages. Each message includes a role (e.g., 'user') and content, which can be plain text.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/prompts

LANGUAGE: APIDOC
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "description": "Code review prompt",
    "messages": [
      {
        "role": "user",
        "content": {
          "type": "text",
          "text": "Please review this Python code:\ndef hello():\n    print('world')"
        }
      }
    ]
  }
}
```

----------------------------------------

TITLE: Model Context Protocol Standard Error Codes
DESCRIPTION: Enumerates the standard JSON-RPC 2.0 error codes defined by the Model Context Protocol (MCP) for consistent error handling.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/architecture

LANGUAGE: TypeScript
CODE:
```
enum ErrorCode {
  // Standard JSON-RPC error codes
  ParseError = -32700,
  InvalidRequest = -32600,
  MethodNotFound = -32601,
  InvalidParams = -32602,
  InternalError = -32603,
}
```

----------------------------------------

TITLE: APIDOC: Model Context Protocol Shutdown Phase
DESCRIPTION: Details the process for cleanly terminating the protocol connection, focusing on transport-specific mechanisms for shutdown, including stdio and HTTP.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/basic/lifecycle

LANGUAGE: APIDOC
CODE:
```
Shutdown Phase:
  One side (usually client) cleanly terminates the protocol connection.
  No specific shutdown messages; underlying transport mechanism signals termination.

Transport-Specific Shutdown:
  stdio:
    Client SHOULD initiate shutdown by:
      1. Closing input stream to child process (server).
      2. Waiting for server to exit, or sending SIGTERM if server doesn't exit timely.
      3. Sending SIGKILL if server doesn't exit timely after SIGTERM.
    Server MAY initiate shutdown by closing its output stream to client and exiting.
  HTTP:
    Shutdown indicated by closing associated HTTP connection(s).
```

----------------------------------------

TITLE: JSON Structure for Embedded Resource Tool Result Content
DESCRIPTION: Represents an embedded resource content item within a tool result, providing additional context or data. It includes the content type as 'resource' and details about the resource such as its URI, MIME type, and optional inline text content.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/tools

LANGUAGE: JSON
CODE:
```
{
  "type": "resource",
  "resource": {
    "uri": "resource://example",
    "mimeType": "text/plain",
    "text": "Resource content"
  }
}
```

----------------------------------------

TITLE: JSON-RPC Error Example for Unsupported Roots
DESCRIPTION: This JSON-RPC error example demonstrates a standard response when a client does not support 'roots' functionality, indicating a 'Method not found' error with specific details about the reason. Clients should return this error for common failure cases like unsupported roots.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client/roots

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -32601,
    "message": "Roots not supported",
    "data": {
      "reason": "Client does not have roots capability"
    }
  }
}
```

----------------------------------------

TITLE: JSON-RPC Error Response Example
DESCRIPTION: An example of a standard JSON-RPC error response, illustrating common failure cases like 'Resource not found' with a specific error code, message, and additional data.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/resources

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 5,
  "error": {
    "code": -32002,
    "message": "Resource not found",
    "data": {
      "uri": "file:///nonexistent.txt"
    }
  }
}
```

----------------------------------------

TITLE: JSON-RPC Protocol Error Example
DESCRIPTION: Provides an example of a standard JSON-RPC error response, indicating issues like unknown tools or invalid arguments.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/tools

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 3,
  "error": {
    "code": -32602,
    "message": "Unknown tool: invalid_tool_name"
  }
}
```

----------------------------------------

TITLE: Resource List Changed Notification
DESCRIPTION: Servers that declare the `listChanged` capability should send a `notifications/resources/list_changed` notification to clients when the list of available resources changes, informing them to re-list resources.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/resources

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "method": "notifications/resources/list_changed"
}
```

----------------------------------------

TITLE: APIDOC: Model Context Protocol Roots Capability
DESCRIPTION: Defines the 'roots' capability object within the client's initialization capabilities. The 'listChanged' property indicates if the client will send notifications when the root list changes.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client

LANGUAGE: APIDOC
CODE:
```
capabilities:
  roots:
    listChanged: boolean
      Description: Indicates whether the client will emit notifications when the list of roots changes.
```

----------------------------------------

TITLE: Root Data Type Definition
DESCRIPTION: Defines the structure of a single root object within the Model Context Protocol. A root specifies a unique identifier (URI) and an optional display name.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client/roots

LANGUAGE: APIDOC
CODE:
```
Root:
  uri: string
    Unique identifier for the root. MUST be a 'file://' URI in the current specification.
  name: string (optional)
    Human-readable name for display purposes.
```

----------------------------------------

TITLE: Define Asynchronous Tool Specification (Java)
DESCRIPTION: Shows how to define an asynchronous tool specification using `McpServerFeatures.AsyncToolSpecification`. Similar to synchronous tools, it requires a `Tool` definition with schema. However, its call handler returns a `Mono.just` wrapped `CallToolResult`, indicating an asynchronous, non-blocking operation, suitable for long-running tasks or external API calls.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-server

LANGUAGE: Java
CODE:
```
// Async tool specification
var schema = """
            {
              "type" : "object",
              "id" : "urn:jsonschema:Operation",
              "properties" : {
                "operation" : {
                  "type" : "string"
                },
                "a" : {
                  "type" : "number"
                },
                "b" : {
                  "type" : "number"
                }
              }
            }
            """;
var asyncToolSpecification = new McpServerFeatures.AsyncToolSpecification(
    new Tool("calculator", "Basic calculator", schema),
    (exchange, arguments) -> {
        // Tool implementation
        return Mono.just(new CallToolResult(result, false));
    }
);
```

----------------------------------------

TITLE: Define GetCommandAndArguments Helper Function
DESCRIPTION: A static helper function designed to parse command-line arguments and determine the correct command and arguments for launching different types of MCP servers. It supports Python, Node.js, and .NET project files, throwing an exception for unsupported script types.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: C#
CODE:
```
static (string command, string[] arguments) GetCommandAndArguments(string[] args)
{
    return args switch
    {
        [var script] when script.EndsWith(".py") => ("python", args),
        [var script] when script.EndsWith(".js") => ("node", args),
        [var script] when Directory.Exists(script) || (File.Exists(script) && script.EndsWith(".csproj")) => ("dotnet", ["run", "--project", script, "--no-build"]),
        _ => throw new NotSupportedException("An unsupported server script was provided. Supported scripts are .py, .js, or .csproj")
    };
}
```

----------------------------------------

TITLE: Model Context Protocol: Cancellation Notification (`notifications/cancelled`)
DESCRIPTION: Defines the `notifications/cancelled` message within the Model Context Protocol for terminating in-progress requests. It specifies the required parameters and outlines the expected behavior for both sender and receiver, including handling of race conditions and resource management.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/basic/utilities/cancellation

LANGUAGE: APIDOC
CODE:
```
notifications/cancelled (Notification)
  Purpose: Indicates that a previously-issued request should be terminated.
  Parameters:
    requestId: string
      Description: The ID of the request to cancel.
      Required: Yes
    reason: string (optional)
      Description: An optional reason string that can be logged or displayed.
      Required: No
  Behavior Requirements:
    - Cancellation notifications MUST only reference requests that were previously issued in the same direction and are believed to still be in-progress.
    - The 'initialize' request MUST NOT be cancelled by clients.
    - Receivers of cancellation notifications SHOULD:
      - Stop processing the cancelled request.
      - Free associated resources.
      - Not send a response for the cancelled request.
    - Receivers MAY ignore cancellation notifications if:
      - The referenced request is unknown.
      - Processing has already completed.
      - The request cannot be cancelled.
    - The sender of the cancellation notification SHOULD ignore any response to the request that arrives afterward.
  Timing Considerations:
    - Both parties MUST handle race conditions gracefully due to network latency (cancellation may arrive after request completion/response).
  Implementation Notes:
    - Both parties SHOULD log cancellation reasons for debugging.
    - Application UIs SHOULD indicate when cancellation is requested.
```

----------------------------------------

TITLE: Example Model Context Protocol Roots for Multiple Repositories
DESCRIPTION: An example array demonstrating how multiple filesystem roots, such as different repository directories, can be defined and exposed by a client.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/client

LANGUAGE: JSON
CODE:
```
[
  {
    "uri": "file:///home/user/repos/frontend",
    "name": "Frontend Repository"
  },
  {
    "uri": "file:///home/user/repos/backend",
    "name": "Backend Repository"
  }
]
```

----------------------------------------

TITLE: Request to List Filesystem Roots
DESCRIPTION: Servers send this JSON RPC request to retrieve the current list of roots from a supporting client. The request includes a unique ID and the 'roots/list' method.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/client/roots

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "roots/list"
}
```

----------------------------------------

TITLE: Model Context Protocol: resources/list Request
DESCRIPTION: Clients send a `resources/list` request to discover available resources. This operation supports pagination. The request includes an optional `cursor` parameter for paginated results.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/resources

LANGUAGE: APIDOC
CODE:
```
resources/list Request:
  Method: "resources/list"
  Parameters:
    cursor:
      Type: string
      Description: An optional cursor value for pagination.
  JSON-RPC Fields:
    jsonrpc: "2.0"
    id: number
```

----------------------------------------

TITLE: Server Notification for Log Message
DESCRIPTION: Servers send log messages to clients using 'notifications/message' JSON-RPC notifications. Each message includes a severity 'level', an optional 'logger' name for categorization, and arbitrary JSON-serializable 'data' related to the log event.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/utilities/logging

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "method": "notifications/message",
  "params": {
    "level": "error",
    "logger": "database",
    "data": {
      "error": "Connection failed",
      "details": {
        "host": "localhost",
        "port": 5432
      }
    }
  }
}
```

----------------------------------------

TITLE: MCP: Stateful Session Management with Mcp-Session-Id Header
DESCRIPTION: Details the mechanism for establishing and managing stateful sessions in MCP using the 'Mcp-Session-Id' HTTP header. It covers session ID assignment during initialization, client inclusion in subsequent requests, server termination, and client-initiated termination.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/basic/transports

LANGUAGE: APIDOC
CODE:
```
MCP Session Management Protocol:
  1. Session ID Assignment (Server):
     - Server MAY assign a session ID at initialization time.
     - Session ID included in 'Mcp-Session-Id' header on HTTP response containing 'InitializeResult'.
     - Session ID SHOULD be globally unique and cryptographically secure (e.g., UUID, JWT, cryptographic hash).
     - Session ID MUST only contain visible ASCII characters (0x21 to 0x7E).
  2. Client Usage of Session ID:
     - If 'Mcp-Session-Id' is returned, client MUST include it in 'Mcp-Session-Id' header on all subsequent HTTP requests.
     - Servers requiring session ID SHOULD respond to requests without it (other than initialization) with HTTP 400 Bad Request.
  3. Server Session Termination:
     - Server MAY terminate the session at any time.
     - After termination, server MUST respond to requests with that session ID with HTTP 404 Not Found.
  4. Client Session Re-initialization:
     - When client receives HTTP 404 for a request with 'Mcp-Session-Id', it MUST start a new session by sending a new 'InitializeRequest' without a session ID.
  5. Client-Initiated Session Termination:
     - Client SHOULD send an HTTP DELETE to the MCP endpoint with 'Mcp-Session-Id' header to explicitly terminate the session.
     - Server MAY respond with HTTP 405 Method Not Allowed if client termination is not allowed.
```

----------------------------------------

TITLE: Response for MCP Roots List Request
DESCRIPTION: Upon receiving a 'roots/list' request, the client responds with a JSON-RPC 2.0 message containing an array of 'Root' objects. Each root includes a URI and an optional human-readable name.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "roots": [
      {
        "uri": "file:///home/user/projects/myproject",
        "name": "My Project"
      }
    ]
  }
}
```

----------------------------------------

TITLE: MCP: Read Resource Request
DESCRIPTION: Clients send this JSON-RPC request to retrieve the contents of a specified resource. The `uri` parameter identifies the target resource.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/resources

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "resources/read",
  "params": {
    "uri": "file:///project/src/main.rs"
  }
}
```

----------------------------------------

TITLE: Configure Servlet-based SSE Server Transport (Java)
DESCRIPTION: This snippet shows how to configure a Servlet-based SSE server transport, which can be used with any Servlet container or registered as a Spring Servlet bean. It leverages the traditional Servlet API for asynchronous message handling, session management, and provides distinct endpoints for server-to-client events and client-to-server requests.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-server

LANGUAGE: Java
CODE:
```
@Configuration
@EnableWebMvc
public class McpServerConfig implements WebMvcConfigurer {

    @Bean
    public HttpServletSseServerTransportProvider servletSseServerTransportProvider() {
        return new HttpServletSseServerTransportProvider(new ObjectMapper(), "/mcp/message");
    }

    @Bean
    public ServletRegistrationBean customServletBean(HttpServletSseServerTransportProvider transportProvider) {
        return new ServletRegistrationBean(transportProvider);
    }
}
```

----------------------------------------

TITLE: Configure MCP Client Capabilities
DESCRIPTION: Illustrates how to build ClientCapabilities to enable features like filesystem roots support with list changes notifications and LLM sampling for an MCP client.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-client

LANGUAGE: Java
CODE:
```
var capabilities = ClientCapabilities.builder()
    .roots(true)      // Enable filesystem roots support with list changes notifications
    .sampling()       // Enable LLM sampling support
    .build();
```

----------------------------------------

TITLE: Example Model Context Protocol Cancellation Notification
DESCRIPTION: This JSON snippet illustrates the structure of a `notifications/cancelled` message, used to request the termination of an in-progress request. It includes the `requestId` of the request to be cancelled and an optional `reason` string for logging or display.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/basic/utilities/cancellation

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "method": "notifications/cancelled",
  "params": {
    "requestId": "123",
    "reason": "User requested cancellation"
  }
}
```

----------------------------------------

TITLE: Initialize MCP Server (Python)
DESCRIPTION: This Python snippet shows the basic imports required to initialize an MCP server using the Model Context Protocol SDK.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/prompts

LANGUAGE: Python
CODE:
```
from mcp.server import Server
import mcp.types as types
```

----------------------------------------

TITLE: Model Context Protocol roots/list Request
DESCRIPTION: Servers send a `roots/list` request to retrieve the current list of roots from the client.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/client/roots

LANGUAGE: APIDOC
CODE:
```
Request:
  jsonrpc: "2.0"
  id: 1
  method: "roots/list"
```

----------------------------------------

TITLE: Model Context Protocol Progress API Specification
DESCRIPTION: Defines the structure and behavior for progress tracking within the Model Context Protocol, including how to request updates and how to send notifications.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/basic/utilities/progress

LANGUAGE: APIDOC
CODE:
```
Model Context Protocol Progress API:
  Requesting Progress Updates:
    Description: To receive progress updates for a request, include a progressToken in the request metadata.
    Parameters:
      _meta: object
        progressToken: string | integer
          Description: A unique identifier for the progress tracking. MUST be unique across all active requests.
  Sending Progress Notifications:
    Method: notifications/progress
    Description: Sent by the receiver to provide updates on an operation's progress.
    Parameters:
      progressToken: string | integer
        Description: The original progress token provided in the request.
      progress: number
        Description: The current progress value. MUST increase with each notification, even if the total is unknown. MAY be floating point.
      total: number (optional)
        Description: The total value for the progress. MAY be floating point.
    Behavior Requirements:
      1. Progress notifications MUST only reference tokens that:
         - Were provided in an active request.
         - Are associated with an in-progress operation.
      2. Receivers of progress requests MAY:
         - Choose not to send any progress notifications.
         - Send notifications at whatever frequency they deem appropriate.
         - Omit the total value if unknown.
      3. Progress notifications MUST stop after completion.
```

----------------------------------------

TITLE: Example Tool Execution Error
DESCRIPTION: This JSON-RPC response shows a tool execution error, where the 'isError' flag is set to true within the result. This indicates a problem during the tool's operation, such as an API failure or business logic error, rather than a protocol issue.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/tools

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 4,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "Failed to fetch weather data: API rate limit exceeded"
      }
    ],
    "isError": true
  }
}
```

----------------------------------------

TITLE: Example JSON-RPC Error Response for Unsupported Roots
DESCRIPTION: This JSON object demonstrates a standard JSON-RPC error response. It indicates that the client does not support 'roots' functionality, returning a -32601 error code (Method not found) with a descriptive message and additional data explaining the reason.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/client/roots

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -32601,
    "message": "Roots not supported",
    "data": {
      "reason": "Client does not have roots capability"
    }
  }
}
```

----------------------------------------

TITLE: MCP Pagination Request Format
DESCRIPTION: This JSON snippet demonstrates how a client requests the next page of results in the Model Context Protocol. It includes the "cursor" received from a previous server response to continue pagination.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/utilities/pagination

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "method": "resources/list",
  "params": {
    "cursor": "eyJwYWdlIjogMn0="
  }
}
```

----------------------------------------

TITLE: Tool Result Text Content Format
DESCRIPTION: Specifies the JSON structure for a text-based content item within a tool's result.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/tools

LANGUAGE: JSON
CODE:
```
{
  "type": "text",
  "text": "Tool result text"
}
```

----------------------------------------

TITLE: Build Spring AI MCP Server JAR
DESCRIPTION: Provides the Maven command to clean and install the Spring AI MCP server project, which compiles the code and packages it into a runnable JAR file in the `target` directory.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: Shell
CODE:
```
./mvnw clean install
```

----------------------------------------

TITLE: Build Spring AI Brave Chatbot Application
DESCRIPTION: Command to clean and build the Spring Boot application using the Maven Wrapper, compiling source code and packaging the application.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: Bash
CODE:
```
./mvnw clean install
```

----------------------------------------

TITLE: MCP API Request for Listing Prompts
DESCRIPTION: Clients send a 'prompts/list' request to retrieve available prompt templates from an MCP server. This operation supports pagination, allowing clients to fetch prompts in chunks using an optional 'cursor' value.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/prompts

LANGUAGE: APIDOC
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "prompts/list",
  "params": {
    "cursor": "optional-cursor-value"
  }
}
```

----------------------------------------

TITLE: Receive prompts/list Response with Prompt Details
DESCRIPTION: The response to a 'prompts/list' request contains an array of 'prompts', each with a name, title, description, and arguments. It also includes 'nextCursor' for pagination, indicating the cursor for the next page of results.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/prompts

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "prompts": [
      {
        "name": "code_review",
        "title": "Request Code Review",
        "description": "Asks the LLM to analyze code quality and suggest improvements",
        "arguments": [
          {
            "name": "code",
            "description": "The code to review",
            "required": true
          }
        ]
      }
    ],
    "nextCursor": "next-page-cursor"
  }
}
```

----------------------------------------

TITLE: Define Audio Content JSON Structure
DESCRIPTION: Defines the JSON structure for representing audio content within the Model Context Protocol, including base64-encoded audio data and its MIME type.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/client/sampling

LANGUAGE: JSON
CODE:
```
{
  "type": "audio",
  "data": "base64-encoded-audio-data",
  "mimeType": "audio/wav"
}
```

----------------------------------------

TITLE: Respond to Ping Request (JSON-RPC)
DESCRIPTION: This JSON-RPC response is sent by the receiver promptly after a ping request. It is an empty result, indicating that the connection is alive and the counterpart is responsive.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/basic/utilities/ping

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": "123",
  "result": {}
}
```

----------------------------------------

TITLE: Example Model Context Protocol Root for a Project Directory
DESCRIPTION: An example of a single root definition representing a project directory, including its 'file://' URI and an optional display name.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/client

LANGUAGE: JSON
CODE:
```
{
  "uri": "file:///home/user/projects/myproject",
  "name": "My Project"
}
```

----------------------------------------

TITLE: Model Context Protocol Completion Reference Types
DESCRIPTION: The Model Context Protocol supports two primary reference types for completion: 'ref/prompt' for named prompts and 'ref/resource' for resource URIs. These types define the context for which completion suggestions are requested.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/utilities/completion

LANGUAGE: APIDOC
CODE:
```
Reference Types:
  - Type: "ref/prompt"
    Description: References a prompt by name
    Example: {"type": "ref/prompt", "name": "code_review"}
  - Type: "ref/resource"
    Description: References a resource URI
    Example: {"type": "ref/resource", "uri": "file:///{path}"}
```

----------------------------------------

TITLE: Tool Definition Data Type
DESCRIPTION: Defines the structure of a tool, including its unique name, human-readable description, and the JSON Schema for its input parameters.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/tools

LANGUAGE: APIDOC
CODE:
```
Tool:
  name: Unique identifier for the tool
  description: Human-readable description of functionality
  inputSchema: JSON Schema defining expected parameters
```

----------------------------------------

TITLE: MCP: Standard Error Response Example
DESCRIPTION: An example of a standard JSON-RPC error response within the Model Context Protocol. It demonstrates a 'Resource not found' error with code `-32002`, including a message and additional data specifying the URI that caused the error.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/resources

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 5,
  "error": {
    "code": -32002,
    "message": "Resource not found",
    "data": {
      "uri": "file:///nonexistent.txt"
    }
  }
}
```

----------------------------------------

TITLE: JSON-RPC Resource Not Found Error Example
DESCRIPTION: This JSON-RPC response illustrates a 'Resource not found' error, using error code -32002 and providing the URI of the missing resource in the data field.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/resources

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 5,
  "error": {
    "code": -32002,
    "message": "Resource not found",
    "data": {
      "uri": "file:///nonexistent.txt"
    }
  }
}
```

----------------------------------------

TITLE: MCP: Read Resource Response
DESCRIPTION: Servers respond with the contents of the requested resource, including its URI, MIME type, and the actual text content. An example shows a Rust file's content.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/resources

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "contents": [
      {
        "uri": "file:///project/src/main.rs",
        "mimeType": "text/x-rust",
        "text": "fn main() {\n    println!(\"Hello world!\");\n}"
      }
    ]
  }
}
```

----------------------------------------

TITLE: JSON Schema: Enum Type Definition
DESCRIPTION: This JSON Schema snippet defines an enumeration (enum) property, allowing the client to select from a predefined list of string values. It demonstrates the use of "enum" for values and "enumNames" for display labels.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client/elicitation

LANGUAGE: json
CODE:
```
{
  "type": "string",
  "title": "Display Name",
  "description": "Description text",
  "enum": ["option1", "option2", "option3"],
  "enumNames": ["Option 1", "Option 2", "Option 3"]
}
```

----------------------------------------

TITLE: Example MCP Root Definition for a Single Project Directory
DESCRIPTION: This JSON snippet demonstrates a single 'Root' object, representing a project directory. It includes a 'file://' URI and an optional human-readable name for display purposes.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client

LANGUAGE: JSON
CODE:
```
{
  "uri": "file:///home/user/projects/myproject",
  "name": "My Project"
}
```

----------------------------------------

TITLE: Declare MCP Resources Capability with List Changed Only
DESCRIPTION: Example JSON for declaring the 'resources' capability with only the 'listChanged' feature enabled. The server will emit notifications when the list of available resources changes, but individual resource subscriptions are not supported.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/resources

LANGUAGE: JSON
CODE:
```
{
  "capabilities": {
    "resources": {
      "listChanged": true
    }
  }
}
```

----------------------------------------

TITLE: Client Notification for Root List Changes
DESCRIPTION: Clients that support the 'listChanged' capability must send this notification when the list of exposed roots changes, informing the server of updates to the accessible filesystem boundaries.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client/roots

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "method": "notifications/roots/list_changed"
}
```

----------------------------------------

TITLE: Notify Root List Changes
DESCRIPTION: When the list of roots changes, clients that support the 'listChanged' capability must send this JSON RPC notification to servers to inform them of the update.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/client/roots

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "method": "notifications/roots/list_changed"
}
```

----------------------------------------

TITLE: JSON-RPC Response for Getting a Prompt
DESCRIPTION: This snippet illustrates the expected JSON-RPC response after successfully retrieving a prompt. It includes the prompt's description and a list of messages, demonstrating how the prompt content is returned.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/prompts

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "description": "Code review prompt",
    "messages": [
      {
        "role": "user",
        "content": {
          "type": "text",
          "text": "Please review this Python code:\ndef hello():\n    print('world')"
        }
      }
    ]
  }
}
```

----------------------------------------

TITLE: Declare Full Resource Capability in MCP
DESCRIPTION: Demonstrates how a server declares full support for the Model Context Protocol's resource capability, including both subscription to individual resource changes and notifications for changes in the list of available resources.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/resources

LANGUAGE: JSON
CODE:
```
{
  "capabilities": {
    "resources": {
      "subscribe": true,
      "listChanged": true
    }
  }
}
```

----------------------------------------

TITLE: Model Context Protocol: sampling/createMessage Response
DESCRIPTION: Defines the structure for a client's response to a `sampling/createMessage` request. It includes the generated content (role, type, text), the specific model used, and the reason for stopping the generation.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/client/sampling

LANGUAGE: APIDOC
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "role": "assistant",
    "content": {
      "type": "text",
      "text": "The capital of France is Paris."
    },
    "model": "claude-3-sonnet-20240307",
    "stopReason": "endTurn"
  }
}
```

----------------------------------------

TITLE: MCP: List Resource Templates Response
DESCRIPTION: Servers respond with a list of available resource templates, each including a `uriTemplate`, `name`, `description`, and `mimeType`. This allows clients to understand how to construct parameterized resource URIs.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/resources

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 3,
  "result": {
    "resourceTemplates": [
      {
        "uriTemplate": "file:///{path}",
        "name": "Project Files",
        "description": "Access files in the project directory",
        "mimeType": "application/octet-stream"
      }
    ]
  }
}
```

----------------------------------------

TITLE: MCP: List Resource Templates Request
DESCRIPTION: Clients send this JSON-RPC request to discover available resource templates. These templates allow servers to expose parameterized resources using URI templates.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/resources

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 3,
  "method": "resources/templates/list"
}
```

----------------------------------------

TITLE: MCP: Resumability and Redelivery with SSE and HTTP Headers
DESCRIPTION: Describes how servers can support resuming broken connections and redelivering lost messages using Server-Sent Events (SSE) 'id' fields and the HTTP 'Last-Event-ID' header. It specifies uniqueness requirements for event IDs and client/server behavior for replaying messages.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/basic/transports

LANGUAGE: APIDOC
CODE:
```
Resumability and Redelivery Protocol:
  1. Server Event ID Assignment:
     - Servers MAY attach an 'id' field to SSE events.
     - If present, the ID MUST be globally unique across all streams within that session or with that specific client.
  2. Client Resumption Request:
     - Client SHOULD issue an HTTP GET to the MCP endpoint.
     - Client MUST include the 'Last-Event-ID' header to indicate the last received event ID.
  3. Server Replay Behavior:
     - Server MAY use 'Last-Event-ID' to replay messages sent after the last event ID on the disconnected stream.
     - Server MUST NOT replay messages delivered on a different stream.
  Note: Event IDs are assigned per-stream as a cursor.
```

----------------------------------------

TITLE: JSON-RPC Notification for Tool List Changes
DESCRIPTION: Servers that support the 'listChanged' capability should send this JSON-RPC notification to clients when the set of available tools has been updated, prompting clients to refresh their tool capabilities.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/tools

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "method": "notifications/tools/list_changed"
}
```

----------------------------------------

TITLE: JSON: Text Content Type for PromptMessage
DESCRIPTION: Represents plain text messages within a prompt. This is the most common content type used for natural language interactions and forms the basic textual component of a message.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/prompts

LANGUAGE: APIDOC
CODE:
```
{
  "type": "text",
  "text": "The text content of the message"
}
```

----------------------------------------

TITLE: API Definition: Text Content Type for Messages
DESCRIPTION: Represents plain text messages within a prompt's content. This is the most common content type used for natural language interactions.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/prompts

LANGUAGE: APIDOC
CODE:
```
Text Content:
  type: "text"
  text: "The text content of the message"
```

LANGUAGE: JSON
CODE:
```
{
  "type": "text",
  "text": "The text content of the message"
}
```

----------------------------------------

TITLE: Default Endpoint Paths for Servers Without Metadata Discovery
DESCRIPTION: For MCP servers that do not implement OAuth 2.0 Authorization Server Metadata, clients must use these default endpoint paths relative to the authorization base URL. Clients must first attempt discovery before falling back to these default paths.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/basic/authorization

LANGUAGE: APIDOC
CODE:
```
| Endpoint | Default Path | Description |
| --- | --- | --- |
| Authorization Endpoint | /authorize | Used for authorization requests |
| Token Endpoint | /token | Used for token exchange & refresh |
| Registration Endpoint | /register | Used for dynamic client registration |

For example, with an MCP server hosted at https://api.example.com/v1/mcp, the default endpoints would be:
* https://api.example.com/authorize
* https://api.example.com/token
* https://api.example.com/register
```

----------------------------------------

TITLE: Deriving Authorization Base URL from MCP Server URL
DESCRIPTION: The authorization base URL is determined by discarding any path component from the MCP server URL, ensuring authorization endpoints are consistently located at the root level of the domain hosting the MCP server.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/basic/authorization

LANGUAGE: APIDOC
CODE:
```
If the MCP server URL is https://api.example.com/v1/mcp, then:
* The authorization base URL is https://api.example.com
* The metadata endpoint MUST be at https://api.example.com/.well-known/oauth-authorization-server
```

----------------------------------------

TITLE: Configure Anthropic API Key with .NET User Secrets
DESCRIPTION: This snippet shows how to initialize .NET user secrets and set the `ANTHROPIC_API_KEY` securely. User secrets are a development-time tool for storing sensitive information outside of source control, ensuring API keys are not hardcoded or committed.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: shell
CODE:
```
dotnet user-secrets init
dotnet user-secrets set "ANTHROPIC_API_KEY" "<your key here>"
```

----------------------------------------

TITLE: Protocol Capability Negotiation and Definitions
DESCRIPTION: Details the optional protocol features available during a session, categorizing client and server capabilities and their descriptions, including sub-capabilities.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/basic/lifecycle

LANGUAGE: APIDOC
CODE:
```
Key Capabilities:
  Category: Client
    Capability: roots
      Description: Ability to provide filesystem roots
    Capability: sampling
      Description: Support for LLM sampling requests
    Capability: experimental
      Description: Describes support for non-standard experimental features
  Category: Server
    Capability: prompts
      Description: Offers prompt templates
    Capability: resources
      Description: Provides readable resources
    Capability: tools
      Description: Exposes callable tools
    Capability: logging
      Description: Emits structured log messages
    Capability: completions
      Description: Supports argument autocompletion
    Capability: experimental
      Description: Describes support for non-standard experimental features

Sub-capabilities:
  listChanged: Support for list change notifications (for prompts, resources, and tools)
  subscribe: Support for subscribing to individual items’ changes (resources only)
```

----------------------------------------

TITLE: Implement Interactive Chat Loop (Kotlin)
DESCRIPTION: Creates an interactive command-line chat loop for the MCP client. It continuously prompts the user for queries, processes them using the `processQuery` function, and prints the AI's response. The loop continues until the user types 'quit'.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: Kotlin
CODE:
```
suspend fun chatLoop() {
    println("\nMCP Client Started!")
    println("Type your queries or 'quit' to exit.")

    while (true) {
        print("\nQuery: ")
        val message = readLine() ?: break
        if (message.lowercase() == "quit") break
        val response = processQuery(message)
        println("\n$response")
    }
}
```

----------------------------------------

TITLE: Declare Model Context Protocol Completion Capability
DESCRIPTION: Servers supporting the Model Context Protocol's completion feature must declare the 'completions' capability in their configuration. This JSON snippet shows the required structure for advertising this capability.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/utilities/completion

LANGUAGE: JSON
CODE:
```
{
  "capabilities": {
    "completions": {}
  }
}
```

----------------------------------------

TITLE: Model Context Protocol CompleteResult Data Type
DESCRIPTION: Defines the structure of the `CompleteResult` object returned by the server, containing completion values, total matches, and a flag for more results.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/utilities/completion

LANGUAGE: APIDOC
CODE:
```
CompleteResult:
  completion:
    values: Array of suggestions (max 100)
    total: Optional total matches
    hasMore: Additional results flag
```

----------------------------------------

TITLE: API Reference: CompleteResult Object Structure
DESCRIPTION: Defines the structure of the `CompleteResult` object, which encapsulates the results of a completion request. It includes an array of suggestions, an optional total count of matches, and a boolean flag indicating if more results are available beyond the current set.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/utilities/completion

LANGUAGE: APIDOC
CODE:
```
CompleteResult:
  completion: object
    values: array (max 100 suggestions)
    total: number (optional total matches)
    hasMore: boolean (additional results flag)
```

----------------------------------------

TITLE: Receiving Completions: `completion/complete` JSON-RPC Response
DESCRIPTION: Servers respond to a `completion/complete` request with an array of completion values. The response includes the suggested values, an optional total count, and a boolean indicating if more results are available.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/utilities/completion

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "completion": {
      "values": ["python", "pytorch", "pyside"],
      "total": 10,
      "hasMore": true
    }
  }
}
```

----------------------------------------

TITLE: Model Context Protocol roots/list Response
DESCRIPTION: The response to a `roots/list` request, containing an array of root definitions. Each root includes a `uri` (file:// URI) and an optional `name`.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/client/roots

LANGUAGE: APIDOC
CODE:
```
Response:
  jsonrpc: "2.0"
  id: 1
  result:
    roots: [
      {
        uri: "file:///home/user/projects/myproject",
        name: "My Project"
      }
    ]
```

----------------------------------------

TITLE: JSON Structure for Audio Tool Result Content
DESCRIPTION: Represents an audio-based content item within a tool result. It includes the content type as 'audio', the base64-encoded audio data, and its corresponding MIME type (e.g., 'audio/wav').
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/tools

LANGUAGE: JSON
CODE:
```
{
  "type": "audio",
  "data": "base64-encoded-audio-data",
  "mimeType": "audio/wav"
}
```

----------------------------------------

TITLE: Send Progress Notification Message
DESCRIPTION: The receiver of a request can send progress notifications using the 'notifications/progress' method. These messages include the original 'progressToken', the current 'progress' value (which must increase), an optional 'total' value, and an optional human-readable 'message'.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/basic/utilities/progress

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "method": "notifications/progress",
  "params": {
    "progressToken": "abc123",
    "progress": 50,
    "total": 100,
    "message": "Reticulating splines..."
  }
}
```

----------------------------------------

TITLE: Configure Claude for Desktop with Spring AI MCP Weather Server
DESCRIPTION: JSON configuration snippet for `claude_desktop_config.json` to register the Spring AI MCP weather server with Claude for Desktop. It specifies the server name, command to launch the JAR, and arguments, including the absolute path to the server JAR file, with variations for MacOS/Linux and Windows.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: JSON
CODE:
```
{
  "mcpServers": {
    "spring-ai-mcp-weather": {
      "command": "java",
      "args": [
        "-Dspring.ai.mcp.server.stdio=true",
        "-jar",
        "/ABSOLUTE/PATH/TO/PARENT/FOLDER/mcp-weather-stdio-server-0.0.1-SNAPSHOT.jar"
      ]
    }
  }
}
```

LANGUAGE: JSON
CODE:
```
{
  "mcpServers": {
    "spring-ai-mcp-weather": {
      "command": "java",
      "args": [
        "-Dspring.ai.mcp.server.transport=STDIO",
        "-jar",
        "C:\\ABSOLUTE\\PATH\\TO\\PARENT\\FOLDER\\weather\\mcp-weather-stdio-server-0.0.1-SNAPSHOT.jar"
      ]
    }
  }
}
```

----------------------------------------

TITLE: JSON Schema: Boolean Type Definition
DESCRIPTION: This JSON Schema snippet defines a boolean property, illustrating how to set a "default" value. Boolean schemas are used for true/false inputs.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client/elicitation

LANGUAGE: json
CODE:
```
{
  "type": "boolean",
  "title": "Display Name",
  "description": "Description text",
  "default": false
}
```

----------------------------------------

TITLE: McpSchema.LoggingLevel Enumeration
DESCRIPTION: Defines the supported logging severity levels within the Model Context Protocol (MCP) SDK, ordered by increasing severity. Clients can use these levels to filter incoming log messages from the server.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-server

LANGUAGE: APIDOC
CODE:
```
McpSchema.LoggingLevel:
  DEBUG: 0
  INFO: 1
  NOTICE: 2
  WARNING: 3
  ERROR: 4
  CRITICAL: 5
  ALERT: 6
  EMERGENCY: 7
```

----------------------------------------

TITLE: Convert JsonObject to JsonValue for Anthropic (Kotlin)
DESCRIPTION: Provides a helper extension function for `JsonObject` to convert itself into an Anthropic `JsonValue`. It uses `ObjectMapper` to parse the JSON string representation into a `JsonNode` and then converts it to `JsonValue`.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: Kotlin
CODE:
```
private fun JsonObject.toJsonValue(): JsonValue {
    val mapper = ObjectMapper()
    val node = mapper.readTree(this.toString())
    return JsonValue.fromJsonNode(node)
}
```

----------------------------------------

TITLE: Text Resource Content Data Type Example
DESCRIPTION: An example structure for resource content when the content is text-based. It includes the resource's URI, name, title, MIME type, and the actual text content.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/resources

LANGUAGE: JSON
CODE:
```
{
  "uri": "file:///example.txt",
  "name": "example.txt",
  "title": "Example Text File",
  "mimeType": "text/plain",
  "text": "Resource content"
}
```

----------------------------------------

TITLE: Define and Register Async Completion Specification in MCP Server
DESCRIPTION: Illustrates how to create an asynchronous completion specification using McpServerFeatures.AsyncCompletionSpecification for code_review prompts, returning a Mono result, and integrating it into an McpServer instance.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-server

LANGUAGE: Java
CODE:
```
// Async prompt specification
var asyncCompletionSpecification = new McpServerFeatures.AsyncCompletionSpecification(
			new McpSchema.PromptReference("code_review"), (exchange, request) -> {

        // completion implementation ...

        return Mono.just(new McpSchema.CompleteResult(
            new CompleteResult.CompleteCompletion(
              List.of("python", "pytorch", "pyside"),
              10, // total
              false // hasMore
            )));
      }
);

// Create a async server with completion capabilities
var mcpServer = McpServer.async(mcpServerTransportProvider)
  .capabilities(ServerCapabilities.builder()
    .completions() // enable completions support
      // ...
    .build())
  // ...
  .completions(new McpServerFeatures.AsyncCompletionSpecification( // register completion specification
      new McpSchema.PromptReference("code_review"), asyncCompletionSpecification))
  .build();
```

----------------------------------------

TITLE: Declare Logging Capability in MCP
DESCRIPTION: Servers that emit log message notifications must declare the 'logging' capability within their protocol capabilities object to indicate support for the logging feature.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/utilities/logging

LANGUAGE: JSON
CODE:
```
{
  "capabilities": {
    "logging": {}
  }
}
```

----------------------------------------

TITLE: Model Context Protocol Root Data Type
DESCRIPTION: Defines the structure of a single root within the Model Context Protocol. A root specifies a filesystem boundary accessible to the server, identified by a 'file://' URI and an optional human-readable name.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/client

LANGUAGE: APIDOC
CODE:
```
Root:
  uri: string (required)
    - Unique identifier for the root.
    - MUST be a 'file://' URI.
  name: string (optional)
    - Human-readable name for display purposes.
```

----------------------------------------

TITLE: JSON-RPC Error Response Example for Unsupported Roots
DESCRIPTION: This JSON object illustrates a standard JSON-RPC error response. It specifically shows a '-32601' (Method not found) error, indicating that the client does not support 'roots', providing a message and additional data for diagnostic purposes.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -32601,
    "message": "Roots not supported",
    "data": {
      "reason": "Client does not have roots capability"
    }
  }
}
```

----------------------------------------

TITLE: APIDOC: Root Data Type
DESCRIPTION: Defines the structure of a 'Root' object, which represents a filesystem boundary exposed by the client. It includes a URI and an optional human-readable name.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client

LANGUAGE: APIDOC
CODE:
```
Root:
  uri: string
    Description: Unique identifier for the root. MUST be a 'file://' URI in the current specification.
  name: string (optional)
    Description: Human-readable name for display purposes.
```

----------------------------------------

TITLE: APIDOC: Model Context Protocol Operation Phase
DESCRIPTION: Describes the main operational phase where client and server exchange messages, emphasizing adherence to negotiated protocol version and capabilities.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/basic/lifecycle

LANGUAGE: APIDOC
CODE:
```
Operation Phase:
  Client and server exchange messages according to negotiated capabilities.
  Both parties SHOULD:
    - Respect the negotiated protocol version.
    - Only use capabilities that were successfully negotiated.
```

----------------------------------------

TITLE: Model Context Protocol Completion Results Structure
DESCRIPTION: Describes the structure of the array returned by servers for completion results, including maximum items, total count, and a flag for additional results.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/utilities/completion

LANGUAGE: APIDOC
CODE:
```
Completion Results:
  - Maximum 100 items per response
  - Optional total number of available matches
  - Boolean indicating if additional results exist
```

----------------------------------------

TITLE: Model Context Protocol Reference Types
DESCRIPTION: Defines the types of references supported by the protocol for completion requests, including prompt names and resource URIs.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/utilities/completion

LANGUAGE: APIDOC
CODE:
```
Reference Types:
  ref/prompt:
    description: References a prompt by name
    example: {"type": "ref/prompt", "name": "code_review"}
  ref/resource:
    description: References a resource URI
    example: {"type": "ref/resource", "uri": "file:///{path}"}
```

----------------------------------------

TITLE: Model Context Protocol Notification Message Structure
DESCRIPTION: Defines the structure for notifications sent within the Model Context Protocol. Notifications do not expect a response and therefore must not include an ID. They contain a method name and optional parameters.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/basic/messages

LANGUAGE: APIDOC
CODE:
```
{
  jsonrpc: "2.0";
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

----------------------------------------

TITLE: JSON Structure for Model Preferences in MCP
DESCRIPTION: Illustrates how servers express model preferences in Model Context Protocol using a combination of model hints (preferred models/families) and normalized capability priorities (cost, speed, intelligence) to guide client model selection.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client/sampling

LANGUAGE: json
CODE:
```
{
  "hints": [
    { "name": "claude-3-sonnet" },
    { "name": "claude" }
  ],
  "costPriority": 0.3,
  "speedPriority": 0.8,
  "intelligencePriority": 0.5
}
```

----------------------------------------

TITLE: Helper Functions for NWS API Interaction and Data Formatting
DESCRIPTION: This section provides helper functions for interacting with the National Weather Service (NWS) API. It includes `makeNWSRequest` for fetching data from the API and `formatAlert` for structuring alert information into a readable string. It also defines several TypeScript interfaces to type the NWS API responses for alerts, points, and forecasts.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: typescript
CODE:
```
// Helper function for making NWS API requests
async function makeNWSRequest<T>(url: string): Promise<T | null> {
  const headers = {
    "User-Agent": USER_AGENT,
    Accept: "application/geo+json",
  };

  try {
    const response = await fetch(url, { headers });
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return (await response.json()) as T;
  } catch (error) {
    console.error("Error making NWS request:", error);
    return null;
  }
}

interface AlertFeature {
  properties: {
    event?: string;
    areaDesc?: string;
    severity?: string;
    status?: string;
    headline?: string;
  };
}

// Format alert data
function formatAlert(feature: AlertFeature): string {
  const props = feature.properties;
  return [
    `Event: ${props.event || "Unknown"}`,
    `Area: ${props.areaDesc || "Unknown"}`,
    `Severity: ${props.severity || "Unknown"}`,
    `Status: ${props.status || "Unknown"}`,
    `Headline: ${props.headline || "No headline"}`,
    "---",
  ].join("\n");
}

interface ForecastPeriod {
  name?: string;
  temperature?: number;
  temperatureUnit?: string;
  windSpeed?: string;
  windDirection?: string;
  shortForecast?: string;
}

interface AlertsResponse {
  features: AlertFeature[];
}

interface PointsResponse {
  properties: {
    forecast?: string;
  };
}

interface ForecastResponse {
  properties: {
    periods: ForecastPeriod[];
  };
}
```

----------------------------------------

TITLE: Declare Roots Capability for MCP Client Initialization
DESCRIPTION: Clients supporting the 'roots' feature in the Model Context Protocol must declare the 'roots' capability during initialization. The 'listChanged' property indicates whether the client will send notifications when the list of roots is modified.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client

LANGUAGE: JSON
CODE:
```
{
  "capabilities": {
    "roots": {
      "listChanged": true
    }
  }
}
```

----------------------------------------

TITLE: Requesting List of Roots from MCP Server
DESCRIPTION: Servers can retrieve the current list of exposed filesystem roots by sending a 'roots/list' request to the client. This is a standard JSON-RPC 2.0 request with a unique ID.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "roots/list"
}
```

----------------------------------------

TITLE: Requesting Progress Updates with progressToken
DESCRIPTION: When a party wants to receive progress updates for a request, it includes a 'progressToken' in the request metadata. Progress tokens must be a string or integer value and unique across all active requests.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/basic/utilities/progress

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "some_method",
  "params": {
    "_meta": {
      "progressToken": "abc123"
    }
  }
}
```

----------------------------------------

TITLE: Model Context Protocol: Image Content Type Schema
DESCRIPTION: Defines the schema for image-based content within Model Context Protocol messages, including the 'type' as 'image', base64-encoded 'data', and the 'mimeType' of the image.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/client/sampling

LANGUAGE: APIDOC
CODE:
```
{
  "type": "image",
  "data": "base64-encoded-image-data",
  "mimeType": "image/jpeg"
}
```

----------------------------------------

TITLE: Response for Listing Available Tools in Model Context Protocol
DESCRIPTION: The server's response to a 'tools/list' request includes a list of available tools, each with a name, title, description, and input schema. It also provides a 'nextCursor' for pagination if more tools are available.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/tools

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "tools": [
      {
        "name": "get_weather",
        "title": "Weather Information Provider",
        "description": "Get current weather information for a location",
        "inputSchema": {
          "type": "object",
          "properties": {
            "location": {
              "type": "string",
              "description": "City name or zip code"
            }
          },
          "required": ["location"]
        }
      }
    ],
    "nextCursor": "next-page-cursor"
  }
}
```

----------------------------------------

TITLE: MCP API Response for Listing Prompts
DESCRIPTION: The server's response to a 'prompts/list' request contains an array of available prompts, each with a 'name', 'description', and 'arguments' array. Arguments specify required parameters for the prompt. A 'nextCursor' is provided for fetching subsequent pages of results.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/prompts

LANGUAGE: APIDOC
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "prompts": [
      {
        "name": "code_review",
        "description": "Asks the LLM to analyze code quality and suggest improvements",
        "arguments": [
          {
            "name": "code",
            "description": "The code to review",
            "required": true
          }
        ]
      }
    ],
    "nextCursor": "next-page-cursor"
  }
}
```

----------------------------------------

TITLE: Example Roots for Multiple Repositories
DESCRIPTION: This JSON snippet illustrates how multiple repository roots can be defined as an array of root objects, allowing a server access to several distinct filesystem locations.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/client/roots

LANGUAGE: JSON
CODE:
```
[
  {
    "uri": "file:///home/user/repos/frontend",
    "name": "Frontend Repository"
  },
  {
    "uri": "file:///home/user/repos/backend",
    "name": "Backend Repository"
  }
]
```

----------------------------------------

TITLE: Model Context Protocol Error Handling
DESCRIPTION: Servers should return standard JSON-RPC error codes for common logging-related failures, such as invalid log levels or internal configuration issues, to ensure consistent error reporting.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/utilities/logging

LANGUAGE: APIDOC
CODE:
```
Standard JSON-RPC Errors for Logging:
- Invalid log level: -32602 (Invalid params)
- Configuration errors: -32603 (Internal error)
```

----------------------------------------

TITLE: Define and Register Sync Completion Specification in MCP Server
DESCRIPTION: Demonstrates how to create a synchronous completion specification using McpServerFeatures.SyncCompletionSpecification for code_review prompts and integrate it into an McpServer instance, enabling completion capabilities.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-server

LANGUAGE: Java
CODE:
```
// Sync completion specification
var syncCompletionSpecification = new McpServerFeatures.SyncCompletionSpecification(
			new McpSchema.PromptReference("code_review"), (exchange, request) -> {

        // completion implementation ...

        return new McpSchema.CompleteResult(
            new CompleteResult.CompleteCompletion(
              List.of("python", "pytorch", "pyside"),
              10, // total
              false // hasMore
            ));
      }
);

// Create a sync server with completion capabilities
var mcpServer = McpServer.sync(mcpServerTransportProvider)
  .capabilities(ServerCapabilities.builder()
    .completions() // enable completions support
      // ...
    .build())
  // ...
  .completions(new McpServerFeatures.SyncCompletionSpecification( // register completion specification
      new McpSchema.PromptReference("code_review"), syncCompletionSpecification))
  .build();
```

----------------------------------------

TITLE: APIDOC: Prompt Data Type Definition
DESCRIPTION: Defines the structure of a prompt, including its unique identifier, optional human-readable title and description, and a list of arguments for customization. This structure is used when defining prompts within the protocol.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/prompts

LANGUAGE: APIDOC
CODE:
```
Prompt:
  name: string
    Unique identifier for the prompt.
  title: string (optional)
    Human-readable name of the prompt for display purposes.
  description: string (optional)
    Human-readable description.
  arguments: array (optional)
    List of arguments for customization.
```

----------------------------------------

TITLE: API: Context Inclusion Parameters
DESCRIPTION: Describes the `includeContext` parameter for specifying what Model Context Protocol (MCP) context to include in LLM requests, with options for no context, current server context, or all connected server contexts.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/sampling

LANGUAGE: APIDOC
CODE:
```
includeContext: string
  "none": No additional context
  "thisServer": Include context from the requesting server
  "allServers": Include context from all connected MCP servers
```

----------------------------------------

TITLE: Tool Result Text Content Format
DESCRIPTION: JSON structure for representing plain text content within a tool result. It specifies the content type as 'text' and includes the actual text string.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/tools

LANGUAGE: json
CODE:
```
{
  "type": "text",
  "text": "Tool result text"
}
```

----------------------------------------

TITLE: Model Context Protocol Ping Request Message Format
DESCRIPTION: Defines the standard JSON-RPC request structure for initiating a ping within the Model Context Protocol. This request includes the JSON-RPC version, a unique identifier, and the 'ping' method name, with no additional parameters required.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/basic/utilities/ping

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": "123",
  "method": "ping"
}
```

----------------------------------------

TITLE: Example Root URI Formats
DESCRIPTION: Illustrates common URI formats that can be used as roots in the Model Context Protocol, including local file paths and HTTP URLs.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/roots

LANGUAGE: Text
CODE:
```
file:///home/user/projects/myapp
https://api.example.com/v1
```

----------------------------------------

TITLE: Verify Java Installation
DESCRIPTION: This shell command is used to check the installed version of Java on your system. It's a crucial step to ensure that the required Java 17 or higher is available before proceeding with project setup.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: Shell
CODE:
```
java --version
```

----------------------------------------

TITLE: Model Context Protocol: resources/list Response
DESCRIPTION: The response to a `resources/list` request contains a list of available resources and an optional `nextCursor` for subsequent pagination requests. Each resource includes its URI, name, description, and MIME type.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/resources

LANGUAGE: APIDOC
CODE:
```
resources/list Response:
  Result:
    resources: array of objects
      - uri:
          Type: string
          Description: Unique identifier for the resource.
      - name:
          Type: string
          Description: Display name of the resource.
      - description:
          Type: string
          Description: A brief description of the resource.
      - mimeType:
          Type: string
          Description: The MIME type of the resource content.
    nextCursor:
      Type: string
      Description: An optional cursor for fetching the next page of results.
  JSON-RPC Fields:
    jsonrpc: "2.0"
    id: number
```

----------------------------------------

TITLE: Define Text Content for Sampling Messages
DESCRIPTION: This JSON structure specifies the format for text-based content within Model Context Protocol sampling messages. It defines the content type as 'text' and provides the actual string content of the message.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client/sampling

LANGUAGE: JSON
CODE:
```
{
  "type": "text",
  "text": "The message content"
}
```

----------------------------------------

TITLE: Send Log Message to Clients (Java)
DESCRIPTION: Demonstrates how a server sends a structured log message to clients using `server.loggingNotification`. It specifies the log level (e.g., INFO), a custom logger name, and the data to be logged. Clients can control the minimum logging level they receive via `mcpClient.setLoggingLevel(level)`.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-server

LANGUAGE: Java
CODE:
```
// Send a log message to clients
server.loggingNotification(LoggingMessageNotification.builder()
    .level(LoggingLevel.INFO)
    .logger("custom-logger")
    .data("Custom log message")
    .build());
```

----------------------------------------

TITLE: Declare Model Context Protocol Resources Capability with Subscribe Only
DESCRIPTION: This example shows a server declaring the 'resources' capability with only the 'subscribe' feature enabled. Clients can subscribe to individual resource changes, but the server will not emit notifications when the overall list of available resources changes.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/resources

LANGUAGE: JSON
CODE:
```
{
  "capabilities": {
    "resources": {
      "subscribe": true
    }
  }
}
```

----------------------------------------

TITLE: Clean Up Client Resources in Python
DESCRIPTION: This asynchronous method is responsible for properly cleaning up resources used by the MCP client, specifically closing the AsyncExitStack to ensure all managed contexts are exited gracefully.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: python
CODE:
```
async def cleanup(self):
    """Clean up resources"""
    await self.exit_stack.aclose()
```

----------------------------------------

TITLE: Example MCP Root Definitions for Multiple Repositories
DESCRIPTION: This JSON array illustrates how multiple 'Root' objects can be defined, each representing a distinct repository or directory. Each root specifies its URI and an optional name.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client

LANGUAGE: JSON
CODE:
```
[
  {
    "uri": "file:///home/user/repos/frontend",
    "name": "Frontend Repository"
  },
  {
    "uri": "file:///home/user/repos/backend",
    "name": "Backend Repository"
  }
]
```

----------------------------------------

TITLE: Example Roots: Multiple Repositories
DESCRIPTION: An example demonstrating how multiple roots can be defined to expose different repositories or directories simultaneously to the server.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client/roots

LANGUAGE: JSON
CODE:
```
[
  {
    "uri": "file:///home/user/repos/frontend",
    "name": "Frontend Repository"
  },
  {
    "uri": "file:///home/user/repos/backend",
    "name": "Backend Repository"
  }
]
```

----------------------------------------

TITLE: Declare MCP Resources Capability with No Features
DESCRIPTION: Example JSON for declaring the 'resources' capability without supporting any optional features. The 'resources' object is empty, indicating no subscriptions or list change notifications are provided.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/resources

LANGUAGE: JSON
CODE:
```
{
  "capabilities": {
    "resources": {}
  }
}
```

----------------------------------------

TITLE: Add Kotlin Serialization and Shadow Plugins to Gradle
DESCRIPTION: Shows how to include the `kotlin-plugin-serialization` and `com.github.johnrengelman.shadow` plugins in both Kotlin DSL (`build.gradle.kts`) and Groovy DSL (`build.gradle`) build scripts for an MCP server project.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: Gradle Kotlin DSL
CODE:
```
plugins {
    kotlin("plugin.serialization") version "your_version_of_kotlin"
    id("com.github.johnrengelman.shadow") version "8.1.1"
}
```

LANGUAGE: Gradle Groovy DSL
CODE:
```
plugins {
    kotlin("plugin.serialization") version "your_version_of_kotlin"
    id("com.github.johnrengelman.shadow") version "8.1.1"
}
```

----------------------------------------

TITLE: MCP Operations Supporting Pagination
DESCRIPTION: This section lists the Model Context Protocol (MCP) operations that support pagination for handling large result sets. Clients can use cursors with these methods to retrieve data in chunks.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/utilities/pagination

LANGUAGE: APIDOC
CODE:
```
resources/list: List available resources
resources/templates/list: List resource templates
prompts/list: List available prompts
tools/list: List available tools
```

----------------------------------------

TITLE: Set Up Java/Gradle Environment for MCP Server
DESCRIPTION: Provides shell commands to verify Java installation and initialize a new Kotlin project using Gradle for an MCP server. This includes creating a project directory and running the Gradle initialization wizard.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: Shell
CODE:
```
java --version
```

LANGUAGE: Shell
CODE:
```
# Create a new directory for our project
mkdir weather
cd weather

# Initialize a new kotlin project
gradle init
```

----------------------------------------

TITLE: List Resource Templates API Request and Response
DESCRIPTION: Servers can expose parameterized resources using URI templates. Clients can request a list of available resource templates via the `resources/templates/list` method. Arguments for these templates may be auto-completed through the completion API.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/resources

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 3,
  "method": "resources/templates/list"
}
```

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 3,
  "result": {
    "resourceTemplates": [
      {
        "uriTemplate": "file:///{path}",
        "name": "Project Files",
        "title": "📁 Project Files",
        "description": "Access files in the project directory",
        "mimeType": "application/octet-stream"
      }
    ]
  }
}
```

----------------------------------------

TITLE: Weather API Helper Functions and Data Models
DESCRIPTION: This Kotlin code provides extension functions for HttpClient to interact with the National Weather Service API, fetching weather forecasts and alerts. It also defines serializable data classes (Points, Forecast, Alert) to parse the API responses, facilitating structured data handling for weather information.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: Kotlin
CODE:
```
suspend fun HttpClient.getForecast(latitude: Double, longitude: Double): List<String> {
    val points = this.get("/points/$latitude,$longitude").body<Points>()
    val forecast = this.get(points.properties.forecast).body<Forecast>()
    return forecast.properties.periods.map { period ->
        """
            ${period.name}:
            Temperature: ${period.temperature} ${period.temperatureUnit}
            Wind: ${period.windSpeed} ${period.windDirection}
            Forecast: ${period.detailedForecast}
        """.trimIndent()
    }
}

suspend fun HttpClient.getAlerts(state: String): List<String> {
    val alerts = this.get("/alerts/active/area/$state").body<Alert>()
    return alerts.features.map { feature ->
        """
            Event: ${feature.properties.event}
            Area: ${feature.properties.areaDesc}
            Severity: ${feature.properties.severity}
            Description: ${feature.properties.description}
            Instruction: ${feature.properties.instruction}
        """.trimIndent()
    }
}

@Serializable
data class Points(
    val properties: Properties
) {
    @Serializable
    data class Properties(val forecast: String)
}

@Serializable
data class Forecast(
    val properties: Properties
) {
    @Serializable
    data class Properties(val periods: List<Period>)

    @Serializable
    data class Period(
        val number: Int, val name: String, val startTime: String, val endTime: String,
        val isDaytime: Boolean, val temperature: Int, val temperatureUnit: String,
        val temperatureTrend: String, val probabilityOfPrecipitation: JsonObject,
        val windSpeed: String, val windDirection: String,
        val shortForecast: String, val detailedForecast: String,
    )
}

@Serializable
data class Alert(
    val features: List<Feature>
) {
    @Serializable
    data class Feature(
        val properties: Properties
    )

    @Serializable
    data class Properties(
        val event: String, val areaDesc: String, val severity: String,
        val description: String, val instruction: String?,
    )
}
```

----------------------------------------

TITLE: Declare MCP Resources Capability with Subscribe Only
DESCRIPTION: Example JSON showing the declaration of the 'resources' capability with only the 'subscribe' feature enabled. Clients can subscribe to individual resource changes, but the server will not notify of overall list changes.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/resources

LANGUAGE: JSON
CODE:
```
{
  "capabilities": {
    "resources": {
      "subscribe": true
    }
  }
}
```

----------------------------------------

TITLE: Declare Resource Capability with Subscription Only
DESCRIPTION: Illustrates how a server declares support for the Model Context Protocol's resource capability, enabling only the subscription feature for clients to be notified of changes to individual resources.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/resources

LANGUAGE: JSON
CODE:
```
{
  "capabilities": {
    "resources": {
      "subscribe": true 
    }
  }
}
```

----------------------------------------

TITLE: Handle Simple Text Elicitation Response
DESCRIPTION: Clients respond to an 'elicitation/create' request with the user's input. The response includes the 'action' taken (e.g., 'accept') and the 'content' containing the data provided by the user, conforming to the requested JSON schema. This example shows a successful response with a provided username.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client/elicitation

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "action": "accept",
    "content": {
      "name": "octocat"
    }
  }
}
```

----------------------------------------

TITLE: Binary Resource Content Format
DESCRIPTION: Defines the structure for binary resource content, including its URI, MIME type, and the base64-encoded binary data.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/resources

LANGUAGE: json
CODE:
```
{
  "uri": "file:///example.png",
  "mimeType": "image/png",
  "blob": "base64-encoded-data"
}
```

----------------------------------------

TITLE: Model Context Protocol Completion Reference Types
DESCRIPTION: The protocol supports two types of completion references: `ref/prompt` for prompts by name and `ref/resource` for resource URIs. These types specify what is being completed and are used within the `completion/complete` request.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/utilities/completion

LANGUAGE: APIDOC
CODE:
```
Type: ref/prompt
  Description: References a prompt by name
  Example: {"type": "ref/prompt", "name": "code_review"}
Type: ref/resource
  Description: References a resource URI
  Example: {"type": "ref/resource", "uri": "file:///{path}"}
```

----------------------------------------

TITLE: Model Context Protocol Ping Response Message Format
DESCRIPTION: Specifies the required JSON-RPC response structure for a ping request. The receiver must respond promptly with an empty result object, confirming the connection is alive and responsive according to protocol behavior requirements.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/basic/utilities/ping

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": "123",
  "result": {}
}
```

----------------------------------------

TITLE: Configure package.json for TypeScript Module and Build
DESCRIPTION: This JSON snippet shows how to modify the `package.json` file to configure a TypeScript project. It sets the `type` to 'module', defines a `bin` entry for the 'weather' executable, and adds a `build` script that compiles TypeScript and makes the output executable. It also specifies that only the 'build' directory should be included in published packages.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: json
CODE:
```
{
  "type": "module",
  "bin": {
    "weather": "./build/index.js"
  },
  "scripts": {
    "build": "tsc && chmod 755 build/index.js"
  },
  "files": ["build"]
}
```

----------------------------------------

TITLE: MCP HTTP with Server-Sent Events (SSE) Transport Specification
DESCRIPTION: Specifies the HTTP with SSE transport for Model Context Protocol, where the server operates independently, handles multiple client connections, and requires specific endpoints for message exchange, along with critical security considerations.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/basic/transports

LANGUAGE: APIDOC
CODE:
```
HTTP with SSE Transport:
  - Server operates as an independent process, handles multiple client connections.

  Security Warning:
    1. Servers MUST validate the 'Origin' header on all incoming connections to prevent DNS rebinding attacks.
    2. When running locally, servers SHOULD bind only to localhost (127.0.0.1) rather than all network interfaces (0.0.0.0).
    3. Servers SHOULD implement proper authentication for all connections.

  Endpoints:
    - Server MUST provide two endpoints:
      1. An SSE endpoint: for clients to establish a connection and receive messages from the server.
      2. A regular HTTP POST endpoint: for clients to send messages to the server.

  Message Exchange:
    - When a client connects, the server MUST send an 'endpoint' event containing a URI for sending messages.
    - All subsequent client messages MUST be sent as HTTP POST requests to this endpoint.
    - Server messages are sent as SSE 'message' events, with content encoded as JSON in event data.
```

----------------------------------------

TITLE: Initialize TypeScript Project on MacOS/Linux
DESCRIPTION: Provides a sequence of shell commands to create a new project directory, initialize an npm project, install necessary runtime and development dependencies, and create the main TypeScript source file.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: bash
CODE:
```
# Create project directory
mkdir mcp-client-typescript
cd mcp-client-typescript

# Initialize npm project
npm init -y

# Install dependencies
npm install @anthropic-ai/sdk @modelcontextprotocol/sdk dotenv

# Install dev dependencies
npm install -D @types/node typescript

# Create source file
touch index.ts
```

----------------------------------------

TITLE: Setting Up MCP Client Environment with uv
DESCRIPTION: Steps to initialize a new Python project, create a virtual environment using `uv`, and activate it. This is the prerequisite setup for developing and running the MCP client.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: Shell
CODE:
```
# Create project directory
uv init mcp-client
cd mcp-client

# Create virtual environment
uv venv

# Activate virtual environment
# On Windows:
.venv\\Scripts\\activate
```

----------------------------------------

TITLE: JSON-RPC Request for Structured Data Elicitation
DESCRIPTION: This JSON-RPC request initiates a structured data elicitation, asking the client for contact information. It includes a "requestedSchema" field defining the expected data structure using a subset of JSON Schema.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client/elicitation

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "elicitation/create",
  "params": {
    "message": "Please provide your contact information",
    "requestedSchema": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Your full name"
        },
        "email": {
          "type": "string",
          "format": "email",
          "description": "Your email address"
        },
        "age": {
          "type": "number",
          "minimum": 18,
          "description": "Your age"
        }
      },
      "required": ["name", "email"]
    }
  }
}
```

----------------------------------------

TITLE: Declare Model Context Protocol Resources Capability with List Changed Only
DESCRIPTION: This JSON snippet illustrates a server declaring the 'resources' capability with only the 'listChanged' feature enabled. The server will notify clients when the list of available resources changes, but clients cannot subscribe to individual resource updates.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/resources

LANGUAGE: JSON
CODE:
```
{
  "capabilities": {
    "resources": {
      "listChanged": true
    }
  }
}
```

----------------------------------------

TITLE: Example of Correct Server Path Usage
DESCRIPTION: Demonstrates correct relative path usage for running the MCP client with a server script, specifically showing a Python server example.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: Shell
CODE:
```
# Relative path
uv run client.py ./server/weather.py
```

----------------------------------------

TITLE: Resource List Changed Notification
DESCRIPTION: Servers send this notification when the list of available resources changes, indicating that clients should update their understanding of available resources.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/resources

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "method": "notifications/resources/list_changed"
}
```

----------------------------------------

TITLE: Activate Virtual Environment and Install Packages (Unix/MacOS)
DESCRIPTION: Commands to activate a Python virtual environment and install necessary packages like 'mcp', 'anthropic', and 'python-dotenv' on Unix or MacOS systems.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: bash
CODE:
```
source .venv/bin/activate
uv add mcp anthropic python-dotenv
```

----------------------------------------

TITLE: Model Context Protocol notifications/roots/list_changed Notification
DESCRIPTION: Clients that support `listChanged` must send this notification when the list of roots changes, informing the server of the update.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/client/roots

LANGUAGE: APIDOC
CODE:
```
Notification:
  jsonrpc: "2.0"
  method: "notifications/roots/list_changed"
```

----------------------------------------

TITLE: MCP: Resource Updated Notification
DESCRIPTION: Servers send this JSON-RPC notification to subscribed clients when a monitored resource has been updated. The `uri` parameter indicates which resource has changed.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/resources

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "method": "notifications/resources/updated",
  "params": {
    "uri": "file:///project/src/main.rs"
  }
}
```

----------------------------------------

TITLE: Text Resource Content Format
DESCRIPTION: Defines the structure for text-based resource content, including its URI, MIME type, and the actual text content.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/resources

LANGUAGE: json
CODE:
```
{
  "uri": "file:///example.txt",
  "mimeType": "text/plain",
  "text": "Resource content"
}
```

----------------------------------------

TITLE: Model Context Protocol Log Levels
DESCRIPTION: The Model Context Protocol adopts standard syslog severity levels as defined in RFC 5424 for log messages, ranging from debug to emergency, each with a specific description and example use case.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/utilities/logging

LANGUAGE: APIDOC
CODE:
```
Log Levels (RFC 5424):
- debug: Detailed debugging information (e.g., Function entry/exit points)
- info: General informational messages (e.g., Operation progress updates)
- notice: Normal but significant events (e.g., Configuration changes)
- warning: Warning conditions (e.g., Deprecated feature usage)
- error: Error conditions (e.g., Operation failures)
- critical: Critical conditions (e.g., System component failures)
- alert: Action must be taken immediately (e.g., Data corruption detected)
- emergency: System is unusable (e.g., Complete system failure)
```

----------------------------------------

TITLE: MCP: Resource Data Type Definition
DESCRIPTION: Defines the structure of a resource within the Model Context Protocol. It includes fields for a unique identifier, human-readable name, optional description, and optional MIME type.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/resources

LANGUAGE: APIDOC
CODE:
```
Resource:
  uri: Unique identifier for the resource
  name: Human-readable name
  description: Optional description
  mimeType: Optional MIME type
```

----------------------------------------

TITLE: Check Claude Desktop Logs
DESCRIPTION: Commands to view Claude's Model Context Protocol (MCP) logs for troubleshooting, including general connection logs (mcp.log) and server-specific error logs (mcp-server-SERVERNAME.log). Includes versions for both macOS/Linux and Windows.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/user

LANGUAGE: Shell
CODE:
```
tail -n 20 -f ~/Library/Logs/Claude/mcp*.log
```

LANGUAGE: Windows Command Prompt
CODE:
```
type "%APPDATA%\Claude\logs\mcp*.log"
```

----------------------------------------

TITLE: APIDOC: CompleteResult Structure
DESCRIPTION: Defines the structure for a completion result, including suggestions, total matches, and a 'hasMore' flag.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/utilities/completion

LANGUAGE: APIDOC
CODE:
```
CompleteResult:
  completion:
    values: Array of suggestions (max 100)
    total: Optional total matches
    hasMore: Additional results flag
```

----------------------------------------

TITLE: Run MCP Client with Different Server Types
DESCRIPTION: Provides command-line examples for executing the .NET MCP client against various server implementations. These commands demonstrate how to specify the path to a .NET project, Python script, or Node.js script for the client to connect to.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: Shell
CODE:
```
dotnet run -- path/to/server.csproj # dotnet server
dotnet run -- path/to/server.py # python server
dotnet run -- path/to/server.js # node server
```

----------------------------------------

TITLE: Configure tsconfig.json for TypeScript Compilation
DESCRIPTION: Defines the TypeScript compiler options in `tsconfig.json`, specifying target ECMAScript version, module system, output directory, strictness, and inclusion/exclusion rules for source files.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: json
CODE:
```
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "Node16",
    "moduleResolution": "Node16",
    "outDir": "./build",
    "rootDir": "./",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["index.ts"],
  "exclude": ["node_modules"]
}
```

----------------------------------------

TITLE: Configure TypeScript Compiler Options (tsconfig.json)
DESCRIPTION: This JSON snippet defines the `tsconfig.json` file, which configures the TypeScript compiler. It specifies target ECMAScript version, module system, output and root directories, strict type checking, ES module interop, and other compiler options. It also defines which files to include and exclude from compilation.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: json
CODE:
```
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "Node16",
    "moduleResolution": "Node16",
    "outDir": "./build",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}
```

----------------------------------------

TITLE: Open Claude for Desktop Configuration File
DESCRIPTION: This snippet provides commands to open the Claude for Desktop configuration file (`claude_desktop_config.json`) using VS Code. It includes commands for MacOS/Linux and Windows operating systems. This file is essential for configuring MCP servers.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: bash
CODE:
```
code ~/Library/Application\ Support/Claude/claude_desktop_config.json
```

LANGUAGE: bash
CODE:
```
code $env:AppData\Claude\claude_desktop_config.json
```

----------------------------------------

TITLE: Open Claude for Desktop Configuration File
DESCRIPTION: Commands to open the `claude_desktop_config.json` file in a text editor (e.g., VS Code) for configuring Claude for Desktop on different operating systems.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: Shell (MacOS/Linux)
CODE:
```
code ~/Library/Application\ Support/Claude/claude_desktop_config.json
```

LANGUAGE: Shell (Windows)
CODE:
```
code $env:AppData\Claude\claude_desktop_config.json
```

----------------------------------------

TITLE: JSON-RPC Response: Accept Structured Data
DESCRIPTION: This JSON-RPC response indicates that the client has accepted the structured data request and provided the requested information. The "content" field contains the submitted data matching the schema.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client/elicitation

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "action": "accept",
    "content": {
      "name": "Monalisa Octocat",
      "email": "[email protected]",
      "age": 30
    }
  }
}
```

----------------------------------------

TITLE: Running the MCP Client with Python or Node.js Servers
DESCRIPTION: Commands to execute the MCP client, connecting it to either a Python-based or Node.js-based server script. This demonstrates the `uv run` command with different server script types.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: Shell
CODE:
```
uv run client.py path/to/server.py # python server
uv run client.py path/to/build/index.js # node server
```

----------------------------------------

TITLE: JSON-RPC Response Actions Structure
DESCRIPTION: This JSON-RPC response example illustrates the three-action model for elicitation responses: 'accept', 'decline', or 'cancel'. The 'content' field is included only for 'accept' actions, containing the submitted data.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client/elicitation

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "action": "accept", // or "decline" or "cancel"
    "content": {
      "propertyName": "value",
      "anotherProperty": 42
    }
  }
}
```

----------------------------------------

TITLE: Tool List Changed Notification (JSON-RPC)
DESCRIPTION: Shows the JSON-RPC notification sent by servers to clients when the list of available tools has changed.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/tools

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "method": "notifications/tools/list_changed"
}
```

----------------------------------------

TITLE: Add Optional Spring WebFlux Transport Dependency
DESCRIPTION: Include this optional dependency if you are using the Spring Framework and require Spring WebFlux-based SSE client and server transport implementations for the MCP SDK.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-overview

LANGUAGE: Maven
CODE:
```
<!-- Optional: Spring WebFlux-based SSE client and server transport -->
<dependency>
    <groupId>io.modelcontextprotocol.sdk</groupId>
    <artifactId>mcp-spring-webflux</artifactId>
</dependency>
```

LANGUAGE: Gradle
CODE:
```
// Optional: Spring WebFlux-based SSE client and server transport
dependencies {
  implementation platform("io.modelcontextprotocol.sdk:mcp-spring-webflux")
}
```

----------------------------------------

TITLE: JSON-RPC Notification for Prompt List Changes
DESCRIPTION: Servers that support the `listChanged` capability should send this notification when the list of available prompts changes, informing clients of updates.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/prompts

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "method": "notifications/prompts/list_changed"
}
```

----------------------------------------

TITLE: APIDOC: Standard JSON-RPC Error Codes
DESCRIPTION: Describes standard JSON-RPC error codes that servers should return for common failure cases in the completion protocol.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/utilities/completion

LANGUAGE: APIDOC
CODE:
```
Error Handling:
  Method not found: -32601 (Capability not supported)
  Invalid prompt name: -32602 (Invalid params)
  Missing required arguments: -32602 (Invalid params)
  Internal errors: -32603 (Internal error)
```

----------------------------------------

TITLE: Open Claude for Desktop Configuration File
DESCRIPTION: Commands to open the `claude_desktop_config.json` file for Claude for Desktop using VS Code, providing specific paths for MacOS/Linux and Windows operating systems. This file is used to configure MCP servers.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: Shell
CODE:
```
code ~/Library/Application\ Support/Claude/claude_desktop_config.json
```

LANGUAGE: Shell
CODE:
```
code $env:AppData\Claude\claude_desktop_config.json
```

----------------------------------------

TITLE: MCP: Text Resource Content Structure
DESCRIPTION: Defines the JSON structure for resources containing text data. It includes the resource's URI, MIME type (e.g., `text/plain`), and the actual text content.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/resources

LANGUAGE: JSON
CODE:
```
{
  "uri": "file:///example.txt",
  "mimeType": "text/plain",
  "text": "Resource content"
}
```

----------------------------------------

TITLE: APIDOC: roots/list Request
DESCRIPTION: Describes the JSON-RPC 2.0 request sent by a server to retrieve the current list of roots from a client.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client

LANGUAGE: APIDOC
CODE:
```
Method: roots/list
Request:
  jsonrpc: string (2.0)
  id: number
  method: string ("roots/list")
```

----------------------------------------

TITLE: Model Context Protocol Client Response for Roots List Request
DESCRIPTION: Clients respond to a 'roots/list' request with a JSON-RPC 2.0 response containing an array of 'root' objects. Each root object specifies a URI and an optional human-readable name.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/client

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "roots": [
      {
        "uri": "file:///home/user/projects/myproject",
        "name": "My Project"
      }
    ]
  }
}
```

----------------------------------------

TITLE: APIDOC: roots/list Response
DESCRIPTION: Describes the JSON-RPC 2.0 response returned by a client to a 'roots/list' request, containing an array of 'Root' objects.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client

LANGUAGE: APIDOC
CODE:
```
Method: roots/list
Response:
  jsonrpc: string (2.0)
  id: number
  result:
    roots: array of Root
      Description: An array of Root objects exposed by the client.
```

----------------------------------------

TITLE: Declare Resource Capability with No Features
DESCRIPTION: Shows how a server declares support for the Model Context Protocol's resource capability without enabling either the subscription or list change notification features, indicating basic resource support.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/resources

LANGUAGE: JSON
CODE:
```
{
  "capabilities": {
    "resources": {} 
  }
}
```

----------------------------------------

TITLE: JSON: Audio Content Type for PromptMessage
DESCRIPTION: Allows including audio information in messages. The audio data must be base64-encoded and include a valid MIME type, facilitating multi-modal interactions where audio context is important.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/prompts

LANGUAGE: APIDOC
CODE:
```
{
  "type": "audio",
  "data": "base64-encoded-audio-data",
  "mimeType": "audio/wav"
}
```

----------------------------------------

TITLE: Example Model Context Protocol Root for a Single Project Directory
DESCRIPTION: This example demonstrates a single 'Root' object representing a project directory. It specifies the file URI and an optional name for the project.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/client

LANGUAGE: JSON
CODE:
```
{
  "uri": "file:///home/user/projects/myproject",
  "name": "My Project"
}
```

----------------------------------------

TITLE: Tool Result Embedded Resource Format
DESCRIPTION: Specifies the JSON structure for an embedded resource content item within a tool's result, including URI, MIME type, and optional text content.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/tools

LANGUAGE: JSON
CODE:
```
{
  "type": "resource",
  "resource": {
    "uri": "resource://example",
    "mimeType": "text/plain",
    "text": "Resource content"
  }
}
```

----------------------------------------

TITLE: Model Context Protocol Pagination Request Format
DESCRIPTION: This JSON snippet demonstrates how a client continues pagination by including the `cursor` received from a previous response in its subsequent request.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/utilities/pagination

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "method": "resources/list",
  "params": {
    "cursor": "eyJwYWdlIjogMn0="
  }
}
```

----------------------------------------

TITLE: Configure MCP Weather Server in Claude Desktop
DESCRIPTION: This JSON snippet demonstrates how to add an MCP server named "weather" to the `mcpServers` key in the Claude for Desktop configuration. It specifies the command to launch the server using `dotnet run` and the absolute path to the project.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: json
CODE:
```
{
  "mcpServers": {
    "weather": {
      "command": "dotnet",
      "args": ["run", "--project", "/ABSOLUTE/PATH/TO/PROJECT", "--no-build"]
    }
  }
}
```

LANGUAGE: json
CODE:
```
{
  "mcpServers": {
    "weather": {
      "command": "dotnet",
      "args": [
        "run",
        "--project",
        "C:\\ABSOLUTE\\PATH\\TO\\PROJECT",
        "--no-build"
      ]
    }
  }
}
```

----------------------------------------

TITLE: Declare Resource Capability with List Change Notifications Only
DESCRIPTION: Demonstrates how a server declares support for the Model Context Protocol's resource capability, enabling only the list change notification feature to inform clients when the overall list of available resources changes.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/resources

LANGUAGE: JSON
CODE:
```
{
  "capabilities": {
    "resources": {
      "listChanged": true 
    }
  }
}
```

----------------------------------------

TITLE: Client Request to Set Log Level
DESCRIPTION: Clients can send a 'logging/setLevel' JSON-RPC request to configure the minimum log level for messages received from the server. The 'level' parameter specifies the desired log severity, filtering out messages below this level.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/utilities/logging

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "logging/setLevel",
  "params": {
    "level": "info"
  }
}
```

----------------------------------------

TITLE: JSON-RPC Response: Decline Structured Data Request
DESCRIPTION: This JSON-RPC response signifies that the client has explicitly declined the structured data request. The "content" field is typically omitted in this case.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client/elicitation

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "action": "decline"
  }
}
```

----------------------------------------

TITLE: Set Anthropic API Key Environment Variable
DESCRIPTION: This shell command shows how to set your Anthropic API key as an environment variable. It's a common practice for securely providing credentials to applications without hardcoding them directly into the source code.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: Shell
CODE:
```
export ANTHROPIC_API_KEY='your-anthropic-api-key-here'
```

----------------------------------------

TITLE: Client Response with List of Roots
DESCRIPTION: Clients respond to a 'roots/list' request with a JSON object containing an array of root definitions. Each root includes a URI and an optional human-readable name.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client/roots

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "roots": [
      {
        "uri": "file:///home/user/projects/myproject",
        "name": "My Project"
      }
    ]
  }
}
```

----------------------------------------

TITLE: Examples of Correct Server Path Usage
DESCRIPTION: Illustrates various correct ways to specify the server path when running the client, including relative, absolute, and Windows-specific formats (forward and backslashes).
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: Shell
CODE:
```
# Relative path
node build/index.js ./server/build/index.js

# Absolute path
node build/index.js /Users/username/projects/mcp-server/build/index.js

# Windows path (either format works)
node build/index.js C:/projects/mcp-server/build/index.js
node build/index.js C:\\projects\\mcp-server\\build\\index.js
```

----------------------------------------

TITLE: Demonstrate Server Path Usage for MCP Client
DESCRIPTION: This snippet provides examples of how to correctly specify server paths when running the MCP client, including relative paths, absolute paths, and Windows-specific path formats (forward slashes and escaped backslashes). It illustrates flexibility in path specification for different operating systems.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: shell
CODE:
```
# Relative path
java -jar build/libs/client.jar ./server/build/libs/server.jar

# Absolute path
java -jar build/libs/client.jar /Users/username/projects/mcp-server/build/libs/server.jar

# Windows path (either format works)
java -jar build/libs/client.jar C:/projects/mcp-server/build/libs/server.jar
java -jar build/libs/client.jar C:\\projects\\mcp-server\\build\\libs\\server.jar
```

----------------------------------------

TITLE: MCP Multiple Simultaneous SSE Connections
DESCRIPTION: Describes the rules for managing multiple simultaneous SSE connections between a client and an MCP server, ensuring message delivery integrity.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/basic/transports

LANGUAGE: APIDOC
CODE:
```
Multiple Connections:
  Client: MAY remain connected to multiple SSE streams simultaneously.
  Server: MUST send each JSON-RPC message on only one connected stream (MUST NOT broadcast).
  Mitigation: Risk of message loss MAY be mitigated by making the stream resumable.
```

----------------------------------------

TITLE: JSON Schema: Number/Integer Type Definition
DESCRIPTION: This JSON Schema snippet defines a number or integer property, showcasing the use of "minimum" and "maximum" constraints to specify a valid range for numerical input.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client/elicitation

LANGUAGE: json
CODE:
```
{
  "type": "number", // or "integer"
  "title": "Display Name",
  "description": "Description text",
  "minimum": 0,
  "maximum": 100
}
```

----------------------------------------

TITLE: Install Amazon Q CLI using Homebrew
DESCRIPTION: This command installs the Amazon Q CLI, an open-source agentic coding assistant for terminals, on macOS and Linux systems using the Homebrew package manager. It provides full support for MCP servers and various other features.
SOURCE: https://modelcontextprotocol.io/introduction/clients

LANGUAGE: Shell
CODE:
```
brew install amazon-q
```

----------------------------------------

TITLE: Model Context Protocol Ping Request and Response Messages
DESCRIPTION: Defines the JSON-RPC message formats for initiating and responding to a ping request within the Model Context Protocol. The request is a standard JSON-RPC call with no parameters, and the response is an empty result object.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/basic/utilities/ping

LANGUAGE: APIDOC
CODE:
```
{
  "jsonrpc": "2.0",
  "id": "123",
  "method": "ping"
}
```

LANGUAGE: APIDOC
CODE:
```
{
  "jsonrpc": "2.0",
  "id": "123",
  "result": {}
}
```

----------------------------------------

TITLE: Initiate Ping Request (JSON-RPC)
DESCRIPTION: This JSON-RPC request initiates a ping to verify the responsiveness of the counterpart. It is a standard request with the method 'ping' and no parameters, identified by a unique ID.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/basic/utilities/ping

LANGUAGE: JSON
CODE:
```
{
  "jsonrpc": "2.0",
  "id": "123",
  "method": "ping"
}
```

----------------------------------------

TITLE: Configure APPDATA Environment Variable in Claude Desktop Config
DESCRIPTION: Example JSON configuration for claude_desktop_config.json demonstrating how to add the APPDATA environment variable to resolve ENOENT errors on Windows, particularly when using servers like brave-search.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/user

LANGUAGE: JSON
CODE:
```
{
  "brave-search": {
    "command": "npx",
    "args": ["-y", "@modelcontextprotocol/server-brave-search"],
    "env": {
      "APPDATA": "C:\\Users\\user\\AppData\\Roaming\\",
      "BRAVE_API_KEY": "..."
    }
  }
}
```

----------------------------------------

TITLE: Model Context Protocol Log Levels (RFC 5424)
DESCRIPTION: The Model Context Protocol adopts the standard syslog severity levels as specified in RFC 5424. This API documentation outlines each log level, its general description, and an example use case, providing a clear understanding of message criticality from 'debug' to 'emergency'.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/utilities/logging

LANGUAGE: APIDOC
CODE:
```
Level | Description | Example Use Case
--- | --- | ---
debug | Detailed debugging information | Function entry/exit points
info | General informational messages | Operation progress updates
notice | Normal but significant events | Configuration changes
warning | Warning conditions | Deprecated feature usage
error | Error conditions | Operation failures
critical | Critical conditions | System component failures
alert | Action must be taken immediately | Data corruption detected
emergency | System is unusable | Complete system failure
```

----------------------------------------

TITLE: Create Pure Java HTTP Client SSE Transport
DESCRIPTION: Initializes a framework-agnostic SSE client transport using HttpClientSseClientTransport, connecting to a specified MCP server URL for pure Java API communication.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-client

LANGUAGE: Java
CODE:
```
McpTransport transport = new HttpClientSseClientTransport("http://your-mcp-server");
```

----------------------------------------

TITLE: Run MCP Inspector with Basic Commands
DESCRIPTION: Demonstrates the fundamental command-line usage of the MCP Inspector tool, showing how to invoke it with a command and optional arguments directly via npx.
SOURCE: https://modelcontextprotocol.io/introduction/docs/tools/inspector

LANGUAGE: Shell
CODE:
```
npx @modelcontextprotocol/inspector <command>
```

LANGUAGE: Shell
CODE:
```
npx @modelcontextprotocol/inspector <command> <arg1> <arg2>
```

----------------------------------------

TITLE: Tool Result Resource Link Content Format
DESCRIPTION: JSON structure for returning a link to an external resource within a tool result. It provides the resource's URI, an optional name, description, and MIME type.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/tools

LANGUAGE: json
CODE:
```
{
  "type": "resource_link",
  "uri": "file:///project/src/main.rs",
  "name": "main.rs",
  "description": "Primary application entry point",
  "mimeType": "text/x-rust"
}
```

----------------------------------------

TITLE: JSON-RPC Response: Cancel Structured Data Request
DESCRIPTION: This JSON-RPC response indicates that the client has dismissed the structured data request without making an explicit choice. The "content" field is typically omitted.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/client/elicitation

LANGUAGE: json
CODE:
```
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "action": "cancel"
  }
}
```

----------------------------------------

TITLE: Model Context Protocol Root Data Type Example: Project Directory
DESCRIPTION: An example of a single root definition representing a project directory. It includes a `file://` URI and an optional human-readable name.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/client/roots

LANGUAGE: JSON
CODE:
```
{
  "uri": "file:///home/user/projects/myproject",
  "name": "My Project"
}
```

----------------------------------------

TITLE: Tool Result Image Content Format
DESCRIPTION: JSON structure for representing image content within a tool result. It includes the content type as 'image', base64-encoded image data, and the MIME type of the image.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/tools

LANGUAGE: json
CODE:
```
{
  "type": "image",
  "data": "base64-encoded-data",
  "mimeType": "image/png"
}
```

----------------------------------------

TITLE: JSON Structure for Image Tool Result Content
DESCRIPTION: Represents an image-based content item within a tool result. It includes the content type as 'image', the base64-encoded image data, and its corresponding MIME type (e.g., 'image/png').
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/tools

LANGUAGE: JSON
CODE:
```
{
  "type": "image",
  "data": "base64-encoded-data",
  "mimeType": "image/png"
}
```

----------------------------------------

TITLE: Verify Node.js and npm Versions
DESCRIPTION: This snippet provides commands to check the installed versions of Node.js and npm. It's a crucial step to ensure that the development environment meets the minimum requirements (Node.js version 16 or higher) for the tutorial.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: bash
CODE:
```
node --version
npm --version
```

----------------------------------------

TITLE: Tool Result Audio Content Format
DESCRIPTION: JSON structure for representing audio content within a tool result. It includes the content type as 'audio', base64-encoded audio data, and the MIME type of the audio.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/tools

LANGUAGE: json
CODE:
```
{
  "type": "audio",
  "data": "base64-encoded-audio-data",
  "mimeType": "audio/wav"
}
```

----------------------------------------

TITLE: Create and Initialize New C# Console Project
DESCRIPTION: These commands create a new directory for the project, navigate into it, and then initialize a new C# console application using the .NET CLI. This sets up the basic project structure for your server.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: Shell
CODE:
```
mkdir weather
cd weather
dotnet new console
```

----------------------------------------

TITLE: Verify Node.js Installation
DESCRIPTION: Use this command in your terminal or command prompt to check if Node.js is correctly installed on your system. A version number should be displayed if successful; otherwise, you may need to download Node.js from nodejs.org.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/user

LANGUAGE: Shell
CODE:
```
node --version
```

----------------------------------------

TITLE: Run C# Server Application
DESCRIPTION: This command executes the compiled C# server application. It initiates the server process, which then listens for and handles incoming requests via standard input/output.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: Bash
CODE:
```
dotnet run
```

----------------------------------------

TITLE: Python Helper Functions for NWS API Interaction
DESCRIPTION: Defines two asynchronous Python helper functions: `make_nws_request` for robustly querying the National Weather Service API with proper headers and error handling, and `format_alert` for structuring raw alert data into a human-readable string.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: Python
CODE:
```
async def make_nws_request(url: str) -> dict[str, Any] | None:
    """Make a request to the NWS API with proper error handling."""
    headers = {
        "User-Agent": USER_AGENT,
        "Accept": "application/geo+json"
    }
    async with httpx.AsyncClient() as client:
        try:
            response = await client.get(url, headers=headers, timeout=30.0)
            response.raise_for_status()
            return response.json()
        except Exception:
            return None

def format_alert(feature: dict) -> str:
    """Format an alert feature into a readable string."""
    props = feature["properties"]
    return f"""
Event: {props.get('event', 'Unknown')}
Area: {props.get('areaDesc', 'Unknown')}
Severity: {props.get('severity', 'Unknown')}
Description: {props.get('description', 'No description available')}
Instructions: {props.get('instruction', 'No specific instructions provided')}
"""
```

----------------------------------------

TITLE: Add Optional Spring WebMVC Transport Dependency
DESCRIPTION: Include this optional dependency if you are using the Spring Framework and require Spring WebMVC-based SSE server transport implementations for the MCP SDK.
SOURCE: https://modelcontextprotocol.io/introduction/sdk/java/mcp-overview

LANGUAGE: Maven
CODE:
```
<!-- Optional: Spring WebMVC-based SSE server transport -->
<dependency>
    <groupId>io.modelcontextprotocol.sdk</groupId>
    <artifactId>mcp-spring-webmvc</artifactId>
</dependency>
```

LANGUAGE: Gradle
CODE:
```
// Optional: Spring WebMVC-based SSE server transport
dependencies {
  implementation platform("io.modelcontextprotocol.sdk:mcp-spring-webmvc")
}
```

----------------------------------------

TITLE: JSON: Configure MCP Weather Server in Claude for Desktop
DESCRIPTION: This JSON snippet illustrates how to configure an MCP server within the `claude_desktop_config.json` file. It defines a server named 'weather' and specifies the `java -jar` command along with the absolute path to its executable JAR file, enabling Claude for Desktop to launch and connect to it.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: json
CODE:
```
{
  "mcpServers": {
    "weather": {
      "command": "java",
      "args": [
        "-jar",
        "/ABSOLUTE/PATH/TO/PARENT/FOLDER/weather/build/libs/weather-0.1.0-all.jar"
      ]
    }
  }
}
```

----------------------------------------

TITLE: Create Client File
DESCRIPTION: Command to create an empty 'client.py' file where the main client code will reside.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: bash
CODE:
```
touch client.py
```

----------------------------------------

TITLE: HTTPS URI Scheme Usage Guidelines
DESCRIPTION: Guidelines for using the `https://` URI scheme within the protocol. Servers should only use this scheme if clients can directly fetch the resource from the web; otherwise, other or custom URI schemes are preferred.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/resources

LANGUAGE: APIDOC
CODE:
```
https://:
  Used to represent a resource available on the web.
  Servers SHOULD use this scheme only when the client is able to fetch and load the
  resource directly from the web on its own—that is, it doesn’t need to read the resource
  via the MCP server.
  For other use cases, servers SHOULD prefer to use another URI scheme, or define a
  custom one, even if the server will itself be downloading resource contents over the
  internet.
```

----------------------------------------

TITLE: Install uv on MacOS/Linux
DESCRIPTION: This command installs `uv`, a fast Python package installer and dependency manager, on MacOS and Linux systems. A terminal restart is recommended after installation to ensure the `uv` command is available.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: Shell
CODE:
```
curl -LsSf https://astral.sh/uv/install.sh | sh
```

----------------------------------------

TITLE: Install `uv` Package Manager on MacOS/Linux
DESCRIPTION: This command downloads and executes the `uv` installation script for MacOS/Linux. `uv` is a fast Python package installer and resolver. Users should restart their terminal after installation.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: Shell
CODE:
```
curl -LsSf https://astral.sh/uv/install.sh | sh
```

----------------------------------------

TITLE: Install NPM Globally
DESCRIPTION: Command to install Node Package Manager (NPM) globally, which is required for npx commands to function correctly and avoid failures.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/user

LANGUAGE: Shell
CODE:
```
npm install -g npm
```

----------------------------------------

TITLE: Verify .NET SDK Installation
DESCRIPTION: This command checks and displays the installed version of the .NET SDK, confirming that the environment is ready for .NET development.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: Shell
CODE:
```
dotnet --version
```

----------------------------------------

TITLE: Manually Create and Use MCP Client in Java
DESCRIPTION: Demonstrates how to manually instantiate and use `McpClient` in Java to connect to a server, initialize it, list tools, call specific tools like `getWeatherForecastByLocation` and `getAlerts`, and gracefully close the client. This snippet shows direct API usage without Spring Boot auto-configuration.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: Java
CODE:
```
var stdioParams = ServerParameters.builder("java")
  .args("-jar", "/ABSOLUTE/PATH/TO/PARENT/FOLDER/mcp-weather-stdio-server-0.0.1-SNAPSHOT.jar")
  .build();

var stdioTransport = new StdioClientTransport(stdioParams);

var mcpClient = McpClient.sync(stdioTransport).build();

mcpClient.initialize();

ListToolsResult toolsList = mcpClient.listTools();

CallToolResult weather = mcpClient.callTool(
  new CallToolRequest("getWeatherForecastByLocation",
      Map.of("latitude", "47.6062", "longitude", "-122.3321")));

CallToolResult alert = mcpClient.callTool(
  new CallToolRequest("getAlerts", Map.of("state", "NY")));

mcpClient.closeGracefully();
```

----------------------------------------

TITLE: MCP: File URI Scheme Usage
DESCRIPTION: Describes the usage of the `file://` URI scheme, identifying resources that behave like a filesystem. It notes that these resources do not necessarily map to a physical filesystem and may use XDG MIME types for non-regular files.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/resources

LANGUAGE: APIDOC
CODE:
```
file://:
  Description: Used to identify resources that behave like a filesystem. However, the resources do not need to map to an actual physical filesystem.
  MIME Type Note: MCP servers MAY identify file:// resources with an XDG MIME type, like `inode/directory`, to represent non-regular files (such as directories) that don’t otherwise have a standard MIME type.
```

----------------------------------------

TITLE: C# HttpClient Extension for JSON Document Reading
DESCRIPTION: This C# extension class simplifies reading JSON documents from HTTP responses. It handles GET requests, ensures success status codes, and parses the response content into a JsonDocument for easy consumption.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: C#
CODE:
```
using System.Text.Json;

internal static class HttpClientExt
{
    public static async Task<JsonDocument> ReadJsonDocumentAsync(this HttpClient client, string requestUri)
    {
        using var response = await client.GetAsync(requestUri);
        response.EnsureSuccessStatusCode();
        return await JsonDocument.ParseAsync(await response.Content.ReadAsStreamAsync());
    }
}
```

----------------------------------------

TITLE: APIDOC: Security Requirements
DESCRIPTION: Outlines essential security requirements for implementations, including input validation, rate limiting, access control, and preventing information disclosure.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/server/utilities/completion

LANGUAGE: APIDOC
CODE:
```
Security:
  Implementations MUST:
    - Validate all completion inputs
    - Implement appropriate rate limiting
    - Control access to sensitive suggestions
    - Prevent completion-based information disclosure
```

----------------------------------------

TITLE: Build and Run Spring AI Chatbot (Maven)
DESCRIPTION: These shell commands illustrate how to compile and run the Spring AI chatbot application using Maven. The first command cleans and installs the project, while the second executes the packaged JAR. An alternative command for direct Spring Boot execution is also provided.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: Shell
CODE:
```
./mvnw clean install
java -jar ./target/ai-mcp-brave-chatbot-0.0.1-SNAPSHOT.jar
```

LANGUAGE: Shell
CODE:
```
./mvnw spring-boot:run
```

----------------------------------------

TITLE: Create .env File
DESCRIPTION: Command to create an empty '.env' file for securely storing API keys and other environment variables.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: bash
CODE:
```
touch .env
```

----------------------------------------

TITLE: Connect to Deprecated SSE Server with TypeScript Client
DESCRIPTION: This snippet shows how to establish a connection to a deprecated SSE server from a TypeScript client. It initializes an MCP Client instance and uses `SSEClientTransport` to connect to the server endpoint.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/transports

LANGUAGE: TypeScript
CODE:
```
const client = new Client({
  name: "example-client",
  version: "1.0.0"
}, {
  capabilities: {}
});

const transport = new SSEClientTransport(
  new URL("http://localhost:3000/sse")
);
await client.connect(transport);
```

----------------------------------------

TITLE: Model Context Protocol Operations Supporting Pagination
DESCRIPTION: This section lists the Model Context Protocol (MCP) operations that support pagination, allowing clients to retrieve large result sets in smaller, manageable chunks.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/server/utilities/pagination

LANGUAGE: APIDOC
CODE:
```
resources/list - List available resources
resources/templates/list - List resource templates
prompts/list - List available prompts
tools/list - List available tools
```

----------------------------------------

TITLE: Configure Spring Boot Application Properties
DESCRIPTION: Example `application.properties` configuration to disable the Spring Boot banner and clear the console logging pattern for a Spring AI MCP server application.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: Properties
CODE:
```
spring.main.bannerMode=off
logging.pattern.console=
```

----------------------------------------

TITLE: Install npx Package Manager
DESCRIPTION: Command to globally install the npx package executor using npm, which is required for running the Brave Search MCP server.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: Bash
CODE:
```
npm install -g npx
```

----------------------------------------

TITLE: MCP: Git URI Scheme Usage
DESCRIPTION: Describes the `git://` URI scheme, indicating its use for Git version control integration within the Model Context Protocol.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/resources

LANGUAGE: APIDOC
CODE:
```
git://:
  Description: Git version control integration.
```

----------------------------------------

TITLE: Shell: Open Claude for Desktop Configuration File
DESCRIPTION: This shell command, applicable to MacOS/Linux, opens the `claude_desktop_config.json` file in VS Code. This file is used to configure MCP servers for Claude for Desktop, allowing users to define server names and their launch commands.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: shell
CODE:
```
code ~/Library/Application\ Support/Claude/claude_desktop_config.json
```

----------------------------------------

TITLE: Define JSON-RPC 2.0 Request Structure for MCP
DESCRIPTION: Describes the mandatory JSON-RPC 2.0 request format used in the Model Context Protocol. Requests must include a unique, non-null string or integer ID and a method name, with optional parameters. The ID must not have been previously used by the requestor within the same session.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2025-03-26/basic

LANGUAGE: APIDOC
CODE:
```
{
  jsonrpc: "2.0";
  id: string | number;
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

----------------------------------------

TITLE: Security Considerations for Tooling
DESCRIPTION: Outlines critical security measures for both servers and clients when implementing and using tools, covering validation, access control, rate limiting, sanitization, user confirmation, and logging.
SOURCE: https://modelcontextprotocol.io/introduction/specification/2024-11-05/server/tools

LANGUAGE: APIDOC
CODE:
```
Servers MUST:
  - Validate all tool inputs
  - Implement proper access controls
  - Rate limit tool invocations
  - Sanitize tool outputs
Clients SHOULD:
  - Prompt for user confirmation on sensitive operations
  - Show tool inputs to the user before calling the server, to avoid malicious or accidental data exfiltration
  - Validate tool results before passing to LLM
  - Implement timeouts for tool calls
  - Log tool usage for audit purposes
```

----------------------------------------

TITLE: Enable Chrome DevTools in Claude Desktop
DESCRIPTION: This command creates or updates the `developer_settings.json` file to enable Chrome DevTools within Claude Desktop, allowing access to client-side error inspection via the Console and Network panels.
SOURCE: https://modelcontextprotocol.io/introduction/docs/tools/debugging

LANGUAGE: Shell
CODE:
```
echo '{"allowDevTools": true}' > ~/Library/Application\ Support/Claude/developer_settings.json
```

----------------------------------------

TITLE: Add Gradle Shadow Plugin
DESCRIPTION: This snippet demonstrates how to add the `com.github.johnrengelman.shadow` plugin to your Gradle build script, presented in both Kotlin DSL and Groovy DSL. This plugin is commonly used to create a 'fat JAR' or 'uber JAR' that includes all project dependencies.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: Kotlin
CODE:
```
plugins {
    id("com.github.johnrengelman.shadow") version "8.1.1"
}
```

LANGUAGE: Groovy
CODE:
```
plugins {
    id("com.github.johnrengelman.shadow") version "8.1.1"
}
```

----------------------------------------

TITLE: Open Claude for Desktop Configuration File
DESCRIPTION: This snippet provides commands to open the `claude_desktop_config.json` file in a text editor like VS Code. Separate commands are provided for MacOS/Linux and Windows operating systems to access the configuration file.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/server

LANGUAGE: bash
CODE:
```
code ~/Library/Application\ Support/Claude/claude_desktop_config.json
```

LANGUAGE: bash
CODE:
```
code $env:AppData\Claude\claude_desktop_config.json
```

----------------------------------------

TITLE: Configure package.json for TypeScript Module
DESCRIPTION: Shows the required `package.json` configuration to set the project type as a module and define a build script using TypeScript compiler (`tsc`), including setting executable permissions for the built JavaScript file.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: json
CODE:
```
{
  "type": "module",
  "scripts": {
    "build": "tsc && chmod 755 build/index.js"
  }
}
```

----------------------------------------

TITLE: Initialize Kotlin Project with Gradle (MacOS/Linux)
DESCRIPTION: These shell commands guide you through creating and initializing a new Kotlin project using Gradle on MacOS or Linux. It involves creating a new directory, navigating into it, and running `gradle init` to set up the project structure.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: Shell
CODE:
```
# Create a new directory for our project
mkdir kotlin-mcp-client
cd kotlin-mcp-client

# Initialize a new kotlin project
gradle init
```

----------------------------------------

TITLE: Server Guidelines for Backwards Compatibility with HTTP+SSE Transport
DESCRIPTION: Guidelines for servers to support older clients using the deprecated HTTP+SSE transport (from protocol version 2024-11-05), advising to maintain both old and new endpoints for seamless transition.
SOURCE: https://modelcontextprotocol.io/introduction/specification/draft/basic/transports

LANGUAGE: APIDOC
CODE:
```
Servers wanting to support older clients should:
- Continue to host both the SSE and POST endpoints of the old transport.
- Host the new "MCP endpoint" defined for the Streamable HTTP transport.
- It is also possible to combine the old POST endpoint and the new MCP endpoint, but this may introduce unneeded complexity.
```

----------------------------------------

TITLE: Set Environment Variables for API Keys
DESCRIPTION: Commands to set environment variables for your Anthropic API key (for Claude AI) and Brave Search API key. Replace the placeholder values with your actual keys.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: Bash
CODE:
```
export ANTHROPIC_API_KEY='your-anthropic-api-key-here'
export BRAVE_API_KEY='your-brave-api-key-here'
```

----------------------------------------

TITLE: Implement Deprecated SSE Server with TypeScript Express
DESCRIPTION: This snippet demonstrates how to set up a deprecated Server-Sent Events (SSE) server using TypeScript and Express. It initializes an MCP Server instance and handles both GET requests for SSE connections and POST requests for message handling.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/transports

LANGUAGE: TypeScript
CODE:
```
import express from "express";

const app = express();

const server = new Server({
  name: "example-server",
  version: "1.0.0"
}, {
  capabilities: {}
});

let transport: SSEServerTransport | null = null;

app.get("/sse", (req, res) => {
  transport = new SSEServerTransport("/messages", res);
  server.connect(transport);
});

app.post("/messages", (req, res) => {
  if (transport) {
    transport.handlePostMessage(req, res);
  }
});

app.listen(3000);
```

----------------------------------------

TITLE: Clone and Navigate Spring AI Examples Repository
DESCRIPTION: Commands to clone the Spring AI examples repository from GitHub and navigate into the specific 'brave-chatbot' project directory.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: Bash
CODE:
```
git clone https://github.com/spring-projects/spring-ai-examples.git
cd model-context-protocol/brave-chatbot
```

----------------------------------------

TITLE: Implement Deprecated SSE Server with Python Starlette
DESCRIPTION: This snippet illustrates how to set up a deprecated Server-Sent Events (SSE) server using Python and Starlette. It defines routes for SSE connections and POST message handling, integrating with `SseServerTransport`.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/transports

LANGUAGE: Python
CODE:
```
from mcp.server.sse import SseServerTransport
from starlette.applications import Starlette
from starlette.routing import Route

app = Server("example-server")
sse = SseServerTransport("/messages")

async def handle_sse(scope, receive, send):
    async with sse.connect_sse(scope, receive, send) as streams:
        await app.run(streams[0], streams[1], app.create_initialization_options())

async def handle_messages(scope, receive, send):
    await sse.handle_post_message(scope, receive, send)

starlette_app = Starlette(
    routes=[
        Route("/sse", endpoint=handle_sse),
        Route("/messages", endpoint=handle_messages, methods=["POST"]),
    ]
)
```

----------------------------------------

TITLE: Connect to Deprecated SSE Server with Python Client
DESCRIPTION: This snippet demonstrates how to connect to a deprecated SSE server from a Python client. It uses `sse_client` and `ClientSession` to establish and manage the connection.
SOURCE: https://modelcontextprotocol.io/introduction/docs/concepts/transports

LANGUAGE: Python
CODE:
```
async with sse_client("http://localhost:8000/sse") as streams:
    async with ClientSession(streams[0], streams[1]) as session:
        await session.initialize()
```

----------------------------------------

TITLE: Remove Boilerplate Files
DESCRIPTION: Commands to delete the default 'main.py' file on both Windows and Unix/MacOS systems.
SOURCE: https://modelcontextprotocol.io/introduction/quickstart/client

LANGUAGE: bash
CODE:
```
del main.py
```

LANGUAGE: bash
CODE:
```
rm main.py
```